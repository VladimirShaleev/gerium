diff --git a/sdk/CMakeLists.txt b/sdk/CMakeLists.txt
index f271025..24dd702 100644
--- a/sdk/CMakeLists.txt
+++ b/sdk/CMakeLists.txt
@@ -89,7 +89,8 @@ elseif(CMAKE_GENERATOR_PLATFORM STREQUAL "arm64" OR CMAKE_EXE_LINKER_FLAGS STREQ
 elseif(CMAKE_GENERATOR_PLATFORM STREQUAL "arm64ec" OR CMAKE_EXE_LINKER_FLAGS STREQUAL "/machine:ARM64EC")
 	set(FFX_PLATFORM_NAME arm64ec)
 else()
-    message(FATAL_ERROR "Unsupported target platform \"${CMAKE_GENERATOR_PLATFORM}\"")
+	set(FFX_PLATFORM_NAME native)
+    # message(FATAL_ERROR "Unsupported target platform \"${CMAKE_GENERATOR_PLATFORM}\"")
 endif()
 
 # Pre-compile shaders
@@ -116,9 +117,11 @@ endif()
 if (NOT FFX_CUSTOM_API)
 
 	# Embed PDBs in the debug versions of the libs
-	set(CMAKE_CXX_FLAGS_DEBUG "${CMAKE_CXX_FLAGS_DEBUG} /Z7 /Od")
+	# set(CMAKE_CXX_FLAGS_DEBUG "${CMAKE_CXX_FLAGS_DEBUG} /Z7 /Od")
     
 	# Write debug, profile, and release versions of the static libs to the /bin folder as they are uniquely named	
+	set(CMAKE_LIBRARY_OUTPUT_DIRECTORY         ${CMAKE_HOME_DIRECTORY}/bin/ffx_sdk/)
+	set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY         ${CMAKE_HOME_DIRECTORY}/bin/ffx_sdk/)
 	set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY_DEBUG   ${CMAKE_HOME_DIRECTORY}/bin/ffx_sdk/)
 	set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY_RELEASE ${CMAKE_HOME_DIRECTORY}/bin/ffx_sdk/)
 	set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY_RELWITHDEBINFO ${CMAKE_HOME_DIRECTORY}/bin/ffx_sdk/)
@@ -162,14 +165,17 @@ endif()
 add_compile_definitions(_UNICODE)
 add_compile_definitions(UNICODE)
 add_compile_definitions(_DISABLE_CONSTEXPR_MUTEX_CONSTRUCTOR)
+add_compile_definitions(_CRT_SECURE_NO_WARNINGS)
 
 if(FFX_VS_VERSION STREQUAL 2015 OR FFX_VS_VERSION STREQUAL 2017)
     message(NOTICE "Forcing the SDK path for VS 2015 and VS 2017")
     set(CMAKE_VS_WINDOWS_TARGET_PLATFORM_VERSION "10.0.18362.0")
 endif()
 
+set(FFX_SC_EXECUTABLE "" CACHE FILEPATH "Full path of FidelityFX_SC")
+set(GLSLANG_VALIDATOR_EXECUTABLE "" CACHE FILEPATH "Full path of glslangValidator")
+
 # Setup common variables
-set(FFX_SC_EXECUTABLE ${CMAKE_CURRENT_SOURCE_DIR}/tools/binary_store/FidelityFX_SC.exe)
 set(FFX_INCLUDE_PATH ${CMAKE_CURRENT_SOURCE_DIR}/include)
 set(FFX_LIB_PATH ${CMAKE_CURRENT_SOURCE_DIR}/libs)
 set(FFX_BIN_PATH ${CMAKE_CURRENT_SOURCE_DIR}/bin/ffx_sdk)
@@ -218,7 +224,7 @@ elseif(FFX_API_BACKEND STREQUAL DX12_ARM64EC)
 	project (FidelityFX-SDK_DX12_arm64ec)
 elseif (FFX_API_BACKEND STREQUAL VK_X64)
 	message(STATUS "Creating project FidelityFX-SDK_VK_x64")
-	project(FidelityFX-SDK_VK_x64)
+	project(FidelityFX)
 elseif(FFX_API_BACKEND STREQUAL GDK_SCARLETT_X64)
 	message(STATUS "Creating project FidelityFX-SDK_GDK_Scarlett_x64")
 	project(FidelityFX-SDK_GDK_Scarlett_x64)
@@ -230,6 +236,20 @@ else()
 	project (FidelityFX-SDK)
 endif()
 
+include(CMakePackageConfigHelpers)
+include(GNUInstallDirs)
+
+configure_package_config_file(
+  "${CMAKE_CURRENT_SOURCE_DIR}/FidelityFX-config.cmake.in" 
+  "${PROJECT_BINARY_DIR}/${PROJECT_NAME}-config.cmake"
+  INSTALL_DESTINATION "${CMAKE_INSTALL_DATADIR}/cmake/${PROJECT_NAME}"
+  NO_SET_AND_CHECK_MACRO
+  NO_CHECK_REQUIRED_COMPONENTS_MACRO)
+
+write_basic_package_version_file(${PROJECT_NAME}-config-version.cmake
+  VERSION 1.1.3
+  COMPATIBILITY SameMajorVersion)
+
 # Components
 add_subdirectory(${FFX_COMPONENTS_PATH}/opticalflow)
 add_subdirectory(${FFX_COMPONENTS_PATH}/frameinterpolation)
@@ -253,6 +273,13 @@ add_subdirectory(${FFX_COMPONENTS_PATH}/brixelizergi)
 add_subdirectory(${FFX_COMPONENTS_PATH}/classifier)
 add_subdirectory(${FFX_COMPONENTS_PATH}/breadcrumbs)
 
+install(
+  FILES
+    "${PROJECT_BINARY_DIR}/${PROJECT_NAME}-config-version.cmake"
+    "${PROJECT_BINARY_DIR}/${PROJECT_NAME}-config.cmake"
+  DESTINATION ${CMAKE_INSTALL_DATADIR}/cmake/${PROJECT_NAME})
+install(DIRECTORY include/ DESTINATION include)
+
 # Add appropriate graphics backend if requested
 if(FFX_API_BACKEND STREQUAL DX12_X64 OR
     FFX_API_BACKEND STREQUAL DX12_ARM64 OR
diff --git a/sdk/FidelityFX-config.cmake.in b/sdk/FidelityFX-config.cmake.in
new file mode 100644
index 0000000..ffeca8a
--- /dev/null
+++ b/sdk/FidelityFX-config.cmake.in
@@ -0,0 +1,23 @@
+@PACKAGE_INIT@
+include("${CMAKE_CURRENT_LIST_DIR}/backend_vk-targets.cmake")
+include("${CMAKE_CURRENT_LIST_DIR}/blur-targets.cmake")
+include("${CMAKE_CURRENT_LIST_DIR}/breadcrumbs-targets.cmake")
+include("${CMAKE_CURRENT_LIST_DIR}/brixelizer-targets.cmake")
+include("${CMAKE_CURRENT_LIST_DIR}/brixelizergi-targets.cmake")
+include("${CMAKE_CURRENT_LIST_DIR}/cacao-targets.cmake")
+include("${CMAKE_CURRENT_LIST_DIR}/cas-targets.cmake")
+include("${CMAKE_CURRENT_LIST_DIR}/classifier-targets.cmake")
+include("${CMAKE_CURRENT_LIST_DIR}/denoiser-targets.cmake")
+include("${CMAKE_CURRENT_LIST_DIR}/dof-targets.cmake")
+include("${CMAKE_CURRENT_LIST_DIR}/frameinterpolation-targets.cmake")
+include("${CMAKE_CURRENT_LIST_DIR}/fsr3upscaler-targets.cmake")
+include("${CMAKE_CURRENT_LIST_DIR}/opticalflow-targets.cmake")
+include("${CMAKE_CURRENT_LIST_DIR}/fsr1-targets.cmake")
+include("${CMAKE_CURRENT_LIST_DIR}/fsr2-targets.cmake")
+include("${CMAKE_CURRENT_LIST_DIR}/fsr3-targets.cmake")
+include("${CMAKE_CURRENT_LIST_DIR}/lens-targets.cmake")
+include("${CMAKE_CURRENT_LIST_DIR}/lpm-targets.cmake")
+include("${CMAKE_CURRENT_LIST_DIR}/parallelsort-targets.cmake")
+include("${CMAKE_CURRENT_LIST_DIR}/spd-targets.cmake")
+include("${CMAKE_CURRENT_LIST_DIR}/sssr-targets.cmake")
+include("${CMAKE_CURRENT_LIST_DIR}/vrs-targets.cmake")
diff --git a/sdk/include/FidelityFX/gpu/CMakeCompileShaders.txt b/sdk/include/FidelityFX/gpu/CMakeCompileShaders.txt
index ac1088d..3f2f6eb 100644
--- a/sdk/include/FidelityFX/gpu/CMakeCompileShaders.txt
+++ b/sdk/include/FidelityFX/gpu/CMakeCompileShaders.txt
@@ -89,7 +89,7 @@ function(compile_shaders_with_depfile
 		# Wave32
 		add_custom_command(
 			OUTPUT ${WAVE32_PERMUTATION_HEADER}
-			COMMAND ${EXECUTABLE} ${FFX_GDK_OPTION} ${SC_ARGS} -name=${PASS_SHADER_FILENAME} -DFFX_HALF=0 ${HLSL_WAVE32_ARGS} ${COMPILE_INCLUDE_ARGS} -output=${OUTPUT_PATH} ${PASS_SHADER}
+			COMMAND ${EXECUTABLE} ${FFX_GDK_OPTION} ${SC_ARGS} -glslangexe=${GLSLANG_VALIDATOR_EXECUTABLE} -name=${PASS_SHADER_FILENAME} -DFFX_HALF=0 ${HLSL_WAVE32_ARGS} ${COMPILE_INCLUDE_ARGS} -output=${OUTPUT_PATH} ${PASS_SHADER}
 			WORKING_DIRECTORY ${CMAKE_BINARY_DIR}
 			DEPENDS ${PASS_SHADER}
 			DEPFILE ${WAVE32_PERMUTATION_HEADER}.d
@@ -99,7 +99,7 @@ function(compile_shaders_with_depfile
 		# Wave64
 		add_custom_command(
 			OUTPUT ${WAVE64_PERMUTATION_HEADER}
-			COMMAND ${EXECUTABLE} ${FFX_GDK_OPTION} ${SC_ARGS} -name=${PASS_SHADER_FILENAME}_wave64 -DFFX_HALF=0 ${HLSL_WAVE64_ARGS} ${COMPILE_INCLUDE_ARGS} -output=${OUTPUT_PATH} ${PASS_SHADER}
+			COMMAND ${EXECUTABLE} ${FFX_GDK_OPTION} ${SC_ARGS} -glslangexe=${GLSLANG_VALIDATOR_EXECUTABLE} -name=${PASS_SHADER_FILENAME}_wave64 -DFFX_HALF=0 ${HLSL_WAVE64_ARGS} ${COMPILE_INCLUDE_ARGS} -output=${OUTPUT_PATH} ${PASS_SHADER}
 			WORKING_DIRECTORY ${CMAKE_BINARY_DIR}
 			DEPENDS ${PASS_SHADER}
 			DEPFILE ${WAVE64_PERMUTATION_HEADER}.d
@@ -109,7 +109,7 @@ function(compile_shaders_with_depfile
 		# Wave32 16-bit
 		add_custom_command(
 			OUTPUT ${WAVE32_16BIT_PERMUTATION_HEADER}
-			COMMAND ${EXECUTABLE} ${FFX_GDK_OPTION} ${SC_ARGS} -name=${PASS_SHADER_FILENAME}_16bit -DFFX_HALF=1 ${HLSL_16BIT_ARGS} ${HLSL_WAVE32_ARGS} ${COMPILE_INCLUDE_ARGS} -output=${OUTPUT_PATH} ${PASS_SHADER}
+			COMMAND ${EXECUTABLE} ${FFX_GDK_OPTION} ${SC_ARGS} -glslangexe=${GLSLANG_VALIDATOR_EXECUTABLE} -name=${PASS_SHADER_FILENAME}_16bit -DFFX_HALF=1 ${HLSL_16BIT_ARGS} ${HLSL_WAVE32_ARGS} ${COMPILE_INCLUDE_ARGS} -output=${OUTPUT_PATH} ${PASS_SHADER}
 			WORKING_DIRECTORY ${CMAKE_BINARY_DIR}
 			DEPENDS ${PASS_SHADER}
 			DEPFILE ${WAVE32_16BIT_PERMUTATION_HEADER}.d
@@ -119,7 +119,7 @@ function(compile_shaders_with_depfile
 		# Wave64 16-bit
 		add_custom_command(
 			OUTPUT ${WAVE64_16BIT_PERMUTATION_HEADER}
-			COMMAND ${EXECUTABLE} ${FFX_GDK_OPTION} ${SC_ARGS} -name=${PASS_SHADER_FILENAME}_wave64_16bit -DFFX_HALF=1 ${HLSL_16BIT_ARGS} ${HLSL_WAVE64_ARGS} ${COMPILE_INCLUDE_ARGS} -output=${OUTPUT_PATH} ${PASS_SHADER}
+			COMMAND ${EXECUTABLE} ${FFX_GDK_OPTION} ${SC_ARGS} -glslangexe=${GLSLANG_VALIDATOR_EXECUTABLE} -name=${PASS_SHADER_FILENAME}_wave64_16bit -DFFX_HALF=1 ${HLSL_16BIT_ARGS} ${HLSL_WAVE64_ARGS} ${COMPILE_INCLUDE_ARGS} -output=${OUTPUT_PATH} ${PASS_SHADER}
 			WORKING_DIRECTORY ${CMAKE_BINARY_DIR}
 			DEPENDS ${PASS_SHADER}
 			DEPFILE ${WAVE64_16BIT_PERMUTATION_HEADER}.d
@@ -133,8 +133,10 @@ endfunction()
 # macro to add shader output files to a list for dependencies
 macro (add_shader_output)
     foreach (_SHADER_SRC ${ARGN})
-		#message (STATUS ${_SHADER_SRC})
-		list (APPEND FFX_SC_PERMUTATION_OUTPUTS "${_SHADER_SRC}")
+		if(_SHADER_SRC MATCHES ".*\.h")
+			#message (STATUS ${_SHADER_SRC})
+			list (APPEND FFX_SC_PERMUTATION_OUTPUTS "${_SHADER_SRC}")
+		endif()
     endforeach()
 
 	set (FFX_SC_PERMUTATION_OUTPUTS ${FFX_SC_PERMUTATION_OUTPUTS} PARENT_SCOPE)
diff --git a/sdk/include/FidelityFX/gpu/ffx_core_cpu.h b/sdk/include/FidelityFX/gpu/ffx_core_cpu.h
index 4b6c41a..b8d3411 100644
--- a/sdk/include/FidelityFX/gpu/ffx_core_cpu.h
+++ b/sdk/include/FidelityFX/gpu/ffx_core_cpu.h
@@ -20,6 +20,8 @@
 // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 // THE SOFTWARE.
 
+#include <cmath>
+
 /// A define for a true value in a boolean expression.
 ///
 /// @ingroup CPUTypes
diff --git a/sdk/include/FidelityFX/host/backends/dx12/d3dx12.h b/sdk/include/FidelityFX/host/backends/dx12/d3dx12.h
index 56b7f2e..e583bf7 100644
--- a/sdk/include/FidelityFX/host/backends/dx12/d3dx12.h
+++ b/sdk/include/FidelityFX/host/backends/dx12/d3dx12.h
@@ -4829,8 +4829,8 @@ public:
     //    CD3DX12_STATE_OBJECT_DESC Collection1(D3D12_STATE_OBJECT_TYPE_COLLECTION);
     //    auto Lib0 = Collection1.CreateSubobject<CD3DX12_DXIL_LIBRARY_SUBOBJECT>();
     //    Lib0->SetDXILLibrary(&pMyAppDxilLibs[0]);
-    //    Lib0->DefineExport(L"rayGenShader0"); // in practice these export listings might be
-    //                                          // data/engine driven
+    //    Lib0->DefineExport("rayGenShader0"); // in practice these export listings might be
+    //                                         // data/engine driven
     //    etc.
     //
     // Alternatively, users can instantiate sububject helpers explicitly, such as via local
@@ -5062,7 +5062,7 @@ private:
     }
     void* Data() noexcept override { return &m_Desc; }
     D3D12_DXIL_LIBRARY_DESC m_Desc;
-    CD3DX12_STATE_OBJECT_DESC::StringContainer<LPCWSTR, std::wstring> m_Strings;
+    CD3DX12_STATE_OBJECT_DESC::StringContainer<LPCWSTR, std::string> m_Strings;
     std::vector<D3D12_EXPORT_DESC> m_Exports;
 };
 
@@ -5134,7 +5134,7 @@ private:
     void* Data() noexcept override { return &m_Desc; }
     D3D12_EXISTING_COLLECTION_DESC m_Desc;
     D3DX12_COM_PTR<ID3D12StateObject> m_CollectionRef;
-    CD3DX12_STATE_OBJECT_DESC::StringContainer<LPCWSTR, std::wstring> m_Strings;
+    CD3DX12_STATE_OBJECT_DESC::StringContainer<LPCWSTR, std::string> m_Strings;
     std::vector<D3D12_EXPORT_DESC> m_Exports;
 };
 
@@ -5196,7 +5196,7 @@ private:
     }
     void* Data() noexcept override { return &m_Desc; }
     D3D12_SUBOBJECT_TO_EXPORTS_ASSOCIATION m_Desc;
-    CD3DX12_STATE_OBJECT_DESC::StringContainer<LPCWSTR, std::wstring> m_Strings;
+    CD3DX12_STATE_OBJECT_DESC::StringContainer<LPCWSTR, std::string> m_Strings;
     std::vector<LPCWSTR> m_Exports;
 };
 
@@ -5259,8 +5259,8 @@ private:
     }
     void* Data() noexcept override { return &m_Desc; }
     D3D12_DXIL_SUBOBJECT_TO_EXPORTS_ASSOCIATION m_Desc;
-    CD3DX12_STATE_OBJECT_DESC::StringContainer<LPCWSTR, std::wstring> m_Strings;
-    CD3DX12_STATE_OBJECT_DESC::StringContainer<LPCWSTR, std::wstring> m_SubobjectName;
+    CD3DX12_STATE_OBJECT_DESC::StringContainer<LPCWSTR, std::string> m_Strings;
+    CD3DX12_STATE_OBJECT_DESC::StringContainer<LPCWSTR, std::string> m_SubobjectName;
     std::vector<LPCWSTR> m_Exports;
 };
 
@@ -5317,7 +5317,7 @@ private:
     void* Data() noexcept override { return &m_Desc; }
     D3D12_HIT_GROUP_DESC m_Desc;
     static constexpr UINT m_NumStrings = 4;
-    CD3DX12_STATE_OBJECT_DESC::StringContainer<LPCWSTR, std::wstring>
+    CD3DX12_STATE_OBJECT_DESC::StringContainer<LPCWSTR, std::string>
         m_Strings[m_NumStrings]; // one string for every entrypoint name
 };
 
@@ -6431,7 +6431,7 @@ private:
     std::list<D3D12_STATE_SUBOBJECT const*> m_Subobjects;
     std::vector<D3D12_STATE_SUBOBJECT const*> m_SubobjectsVector;
     UINT m_numSubobjects;
-    CD3DX12_STATE_OBJECT_DESC::StringContainer<LPCWSTR, std::wstring> m_Strings;
+    CD3DX12_STATE_OBJECT_DESC::StringContainer<LPCWSTR, std::string> m_Strings;
 };
 
 //------------------------------------------------------------------------------------------------
@@ -6479,7 +6479,7 @@ public:
 private:
     std::vector<D3D12_NODE_OUTPUT_OVERRIDES> m_Desc;
     // Cached parameters
-    CD3DX12_STATE_OBJECT_DESC::StringContainer<LPCWSTR, std::wstring> m_Strings;
+    CD3DX12_STATE_OBJECT_DESC::StringContainer<LPCWSTR, std::string> m_Strings;
     std::forward_list<UINT> m_UINTs;
     std::forward_list<D3D12_NODE_ID> m_NodeIDs;
     const D3D12_NODE_OUTPUT_OVERRIDES** m_ppOwner;
@@ -6513,7 +6513,7 @@ public:
     }
     D3D12_NODE* m_pDesc;
 private:
-    CD3DX12_STATE_OBJECT_DESC::StringContainer<LPCWSTR, std::wstring> m_Strings;
+    CD3DX12_STATE_OBJECT_DESC::StringContainer<LPCWSTR, std::string> m_Strings;
 };
 
 //------------------------------------------------------------------------------------------------
@@ -6577,7 +6577,7 @@ public:
     D3D12_NODE* m_pDesc;
 private:
     // Cached parameters
-    CD3DX12_STATE_OBJECT_DESC::StringContainer<LPCWSTR, std::wstring> m_Strings;
+    CD3DX12_STATE_OBJECT_DESC::StringContainer<LPCWSTR, std::string> m_Strings;
     std::forward_list<UINT> m_UINTs;
     struct UINT3
     {
@@ -6641,7 +6641,7 @@ public:
     D3D12_NODE* m_pDesc;
 private:
     // Cached parameters
-    CD3DX12_STATE_OBJECT_DESC::StringContainer<LPCWSTR, std::wstring> m_Strings;
+    CD3DX12_STATE_OBJECT_DESC::StringContainer<LPCWSTR, std::string> m_Strings;
     std::forward_list<UINT> m_UINTs;
     struct UINT3
     {
@@ -6705,7 +6705,7 @@ public:
     D3D12_NODE* m_pDesc;
 private:
     // Cached parameters
-    CD3DX12_STATE_OBJECT_DESC::StringContainer<LPCWSTR, std::wstring> m_Strings;
+    CD3DX12_STATE_OBJECT_DESC::StringContainer<LPCWSTR, std::string> m_Strings;
     std::forward_list<UINT> m_UINTs;
     std::forward_list<D3D12_NODE_ID> m_NodeIDs;
     CD3DX12_NODE_OUTPUT_OVERRIDES m_NodeOutputOverrides;
@@ -6765,7 +6765,7 @@ public:
     D3D12_NODE* m_pDesc;
 private:
     // Cached parameters
-    CD3DX12_STATE_OBJECT_DESC::StringContainer<LPCWSTR, std::wstring> m_Strings;
+    CD3DX12_STATE_OBJECT_DESC::StringContainer<LPCWSTR, std::string> m_Strings;
     std::forward_list<UINT> m_UINTs;
     std::forward_list<D3D12_NODE_ID> m_NodeIDs;
     CD3DX12_NODE_OUTPUT_OVERRIDES m_NodeOutputOverrides;
@@ -6884,7 +6884,7 @@ private:
     std::list<D3D12_NODE> m_NodeDescs;
     UINT m_NumNodes;
     std::vector<D3D12_NODE> m_NodeDescsVector;
-    CD3DX12_STATE_OBJECT_DESC::StringContainer<LPCWSTR, std::wstring> m_Strings;
+    CD3DX12_STATE_OBJECT_DESC::StringContainer<LPCWSTR, std::string> m_Strings;
     std::list<std::unique_ptr<const CD3DX12_NODE_HELPER_BASE>> m_OwnedNodeHelpers;
 };
 #endif // D3D12_SDK_VERSION >= 612
diff --git a/sdk/include/FidelityFX/host/backends/dx12/ffx_dx12.h b/sdk/include/FidelityFX/host/backends/dx12/ffx_dx12.h
index 38d2c2f..836e169 100644
--- a/sdk/include/FidelityFX/host/backends/dx12/ffx_dx12.h
+++ b/sdk/include/FidelityFX/host/backends/dx12/ffx_dx12.h
@@ -115,7 +115,7 @@ FFX_API FfxPipeline ffxGetPipelineDX12(ID3D12PipelineState* pipelineState);
 /// @ingroup DX12Backend
 FFX_API FfxResource ffxGetResourceDX12(const ID3D12Resource*  dx12Resource,
                                        FfxResourceDescription ffxResDescription,
-                                       const wchar_t*         ffxResName,
+                                       const char*            ffxResName,
                                        FfxResourceStates      state = FFX_RESOURCE_STATE_COMPUTE_READ);
 
 /// Loads PIX runtime dll to allow SDK calls to show up in Microsoft PIX.
@@ -130,7 +130,7 @@ FFX_API FfxResource ffxGetResourceDX12(const ID3D12Resource*  dx12Resource,
 /// FFX_ERROR_BACKEND_API_ERROR             Could not get proc addresses for PIXBeginEvent and/or PIXEndEvent
 ///
 /// @ingroup DX12Backend
-FFX_API FfxErrorCode ffxLoadPixDll(const wchar_t*  pixDllPath);
+FFX_API FfxErrorCode ffxLoadPixDll(const char*  pixDllPath);
 
 /// Fetch a <c><i>FfxSurfaceFormat</i></c> from a DXGI_FORMAT.
 ///
diff --git a/sdk/include/FidelityFX/host/backends/vk/ffx_vk.h b/sdk/include/FidelityFX/host/backends/vk/ffx_vk.h
index b31d589..5b263ba 100644
--- a/sdk/include/FidelityFX/host/backends/vk/ffx_vk.h
+++ b/sdk/include/FidelityFX/host/backends/vk/ffx_vk.h
@@ -83,13 +83,15 @@ typedef struct VkFrameInterpolationInfoFFX
 /// The size (in bytes) of the required scratch memory buffer for the VK backend.
 /// 
 /// @ingroup VKBackend
-FFX_API size_t ffxGetScratchMemorySizeVK(VkPhysicalDevice physicalDevice, size_t maxContexts);
+FFX_API size_t ffxGetScratchMemorySizeVK(FfxDevice device, size_t maxContexts);
 
 /// Convenience structure to hold all VK-related device information
 typedef struct VkDeviceContext {
-    VkDevice                vkDevice;           /// The Vulkan device
-    VkPhysicalDevice        vkPhysicalDevice;   /// The Vulkan physical device
-    PFN_vkGetDeviceProcAddr vkDeviceProcAddr;   /// The device's function address table
+    VkInstance                       vkInstance;         /// The Vulkan instance
+    VkDevice                         vkDevice;           /// The Vulkan device
+    VkPhysicalDevice                 vkPhysicalDevice;   /// The Vulkan physical device
+    PFN_vkGetInstanceProcAddr        vkInstanceProcAddr; /// The instance's function address table
+    PFN_vkGetDeviceProcAddr          vkDeviceProcAddr;   /// The device's function address table
 } VkDeviceContext;
 
 /// Create a <c><i>FfxDevice</i></c> from a <c><i>VkDevice</i></c>.
@@ -157,7 +159,7 @@ FFX_API FfxPipeline ffxGetPipelineVK(VkPipeline pipeline);
 /// @ingroup VKBackend
 FFX_API FfxResource ffxGetResourceVK(void*  vkResource,
     FfxResourceDescription                  ffxResDescription,
-    const wchar_t*                          ffxResName,
+    const char*                             ffxResName,
     FfxResourceStates                       state = FFX_RESOURCE_STATE_COMPUTE_READ);
 
 /// Fetch a <c><i>FfxSurfaceFormat</i></c> from a VkFormat.
diff --git a/sdk/include/FidelityFX/host/ffx_brixelizer.h b/sdk/include/FidelityFX/host/ffx_brixelizer.h
index 9860b4c..01dc244 100644
--- a/sdk/include/FidelityFX/host/ffx_brixelizer.h
+++ b/sdk/include/FidelityFX/host/ffx_brixelizer.h
@@ -32,7 +32,7 @@
 /// The size of the update description specified in 32bit values.
 ///
 /// @ingroup ffxBrixelizer
-#define FFX_BRIXELIZER_UPDATE_DESCRIPTION_SIZE 2099376
+#define FFX_BRIXELIZER_UPDATE_DESCRIPTION_SIZE 2098576
 
 #ifdef __cplusplus
 extern "C" {
diff --git a/sdk/include/FidelityFX/host/ffx_fsr2.h b/sdk/include/FidelityFX/host/ffx_fsr2.h
index f7482ee..ff40493 100644
--- a/sdk/include/FidelityFX/host/ffx_fsr2.h
+++ b/sdk/include/FidelityFX/host/ffx_fsr2.h
@@ -150,7 +150,7 @@ typedef enum FfxFsr2InitializationFlagBits {
 /// @ingroup ffxFsr2
 typedef void(*FfxFsr2Message)(
     FfxMsgType type,
-    const wchar_t* message);
+    const char* message);
 
 /// A structure encapsulating the parameters required to initialize FidelityFX
 /// Super Resolution 2 upscaling.
diff --git a/sdk/include/FidelityFX/host/ffx_fsr3upscaler.h b/sdk/include/FidelityFX/host/ffx_fsr3upscaler.h
index 2cef263..e45f2aa 100644
--- a/sdk/include/FidelityFX/host/ffx_fsr3upscaler.h
+++ b/sdk/include/FidelityFX/host/ffx_fsr3upscaler.h
@@ -152,7 +152,7 @@ typedef enum FfxFsr3UpscalerInitializationFlagBits {
 /// @ingroup ffxFsr3Upscaler
 typedef void(*FfxFsr3UpscalerMessage)(
     FfxMsgType type,
-    const wchar_t* message);
+    const char* message);
 
 /// A structure encapsulating the parameters required to initialize FidelityFX
 /// Super Resolution 3 upscaling.
diff --git a/sdk/include/FidelityFX/host/ffx_interface.h b/sdk/include/FidelityFX/host/ffx_interface.h
index 88e6572..677cd7b 100644
--- a/sdk/include/FidelityFX/host/ffx_interface.h
+++ b/sdk/include/FidelityFX/host/ffx_interface.h
@@ -472,7 +472,7 @@ typedef enum FfxUiCompositionFlags
 
 typedef FfxErrorCode(*FfxPresentCallbackFunc)(const FfxPresentCallbackDescription* params, void*);
 typedef FfxErrorCode(*FfxFrameGenerationDispatchFunc)(const FfxFrameGenerationDispatchDescription* params, void*);
-typedef FfxErrorCode(*FfxWaitCallbackFunc)(wchar_t* fenceName, uint64_t fenceValueToWaitFor);
+typedef FfxErrorCode(*FfxWaitCallbackFunc)(char* fenceName, uint64_t fenceValueToWaitFor);
 
 /// A structure representing the configuration options to pass to FrameInterpolationSwapChain
 ///
diff --git a/sdk/include/FidelityFX/host/ffx_types.h b/sdk/include/FidelityFX/host/ffx_types.h
index f171397..a582e9b 100644
--- a/sdk/include/FidelityFX/host/ffx_types.h
+++ b/sdk/include/FidelityFX/host/ffx_types.h
@@ -344,17 +344,18 @@ typedef enum FfxResourceUsage {
 /// @ingroup SDKTypes
 typedef enum FfxResourceStates {
 
-    FFX_RESOURCE_STATE_COMMON               = (1 << 0),
-    FFX_RESOURCE_STATE_UNORDERED_ACCESS     = (1 << 1), ///< Indicates a resource is in the state to be used as UAV.
-    FFX_RESOURCE_STATE_COMPUTE_READ         = (1 << 2), ///< Indicates a resource is in the state to be read by compute shaders.
-    FFX_RESOURCE_STATE_PIXEL_READ           = (1 << 3), ///< Indicates a resource is in the state to be read by pixel shaders.
-    FFX_RESOURCE_STATE_PIXEL_COMPUTE_READ   = (FFX_RESOURCE_STATE_PIXEL_READ | FFX_RESOURCE_STATE_COMPUTE_READ), ///< Indicates a resource is in the state to be read by pixel or compute shaders.
-    FFX_RESOURCE_STATE_COPY_SRC             = (1 << 4), ///< Indicates a resource is in the state to be used as source in a copy command.
-    FFX_RESOURCE_STATE_COPY_DEST            = (1 << 5), ///< Indicates a resource is in the state to be used as destination in a copy command.
-    FFX_RESOURCE_STATE_GENERIC_READ         = (FFX_RESOURCE_STATE_COPY_SRC | FFX_RESOURCE_STATE_COMPUTE_READ),  ///< Indicates a resource is in generic (slow) read state.
-    FFX_RESOURCE_STATE_INDIRECT_ARGUMENT    = (1 << 6), ///< Indicates a resource is in the state to be used as an indirect command argument
-    FFX_RESOURCE_STATE_PRESENT              = (1 << 7), ///< Indicates a resource is in the state to be used to present to the swap chain
-    FFX_RESOURCE_STATE_RENDER_TARGET        = (1 << 8), ///< Indicates a resource is in the state to be used as render target
+    FFX_RESOURCE_STATE_COMMON                  = (1 << 0),
+    FFX_RESOURCE_STATE_UNORDERED_ACCESS        = (1 << 1), ///< Indicates a resource is in the state to be used as UAV.
+    FFX_RESOURCE_STATE_COMPUTE_READ            = (1 << 2), ///< Indicates a resource is in the state to be read by compute shaders.
+    FFX_RESOURCE_STATE_PIXEL_READ              = (1 << 3), ///< Indicates a resource is in the state to be read by pixel shaders.
+    FFX_RESOURCE_STATE_PIXEL_COMPUTE_READ      = (FFX_RESOURCE_STATE_PIXEL_READ | FFX_RESOURCE_STATE_COMPUTE_READ), ///< Indicates a resource is in the state to be read by pixel or compute shaders.
+    FFX_RESOURCE_STATE_COPY_SRC                = (1 << 4), ///< Indicates a resource is in the state to be used as source in a copy command.
+    FFX_RESOURCE_STATE_COPY_DEST               = (1 << 5), ///< Indicates a resource is in the state to be used as destination in a copy command.
+    FFX_RESOURCE_STATE_GENERIC_READ            = (FFX_RESOURCE_STATE_COPY_SRC | FFX_RESOURCE_STATE_COMPUTE_READ),  ///< Indicates a resource is in generic (slow) read state.
+    FFX_RESOURCE_STATE_INDIRECT_ARGUMENT       = (1 << 6), ///< Indicates a resource is in the state to be used as an indirect command argument
+    FFX_RESOURCE_STATE_PRESENT                 = (1 << 7), ///< Indicates a resource is in the state to be used to present to the swap chain
+    FFX_RESOURCE_STATE_RENDER_TARGET           = (1 << 8), ///< Indicates a resource is in the state to be used as render target
+    FFX_RESOURCE_STATE_DEPTH_STENCIL_READ_ONLY = (1 << 9), ///< Indicates a resource is in the state to be used as depth stencil read only
 } FfxResourceStates;
 
 /// An enumeration of surface dimensions.
@@ -739,7 +740,7 @@ typedef struct FfxResource {
     void*                           resource;                               ///< pointer to the resource.
     FfxResourceDescription          description;
     FfxResourceStates               state;
-    wchar_t                         name[FFX_RESOURCE_NAME_SIZE];           ///< (optional) Resource name.
+    char                            name[FFX_RESOURCE_NAME_SIZE];           ///< (optional) Resource name.
 } FfxResource;
 
 /// A structure describing a static resource.
@@ -849,7 +850,7 @@ typedef struct FfxResourceInitData
 typedef struct FfxInternalResourceDescription {
 
     uint32_t                    id;         ///< Resource identifier
-    const wchar_t*              name;       ///< Name to set to the resource for easier debugging
+    const char*                 name;       ///< Name to set to the resource for easier debugging
     FfxResourceType             type;       ///< The type of resource (see <c><i>FfxResourceType</i></c>)
     FfxResourceUsage            usage;      ///< Resource usage flags (see <c><i>FfxResourceUsage</i></c>)
     FfxSurfaceFormat            format;     ///< The resource format to use
@@ -878,10 +879,10 @@ typedef struct FfxViewDescription
     };
 
     int32_t                     firstSlice;                 ///< The first slice to map to, (-1) for default first slice
-    wchar_t                     name[FFX_RESOURCE_NAME_SIZE];
+    char                        name[FFX_RESOURCE_NAME_SIZE];
 } FfxViewDescription;
 
-static FfxViewDescription s_FfxViewDescInit = { false, FFX_RESOURCE_VIEW_DIMENSION_TEXTURE_2D, -1, -1, -1, L"" };
+static FfxViewDescription s_FfxViewDescInit = { false, FFX_RESOURCE_VIEW_DIMENSION_TEXTURE_2D, -1, -1, -1, "" };
 
 /// A structure defining a resource bind point
 ///
@@ -891,7 +892,7 @@ typedef struct FfxResourceBinding
     uint32_t    slotIndex;                      ///< The slot into which to bind the resource
     uint32_t    arrayIndex;                     ///< The resource offset for mip/array access
     uint32_t    resourceIdentifier;             ///< A unique resource identifier representing an internal resource index
-    wchar_t     name[FFX_RESOURCE_NAME_SIZE];   ///< A debug name to help track the resource binding
+    char        name[FFX_RESOURCE_NAME_SIZE];   ///< A debug name to help track the resource binding
 }FfxResourceBinding;
 
 /// A structure encapsulating a single pass of an algorithm.
@@ -919,7 +920,7 @@ typedef struct FfxPipelineState {
     FfxResourceBinding              uavBufferBindings[FFX_MAX_NUM_UAVS];                ///< Array of ResourceIdentifiers bound as buffer UAVs
     FfxResourceBinding              constantBufferBindings[FFX_MAX_NUM_CONST_BUFFERS];  ///< Array of ResourceIdentifiers bound as CBs
 
-    wchar_t                         name[FFX_RESOURCE_NAME_SIZE];                       ///< Pipeline name for debugging/profiling purposes
+    char                            name[FFX_RESOURCE_NAME_SIZE];                       ///< Pipeline name for debugging/profiling purposes
 } FfxPipelineState;
 
 /// A structure containing the data required to create a resource.
@@ -929,8 +930,8 @@ typedef struct FfxCreateResourceDescription {
 
     FfxHeapType                     heapType;                               ///< The heap type to hold the resource, typically <c><i>FFX_HEAP_TYPE_DEFAULT</i></c>.
     FfxResourceDescription          resourceDescription;                    ///< A resource description.
-    FfxResourceStates               initialState;                            ///< The initial resource state.
-    const wchar_t*                  name;                                   ///< Name of the resource.
+    FfxResourceStates               initialState;                           ///< The initial resource state.
+    const char*                     name;                                   ///< Name of the resource.
     uint32_t                        id;                                     ///< Internal resource ID.
     FfxResourceInitData             initData;                               ///< A struct used to initialize the resource.
 } FfxCreateResourceDescription;
@@ -990,7 +991,7 @@ typedef struct FfxPipelineDescription {
     size_t                              samplerCount;                   ///< Number of samplers to create for the pipeline
     const FfxRootConstantDescription*   rootConstants;                  ///< A collection of root constant descriptions to use when building the root signature for the pipeline
     uint32_t                            rootConstantBufferCount;        ///< Number of root constant buffers to create for the pipeline
-    wchar_t                             name[64];                       ///< Pipeline name with which to name the pipeline object
+    char                                name[64];                       ///< Pipeline name with which to name the pipeline object
     FfxBindStage                        stage;                          ///< The stage(s) for which this pipeline is being built
     uint32_t                            indirectWorkload;               ///< Whether this pipeline has an indirect workload
     FfxSurfaceFormat                    backbufferFormat;               ///< For raster pipelines this contains the backbuffer format
@@ -1023,7 +1024,7 @@ typedef struct FfxTextureSRV
 {
     FfxResourceInternal resource;               ///< Resource corresponding to the shader resource view.
 #ifdef FFX_DEBUG
-    wchar_t             name[FFX_RESOURCE_NAME_SIZE];
+    char                name[FFX_RESOURCE_NAME_SIZE];
 #endif
 } FfxTextureSRV;
 
@@ -1035,7 +1036,7 @@ typedef struct FfxBufferSRV
     uint32_t            stride;                 ///< Size of resource to bind in bytes.
     FfxResourceInternal resource;               ///< Resource corresponding to the shader resource view.
 #ifdef FFX_DEBUG
-    wchar_t             name[FFX_RESOURCE_NAME_SIZE];
+    char                name[FFX_RESOURCE_NAME_SIZE];
 #endif
 } FfxBufferSRV;
 
@@ -1045,7 +1046,7 @@ typedef struct FfxTextureUAV
     uint32_t            mip;                    ///< Mip level of resource to bind.
     FfxResourceInternal resource;               ///< Resource corresponding to the unordered access view.
 #ifdef FFX_DEBUG
-    wchar_t             name[FFX_RESOURCE_NAME_SIZE];
+    char                name[FFX_RESOURCE_NAME_SIZE];
 #endif
 } FfxTextureUAV;
 
@@ -1057,7 +1058,7 @@ typedef struct FfxBufferUAV
     uint32_t            stride;                 ///< Size of resource to bind in bytes.
     FfxResourceInternal resource;               ///< Resource corresponding to the unordered access view.
 #ifdef FFX_DEBUG
-    wchar_t             name[FFX_RESOURCE_NAME_SIZE];
+    char                name[FFX_RESOURCE_NAME_SIZE];
 #endif
 } FfxBufferUAV;
 
@@ -1086,7 +1087,7 @@ typedef struct FfxComputeJobDescription {
 
     FfxConstantBuffer               cbs[FFX_MAX_NUM_CONST_BUFFERS];         ///< Constant buffers to be bound in the compute job.
 #ifdef FFX_DEBUG
-    wchar_t                         cbNames[FFX_MAX_NUM_CONST_BUFFERS][FFX_RESOURCE_NAME_SIZE];
+    char                            cbNames[FFX_MAX_NUM_CONST_BUFFERS][FFX_RESOURCE_NAME_SIZE];
 #endif
 } FfxComputeJobDescription;
 
@@ -1100,7 +1101,7 @@ typedef struct FfxRasterJobDescription
 
     FfxConstantBuffer               cbs[FFX_MAX_NUM_CONST_BUFFERS];         ///< Constant buffers to be bound in the compute job.
 #ifdef FFX_DEBUG
-    wchar_t                         cbNames[FFX_MAX_NUM_CONST_BUFFERS][FFX_RESOURCE_NAME_SIZE];
+    char                            cbNames[FFX_MAX_NUM_CONST_BUFFERS][FFX_RESOURCE_NAME_SIZE];
 #endif
 } FfxRasterJobDescription;
 
@@ -1127,7 +1128,7 @@ typedef struct FfxDiscardJobDescription {
 typedef struct FfxGpuJobDescription{
 
     FfxGpuJobType       jobType;                                    ///< Type of the job.
-    wchar_t             jobLabel[FFX_RESOURCE_NAME_SIZE];           ///< Job label for markers
+    char                jobLabel[FFX_RESOURCE_NAME_SIZE];           ///< Job label for markers
 
     union {
         FfxClearFloatJobDescription clearJobDescriptor;                     ///< Clear job descriptor. Valid when <c><i>jobType</i></c> is <c><i>FFX_RENDER_JOB_CLEAR_FLOAT</i></c>.
diff --git a/sdk/include/FidelityFX/host/ffx_util.h b/sdk/include/FidelityFX/host/ffx_util.h
index f06a368..6826c0e 100644
--- a/sdk/include/FidelityFX/host/ffx_util.h
+++ b/sdk/include/FidelityFX/host/ffx_util.h
@@ -24,6 +24,10 @@
 
 #include <FidelityFX/host/ffx_types.h>
 
+#if __cplusplus >= 202002L
+# include <bit>
+#endif
+
 /// @defgroup Utils Utilities
 /// Utility Macros used by the FidelityFX SDK
 /// 
diff --git a/sdk/src/backends/dx12/CMakeLists.txt b/sdk/src/backends/dx12/CMakeLists.txt
index b4146ef..642509b 100644
--- a/sdk/src/backends/dx12/CMakeLists.txt
+++ b/sdk/src/backends/dx12/CMakeLists.txt
@@ -392,9 +392,9 @@ file(GLOB_RECURSE PUBLIC_SOURCE
     "${FFX_HOST_BACKENDS_PATH}/dx12/*.h")
 
 if (FFX_BUILD_AS_DLL)
-    add_library(ffx_backend_dx12_${FFX_PLATFORM_NAME} SHARED ${PRIVATE_SOURCE} ${PUBLIC_SOURCE} ${PRIVATE_SHADERS} ${PUBLIC_SHADERS})
+    add_library(backend_dx12 SHARED ${PRIVATE_SOURCE} ${PUBLIC_SOURCE} ${PRIVATE_SHADERS} ${PUBLIC_SHADERS})
 else()
-    add_library(ffx_backend_dx12_${FFX_PLATFORM_NAME} STATIC ${PRIVATE_SOURCE} ${PUBLIC_SOURCE} ${PRIVATE_SHADERS} ${PUBLIC_SHADERS})
+    add_library(backend_dx12 STATIC ${PRIVATE_SOURCE} ${PUBLIC_SOURCE} ${PRIVATE_SHADERS} ${PUBLIC_SHADERS})
 endif()
 
 # dx12 backend source
@@ -405,15 +405,17 @@ source_group("public_shaders"  FILES ${PUBLIC_SHADERS})
 
 get_filename_component(FFX_PASS_SHADER_OUTPUT_PATH ${CMAKE_CURRENT_BINARY_DIR}/../shaders/dx12 ABSOLUTE)
 
-target_include_directories(ffx_backend_dx12_${FFX_PLATFORM_NAME} PUBLIC ${FFX_INCLUDE_PATH})
-target_include_directories(ffx_backend_dx12_${FFX_PLATFORM_NAME} PUBLIC ${FFX_LIB_PATH})
-target_include_directories(ffx_backend_dx12_${FFX_PLATFORM_NAME} PUBLIC ${FFX_PASS_SHADER_OUTPUT_PATH})
-target_include_directories(ffx_backend_dx12_${FFX_PLATFORM_NAME} PRIVATE ${FFX_COMPONENTS_PATH})
-target_include_directories(ffx_backend_dx12_${FFX_PLATFORM_NAME} PRIVATE ${FFX_SHARED_PATH})
-target_include_directories(ffx_backend_dx12_${FFX_PLATFORM_NAME} PRIVATE "${FFX_SRC_BACKENDS_PATH}/shared")
-target_include_directories(ffx_backend_dx12_${FFX_PLATFORM_NAME} PRIVATE ${FFX_PASS_SHADER_OUTPUT_PATH})
+target_include_directories(backend_dx12 PUBLIC
+	$<BUILD_INTERFACE:${FFX_INCLUDE_PATH}>
+	$<INSTALL_INTERFACE:include>)
+target_include_directories(backend_dx12 PRIVATE ${FFX_LIB_PATH})
+# target_include_directories(backend_dx12 PUBLIC ${FFX_PASS_SHADER_OUTPUT_PATH})
+target_include_directories(backend_dx12 PRIVATE ${FFX_COMPONENTS_PATH})
+target_include_directories(backend_dx12 PRIVATE ${FFX_SHARED_PATH})
+target_include_directories(backend_dx12 PRIVATE "${FFX_SRC_BACKENDS_PATH}/shared")
+target_include_directories(backend_dx12 PRIVATE ${FFX_PASS_SHADER_OUTPUT_PATH})
 
-target_link_libraries(ffx_backend_dx12_${FFX_PLATFORM_NAME} pixlib dxgi)
+target_link_libraries(backend_dx12 pixlib dxgi)
 
 set_source_files_properties(${PRIVATE_SHADERS} PROPERTIES HEADER_FILE_ONLY TRUE)
 set_source_files_properties(${PUBLIC_SHADERS} PROPERTIES HEADER_FILE_ONLY TRUE)
@@ -421,23 +423,23 @@ set_source_files_properties(${PUBLIC_SHADERS} PROPERTIES HEADER_FILE_ONLY TRUE)
 file(MAKE_DIRECTORY ${FFX_PASS_SHADER_OUTPUT_PATH})
 
 if (FFX_AUTO_COMPILE_SHADERS)
-	set(FFX_SC_DEPENDENT_TARGET ffx_backend_dx12_${FFX_PLATFORM_NAME})
+	set(FFX_SC_DEPENDENT_TARGET backend_dx12)
 else()
-    set(FFX_SC_DEPENDENT_TARGET ffx_backend_dx12_shaders_${FFX_PLATFORM_NAME})
+    set(FFX_SC_DEPENDENT_TARGET backend_dx12_shaders)
     add_custom_target(${FFX_SC_DEPENDENT_TARGET})
-    #add_dependencies(ffx_backend_dx12_${FFX_PLATFORM_NAME} ${FFX_SC_DEPENDENT_TARGET})
+    #add_dependencies(backend_dx12 ${FFX_SC_DEPENDENT_TARGET})
 endif()
 
 if(${CMAKE_VERSION} VERSION_GREATER_EQUAL "3.20.0")
 	cmake_policy(SET CMP0116 OLD)
 endif()
 
-target_compile_definitions(ffx_backend_dx12_${FFX_PLATFORM_NAME} PRIVATE
+target_compile_definitions(backend_dx12 PRIVATE
 	NOMINMAX
 	WIN32_LEAN_AND_MEAN)
 
 if (MSVC)
-	target_compile_options(ffx_backend_dx12_${FFX_PLATFORM_NAME} PRIVATE
+	target_compile_options(backend_dx12 PRIVATE
 	"/W4" # warning level 4
 	"/WX" # warnings as errors
 	# disable MSVC warnings that are too strict
@@ -450,110 +452,110 @@ endif()
 
 # add pass shaders for all the components
 if (FFX_FSR1 OR FFX_ALL)
-	target_compile_definitions(ffx_backend_dx12_${FFX_PLATFORM_NAME} PRIVATE FFX_FSR1)
+	target_compile_definitions(backend_dx12 PRIVATE FFX_FSR1)
     include (CMakeShadersFSR1.txt)
 endif()
 
 if (FFX_FSR2 OR FFX_ALL)
-	target_compile_definitions(ffx_backend_dx12_${FFX_PLATFORM_NAME} PRIVATE FFX_FSR2)
+	target_compile_definitions(backend_dx12 PRIVATE FFX_FSR2)
 	include (CMakeShadersFSR2.txt)
 endif()
 
 if (FFX_FSR3 OR FFX_ALL)
-	target_compile_definitions(ffx_backend_dx12_${FFX_PLATFORM_NAME} PRIVATE FFX_FSR3)
+	target_compile_definitions(backend_dx12 PRIVATE FFX_FSR3)
 endif()
 
 if (FFX_FSR3UPSCALER OR FFX_ALL)
-	target_compile_definitions(ffx_backend_dx12_${FFX_PLATFORM_NAME} PRIVATE FFX_FSR3UPSCALER)
+	target_compile_definitions(backend_dx12 PRIVATE FFX_FSR3UPSCALER)
     include (CMakeShadersFSR3Upscaler.txt)
 endif()
 
 if (FFX_FI OR FFX_ALL)
-	target_compile_definitions(ffx_backend_dx12_${FFX_PLATFORM_NAME} PRIVATE FFX_FI)
+	target_compile_definitions(backend_dx12 PRIVATE FFX_FI)
 	include (CMakeShadersFrameinterpolation.txt)
 endif()
 
 if (FFX_OF OR FFX_ALL)
-	target_compile_definitions(ffx_backend_dx12_${FFX_PLATFORM_NAME} PRIVATE FFX_OF)
+	target_compile_definitions(backend_dx12 PRIVATE FFX_OF)
 	include (CMakeShadersOpticalflow.txt)
 endif()
 
 if (FFX_SPD OR FFX_ALL)
-	target_compile_definitions(ffx_backend_dx12_${FFX_PLATFORM_NAME} PRIVATE FFX_SPD)
+	target_compile_definitions(backend_dx12 PRIVATE FFX_SPD)
 	include (CMakeShadersSPD.txt)
 endif()
 
 if (FFX_CACAO OR FFX_ALL)
-	target_compile_definitions(ffx_backend_dx12_${FFX_PLATFORM_NAME} PRIVATE FFX_CACAO)
+	target_compile_definitions(backend_dx12 PRIVATE FFX_CACAO)
 	include (CMakeShadersCACAO.txt)
 endif()
 
 if (FFX_LPM OR FFX_ALL)
-	target_compile_definitions(ffx_backend_dx12_${FFX_PLATFORM_NAME} PRIVATE FFX_LPM)
+	target_compile_definitions(backend_dx12 PRIVATE FFX_LPM)
 	include (CMakeShadersLPM.txt)
 endif()
 
 if (FFX_BLUR OR FFX_ALL)
-	target_compile_definitions(ffx_backend_dx12_${FFX_PLATFORM_NAME} PRIVATE FFX_BLUR)
-	include (CMakeShadersBlur.txt)
+	target_compile_definitions(backend_dx12 PRIVATE FFX_BLUR)
+	include (CMakeShadersBLUR.txt)
 endif()
 
 if (FFX_VRS OR FFX_ALL)
-	target_compile_definitions(ffx_backend_dx12_${FFX_PLATFORM_NAME} PRIVATE FFX_VRS)
+	target_compile_definitions(backend_dx12 PRIVATE FFX_VRS)
 	include (CMakeShadersVRS.txt)
 endif()
 
 if (FFX_CAS OR FFX_ALL)
-	target_compile_definitions(ffx_backend_dx12_${FFX_PLATFORM_NAME} PRIVATE FFX_CAS)
+	target_compile_definitions(backend_dx12 PRIVATE FFX_CAS)
 	include (CMakeShadersCAS.txt)
 endif()
 
 if (FFX_DOF OR FFX_ALL)
-	target_compile_definitions(ffx_backend_dx12_${FFX_PLATFORM_NAME} PRIVATE FFX_DOF)
+	target_compile_definitions(backend_dx12 PRIVATE FFX_DOF)
 	include (CMakeShadersDOF.txt)
 endif()
 
 if (FFX_LENS OR FFX_ALL)
-	target_compile_definitions(ffx_backend_dx12_${FFX_PLATFORM_NAME} PRIVATE FFX_LENS)
+	target_compile_definitions(backend_dx12 PRIVATE FFX_LENS)
 	include (CMakeShadersLENS.txt)
 endif()
 
 if (FFX_PARALLEL_SORT OR FFX_ALL)
-	target_compile_definitions(ffx_backend_dx12_${FFX_PLATFORM_NAME} PRIVATE FFX_PARALLEL_SORT)
+	target_compile_definitions(backend_dx12 PRIVATE FFX_PARALLEL_SORT)
 	include (CMakeShadersParallelSort.txt)
 endif()
 
 if (FFX_DENOISER OR FFX_ALL)
-	target_compile_definitions(ffx_backend_dx12_${FFX_PLATFORM_NAME} PRIVATE FFX_DENOISER)
+	target_compile_definitions(backend_dx12 PRIVATE FFX_DENOISER)
 	include (CMakeShadersDenoiser.txt)
 endif()
 
 if (FFX_CLASSIFIER OR FFX_ALL)
-	target_compile_definitions(ffx_backend_dx12_${FFX_PLATFORM_NAME} PRIVATE FFX_CLASSIFIER)
+	target_compile_definitions(backend_dx12 PRIVATE FFX_CLASSIFIER)
 	include (CMakeShadersClassifier.txt)
 endif()
 
 if (FFX_SSSR OR FFX_ALL)
-	target_compile_definitions(ffx_backend_dx12_${FFX_PLATFORM_NAME} PRIVATE FFX_SSSR)
+	target_compile_definitions(backend_dx12 PRIVATE FFX_SSSR)
 	include (CMakeShadersSSSR.txt)
 endif()
 
 if (FFX_BREADCRUMBS OR FFX_ALL)
-	target_compile_definitions(ffx_backend_dx12_${FFX_PLATFORM_NAME} PRIVATE FFX_BREADCRUMBS)
+	target_compile_definitions(backend_dx12 PRIVATE FFX_BREADCRUMBS)
 endif()
 
 if (FFX_BRIXELIZER OR FFX_ALL)
-	target_compile_definitions(ffx_backend_dx12_${FFX_PLATFORM_NAME} PRIVATE FFX_BRIXELIZER)
+	target_compile_definitions(backend_dx12 PRIVATE FFX_BRIXELIZER)
 	include (CMakeShadersBrixelizer.txt)
 endif()
 
 if (FFX_BRIXELIZER_GI OR FFX_ALL)
-	target_compile_definitions(ffx_backend_dx12_${FFX_PLATFORM_NAME} PRIVATE FFX_BRIXELIZER_GI)
+	target_compile_definitions(backend_dx12 PRIVATE FFX_BRIXELIZER_GI)
 	include (CMakeShadersBrixelizerGI.txt)
 endif()
 
 if (FFX_CLASSIFIER OR FFX_ALL)
-    target_compile_definitions(ffx_backend_dx12_${FFX_PLATFORM_NAME} PRIVATE FFX_CLASSIFIER)
+    target_compile_definitions(backend_dx12 PRIVATE FFX_CLASSIFIER)
     include (CMakeShadersClassifier.txt)
 endif()
 
@@ -561,8 +563,8 @@ add_custom_target(ffx_shader_permutations_dx12 DEPENDS ${FFX_SC_PERMUTATION_OUTP
 add_dependencies(${FFX_SC_DEPENDENT_TARGET} ffx_shader_permutations_dx12)
 
 # Make sure shader builds are a dependency of the backend
-add_dependencies(ffx_backend_dx12_${FFX_PLATFORM_NAME} ffx_shader_permutations_dx12)
+add_dependencies(backend_dx12 ffx_shader_permutations_dx12)
 
 # Add to solution folder.
-set_target_properties(ffx_backend_dx12_${FFX_PLATFORM_NAME} PROPERTIES FOLDER Backends)
+set_target_properties(backend_dx12 PROPERTIES FOLDER Backends)
 set_target_properties(ffx_shader_permutations_dx12 PROPERTIES FOLDER Backends)
diff --git a/sdk/src/backends/dx12/FrameInterpolationSwapchain/FrameInterpolationSwapchainDX12.cpp b/sdk/src/backends/dx12/FrameInterpolationSwapchain/FrameInterpolationSwapchainDX12.cpp
index 90cf777..98db4e8 100644
--- a/sdk/src/backends/dx12/FrameInterpolationSwapchain/FrameInterpolationSwapchainDX12.cpp
+++ b/sdk/src/backends/dx12/FrameInterpolationSwapchain/FrameInterpolationSwapchainDX12.cpp
@@ -650,7 +650,7 @@ bool FrameInterpolationSwapChainDX12::verifyBackbufferDuplicateResources()
                 }
             }
 
-            for (size_t i = 0; i < _countof(interpolationOutputs); i++)
+            for (size_t i = 0; i < std::size(interpolationOutputs); i++)
             {
                 // create interpolation output resource
                 bufferDesc.Flags |= D3D12_RESOURCE_FLAG_ALLOW_UNORDERED_ACCESS;
@@ -923,7 +923,7 @@ bool FrameInterpolationSwapChainDX12::spawnPresenterThread()
 void FrameInterpolationSwapChainDX12::discardOutstandingInterpolationCommandLists()
 {
     // drop any outstanding interpolaton command lists
-    for (size_t i = 0; i < _countof(registeredInterpolationCommandLists); i++)
+    for (size_t i = 0; i < std::size(registeredInterpolationCommandLists); i++)
     {
         if (registeredInterpolationCommandLists[i] != nullptr)
         {
@@ -1035,7 +1035,7 @@ bool FrameInterpolationSwapChainDX12::destroyReplacementResources()
     discardOutstandingInterpolationCommandLists();
 
     {
-        for (size_t i = 0; i < _countof(replacementSwapBuffers); i++)
+        for (size_t i = 0; i < std::size(replacementSwapBuffers); i++)
         {
             uint64_t resourceSize = GetResourceGpuMemorySize(replacementSwapBuffers[i].resource);
             totalUsageInBytes -= resourceSize;
@@ -1044,7 +1044,7 @@ bool FrameInterpolationSwapChainDX12::destroyReplacementResources()
 
         SafeRelease(realBackBuffer0);
         
-        for (size_t i = 0; i < _countof(interpolationOutputs); i++)
+        for (size_t i = 0; i < std::size(interpolationOutputs); i++)
         {
             uint64_t resourceSize = GetResourceGpuMemorySize(interpolationOutputs[i].resource);
             totalUsageInBytes -= resourceSize;
@@ -1272,18 +1272,18 @@ void FrameInterpolationSwapChainDX12::presentPassthrough(UINT SyncInterval, UINT
     barriers[1].Transition.pResource   = dx12ResourceDst;
     barriers[1].Transition.StateBefore = D3D12_RESOURCE_STATE_PRESENT;
     barriers[1].Transition.StateAfter  = D3D12_RESOURCE_STATE_COPY_DEST;
-    list->ResourceBarrier(_countof(barriers), barriers);
+    list->ResourceBarrier(std::size(barriers), barriers);
 
     list->CopyResource(dx12ResourceDst, dx12ResourceSrc);
 
-    for (size_t i = 0; i < _countof(barriers); ++i)
+    for (size_t i = 0; i < std::size(barriers); ++i)
     {
         D3D12_RESOURCE_STATES tmpStateBefore = barriers[i].Transition.StateBefore;
         barriers[i].Transition.StateBefore   = barriers[i].Transition.StateAfter;
         barriers[i].Transition.StateAfter    = tmpStateBefore;
     }
 
-    list->ResourceBarrier(_countof(barriers), barriers);
+    list->ResourceBarrier(std::size(barriers), barriers);
 
     passthroughList->execute(true);
 
@@ -1580,18 +1580,18 @@ void FrameInterpolationSwapChainDX12::copyUiResource()
     barriers[1].Transition.pResource   = dx12ResourceDst;
     barriers[1].Transition.StateBefore = ffxGetDX12StateFromResourceState(presentInfo.currentUiSurface.state);
     barriers[1].Transition.StateAfter  = D3D12_RESOURCE_STATE_COPY_DEST;
-    dx12List->ResourceBarrier(_countof(barriers), barriers);
+    dx12List->ResourceBarrier(std::size(barriers), barriers);
 
     dx12List->CopyResource(dx12ResourceDst, dx12ResourceSrc);
 
-    for (size_t i = 0; i < _countof(barriers); ++i)
+    for (size_t i = 0; i < std::size(barriers); ++i)
     {
         D3D12_RESOURCE_STATES tmpStateBefore = barriers[i].Transition.StateBefore;
         barriers[i].Transition.StateBefore   = barriers[i].Transition.StateAfter;
         barriers[i].Transition.StateAfter    = tmpStateBefore;
     }
 
-    dx12List->ResourceBarrier(_countof(barriers), barriers);
+    dx12List->ResourceBarrier(std::size(barriers), barriers);
 
     copyList->execute(true);
 
@@ -1664,7 +1664,7 @@ HRESULT STDMETHODCALLTYPE FrameInterpolationSwapChainDX12::Present(UINT SyncInte
     // Unregister any potential command list
     registeredInterpolationCommandLists[currentBackBufferIndex] = nullptr;
     presentCount++;
-    interpolationBufferIndex                                                   = presentCount % _countof(interpolationOutputs);
+    interpolationBufferIndex                                                   = presentCount % std::size(interpolationOutputs);
 
     //update active backbuffer and block when no buffer is available
     replacementSwapBufferIndex = presentCount % gameBufferCount;
diff --git a/sdk/src/backends/dx12/FrameInterpolationSwapchain/FrameInterpolationSwapchainDX12_Helpers.h b/sdk/src/backends/dx12/FrameInterpolationSwapchain/FrameInterpolationSwapchainDX12_Helpers.h
index 855b502..1ca70c1 100644
--- a/sdk/src/backends/dx12/FrameInterpolationSwapchain/FrameInterpolationSwapchainDX12_Helpers.h
+++ b/sdk/src/backends/dx12/FrameInterpolationSwapchain/FrameInterpolationSwapchainDX12_Helpers.h
@@ -218,7 +218,7 @@ public:
         }
 
         ID3D12CommandList* pListsToExec[] = {list};
-        queue->ExecuteCommandLists(_countof(pListsToExec), pListsToExec);
+        queue->ExecuteCommandLists(std::size(pListsToExec), pListsToExec);
         queue->Signal(fence, availableFenceValue);
     }
 
diff --git a/sdk/src/backends/dx12/FrameInterpolationSwapchain/FrameInterpolationSwapchainDX12_UiComposition.cpp b/sdk/src/backends/dx12/FrameInterpolationSwapchain/FrameInterpolationSwapchainDX12_UiComposition.cpp
index aa6dbab..1afdd4d 100644
--- a/sdk/src/backends/dx12/FrameInterpolationSwapchain/FrameInterpolationSwapchainDX12_UiComposition.cpp
+++ b/sdk/src/backends/dx12/FrameInterpolationSwapchain/FrameInterpolationSwapchainDX12_UiComposition.cpp
@@ -296,18 +296,18 @@ FFX_API FfxErrorCode ffxFrameInterpolationUiComposition(const FfxPresentCallback
         barriers[1].Transition.pResource   = pRtResource;
         barriers[1].Transition.StateBefore = ffxGetDX12StateFromResourceState(params->outputSwapChainBuffer.state);
         barriers[1].Transition.StateAfter  = D3D12_RESOURCE_STATE_COPY_DEST;
-        pCmdList->ResourceBarrier(_countof(barriers), barriers);
+        pCmdList->ResourceBarrier(std::size(barriers), barriers);
 
         pCmdList->CopyResource(pRtResource, pResBackbuffer);
 
-        for (size_t i = 0; i < _countof(barriers); ++i)
+        for (size_t i = 0; i < std::size(barriers); ++i)
         {
             D3D12_RESOURCE_STATES tmpStateBefore = barriers[i].Transition.StateBefore;
             barriers[i].Transition.StateBefore   = barriers[i].Transition.StateAfter;
             barriers[i].Transition.StateAfter    = tmpStateBefore;
         }
 
-        pCmdList->ResourceBarrier(_countof(barriers), barriers);
+        pCmdList->ResourceBarrier(std::size(barriers), barriers);
     }
     else
     {
diff --git a/sdk/src/backends/dx12/ffx_dx12.cpp b/sdk/src/backends/dx12/ffx_dx12.cpp
index 95cc5a8..1f4503c 100644
--- a/sdk/src/backends/dx12/ffx_dx12.cpp
+++ b/sdk/src/backends/dx12/ffx_dx12.cpp
@@ -103,7 +103,7 @@ typedef struct BackendContext_DX12 {
     typedef struct Resource
     {
 #ifdef _DEBUG
-        wchar_t                 resourceName[64] = {};
+        char                    resourceName[64] = {};
 #endif
         ID3D12Resource*         resourcePtr;
         FfxResourceDescription  resourceDescription;
@@ -316,7 +316,7 @@ FfxPipeline ffxGetPipelineDX12(ID3D12PipelineState* pipelineState)
 // register a DX12 resource to the backend
 FfxResource ffxGetResourceDX12(const ID3D12Resource* dx12Resource,
     FfxResourceDescription                     ffxResDescription,
-    const wchar_t* ffxResName,
+    const char*                                ffxResName,
     FfxResourceStates                          state /*=FFX_RESOURCE_STATE_COMPUTE_READ*/)
 {
     FfxResource resource = {};
@@ -326,7 +326,7 @@ FfxResource ffxGetResourceDX12(const ID3D12Resource* dx12Resource,
 
 #ifdef _DEBUG
     if (ffxResName) {
-        wcscpy_s(resource.name, ffxResName);
+        strcpy(resource.name, ffxResName);
     }
 #else
     (void)ffxResName;
@@ -335,14 +335,14 @@ FfxResource ffxGetResourceDX12(const ID3D12Resource* dx12Resource,
     return resource;
 }
 
-FfxErrorCode ffxLoadPixDll(const wchar_t* pixDllPath)
+FfxErrorCode ffxLoadPixDll(const char* pixDllPath)
 {
 #if defined(ENABLE_PIX_CAPTURES)
     // Only do this once
     if (s_PIXDLLLoaded)
         return FFX_OK;
 
-    HMODULE module = LoadLibrary(pixDllPath);
+    HMODULE module = LoadLibraryA(pixDllPath);
 
     if (!module)
     {
@@ -860,7 +860,7 @@ ID3D12Resource* getDX12ResourcePtr(BackendContext_DX12* backendContext, int32_t
     return reinterpret_cast<ID3D12Resource*>(backendContext->pResources[resourceIndex].resourcePtr);
 }
 
-void beginMarkerDX12(BackendContext_DX12* backendContext, ID3D12GraphicsCommandList* pCmdList, const wchar_t* label)
+void beginMarkerDX12(BackendContext_DX12* backendContext, ID3D12GraphicsCommandList* pCmdList, const char* label)
 {
     FFX_ASSERT(nullptr != backendContext);
     FFX_ASSERT(nullptr != pCmdList);
@@ -868,9 +868,7 @@ void beginMarkerDX12(BackendContext_DX12* backendContext, ID3D12GraphicsCommandL
 #if defined(ENABLE_PIX_CAPTURES)
     if (s_PIXDLLLoaded)
     {
-        char strLabel[FFX_RESOURCE_NAME_SIZE];
-        WideCharToMultiByte(CP_UTF8, 0, label, -1, strLabel, int(std::size(strLabel)), nullptr, nullptr);
-        pixBeginEventOnCommandList(pCmdList, 0, strLabel);
+        pixBeginEventOnCommandList(pCmdList, 0, label);
     }
 #endif // #if defined(ENABLE_PIX_CAPTURES)
 }
@@ -1430,7 +1428,7 @@ FfxErrorCode CreateResourceDX12(
         backendResource->resourcePtr = dx12Resource;
 
 #ifdef _DEBUG
-        wcscpy_s(backendResource->resourceName, createResourceDescription->name);
+        strcpy(backendResource->resourceName, createResourceDescription->name);
 #endif
         return FFX_OK;
 
@@ -1453,7 +1451,7 @@ FfxErrorCode CreateResourceDX12(
         backendResource->resourcePtr = dx12Resource;
 
 #ifdef _DEBUG
-        wcscpy_s(backendResource->resourceName, createResourceDescription->name);
+        strcpy(backendResource->resourceName, createResourceDescription->name);
 #endif
 
         // Create SRVs and UAVs
@@ -1627,7 +1625,7 @@ FfxErrorCode CreateResourceDX12(
             backendInterface->fpCreateResource(backendInterface, &uploadDescription, effectContextId, &copySrc);
 
             // setup the upload job
-            FfxGpuJobDescription copyJob  = { FFX_GPU_JOB_COPY, L"Resource Initialization Copy" };
+            FfxGpuJobDescription copyJob  = { FFX_GPU_JOB_COPY, "Resource Initialization Copy" };
             copyJob.copyJobDescriptor.src = copySrc;
             copyJob.copyJobDescriptor.dst = *outTexture;
             copyJob.copyJobDescriptor.srcOffset = 0;
@@ -1771,9 +1769,9 @@ FfxErrorCode RegisterResourceDX12(
     backendResource->currentState = state;
 
 #ifdef _DEBUG
-    const wchar_t* name = inFfxResource->name;
+    const char* name = inFfxResource->name;
     if (name) {
-        wcscpy_s(backendResource->resourceName, name);
+        strcpy(backendResource->resourceName, name);
     }
 #endif
 
@@ -1997,7 +1995,7 @@ FfxResource GetResourceDX12(FfxInterface* backendInterface, FfxResourceInternal
 #ifdef _DEBUG
     if (backendContext->pResources[inResource.internalIndex].resourceName)
     {
-        wcscpy_s(resource.name, backendContext->pResources[inResource.internalIndex].resourceName);
+        strcpy(resource.name, backendContext->pResources[inResource.internalIndex].resourceName);
     }
 #endif
 
@@ -2930,7 +2928,7 @@ FfxErrorCode CreatePipelineDX12(
 
     // Set the pipeline name
     reinterpret_cast<ID3D12PipelineState*>(outPipeline->pipeline)->SetName(pipelineDescription->name);
-    wcscpy_s(outPipeline->name, pipelineDescription->name);
+    strcpy(outPipeline->name, pipelineDescription->name);
 
     return FFX_OK;
 }
@@ -3522,7 +3520,7 @@ static void breadcrumbsAllocBlockVirtual(ID3D12Device3* dx12Device, D3D12_RESOUR
                 ID3D12Resource* resource = nullptr;
                 if (SUCCEEDED(dx12Device->CreatePlacedResource(heap, 0, resDesc, D3D12_RESOURCE_STATE_COPY_DEST, nullptr, IID_PPV_ARGS(&resource))))
                 {
-                    resource->SetName(L"Buffer for Breadcrumbs - placed in VirtualAlloc, OpenExistingHeapFromAddress");
+                    resource->SetName("Buffer for Breadcrumbs - placed in VirtualAlloc, OpenExistingHeapFromAddress");
                     blockData->heap = (void*)heap;
                     blockData->buffer = (void*)resource;
                     return;
@@ -3584,7 +3582,7 @@ FfxErrorCode BreadcrumbsAllocBlockDX12(
             // Cannot map breadcrumbs buffer!
             return FFX_ERROR_BACKEND_API_ERROR;
         }
-        resource->SetName(L"Buffer for Breadcrumbs - committed");
+        resource->SetName("Buffer for Breadcrumbs - committed");
         blockData->buffer = (void*)resource;
     }
 
diff --git a/sdk/src/backends/shared/blob_accessors/ffx_brixelizer_shaderblobs.cpp b/sdk/src/backends/shared/blob_accessors/ffx_brixelizer_shaderblobs.cpp
index 0ec49f4..cf54db4 100644
--- a/sdk/src/backends/shared/blob_accessors/ffx_brixelizer_shaderblobs.cpp
+++ b/sdk/src/backends/shared/blob_accessors/ffx_brixelizer_shaderblobs.cpp
@@ -1415,7 +1415,7 @@ FfxErrorCode brixelizerGetPermutationBlobByIndex(
     }
 
     // return an empty blob
-    memset(&outBlob, 0, sizeof(FfxShaderBlob));
+    memset(outBlob, 0, sizeof(FfxShaderBlob));
     return FFX_OK;
 }
 
diff --git a/sdk/src/backends/shared/blob_accessors/ffx_brixelizergi_shaderblobs.cpp b/sdk/src/backends/shared/blob_accessors/ffx_brixelizergi_shaderblobs.cpp
index 931abb4..fdb03a7 100644
--- a/sdk/src/backends/shared/blob_accessors/ffx_brixelizergi_shaderblobs.cpp
+++ b/sdk/src/backends/shared/blob_accessors/ffx_brixelizergi_shaderblobs.cpp
@@ -875,7 +875,7 @@ FfxErrorCode brixelizerGIGetPermutationBlobByIndex(
     }
 
     // return an empty blob
-    memset(&outBlob, 0, sizeof(FfxShaderBlob));
+    memset(outBlob, 0, sizeof(FfxShaderBlob));
     return FFX_OK;
 }
 
diff --git a/sdk/src/backends/shared/blob_accessors/ffx_classifier_shaderblobs.cpp b/sdk/src/backends/shared/blob_accessors/ffx_classifier_shaderblobs.cpp
index 1bcd3a5..203d257 100644
--- a/sdk/src/backends/shared/blob_accessors/ffx_classifier_shaderblobs.cpp
+++ b/sdk/src/backends/shared/blob_accessors/ffx_classifier_shaderblobs.cpp
@@ -135,7 +135,7 @@ FfxErrorCode classifierGetPermutationBlobByIndex(
     }
 
     // return an empty blob
-    memset(&outBlob, 0, sizeof(FfxShaderBlob));
+    memset(outBlob, 0, sizeof(FfxShaderBlob));
     return FFX_OK;
 }
 
diff --git a/sdk/src/backends/vk/CMakeLists.txt b/sdk/src/backends/vk/CMakeLists.txt
index c19b659..7720ea9 100644
--- a/sdk/src/backends/vk/CMakeLists.txt
+++ b/sdk/src/backends/vk/CMakeLists.txt
@@ -27,17 +27,17 @@ endif()
 #include CMake custom command generator functions for compiling shaders.
 include("${FFX_GPU_PATH}/CMakeCompileShaders.txt")
 
-function (CheckVulkanSDKVersion)
-    # set the desired version
-    set(vulkan_min_version "1.3.250")
-
-    if (${Vulkan_VERSION} VERSION_LESS ${vulkan_min_version})
-        message(FATAL_ERROR "Vulkan SDK ${vulkan_min_version} or above is required. Found Vulkan SDK ${Vulkan_VERSION}")
-    endif()
-endfunction()
+# function (CheckVulkanSDKVersion)
+#     # set the desired version
+#     set(vulkan_min_version "1.3.250")
+# 
+#     if (${Vulkan_VERSION} VERSION_LESS ${vulkan_min_version})
+#         message(FATAL_ERROR "Vulkan SDK ${vulkan_min_version} or above is required. Found Vulkan SDK ${Vulkan_VERSION}")
+#     endif()
+# endfunction()
 
-find_package(Vulkan REQUIRED)
-CheckVulkanSDKVersion()
+find_package(VulkanHeaders CONFIG REQUIRED)
+# CheckVulkanSDKVersion()
 
 set(PUBLIC_SHADERS "")
 set(PRIVATE_SHADERS "")
@@ -52,8 +52,8 @@ file(GLOB PRIVATE_SOURCE
 	"${FFX_SRC_BACKENDS_PATH}/shared/blob_accessors/"
     "${CMAKE_CURRENT_SOURCE_DIR}/*.h"
     "${CMAKE_CURRENT_SOURCE_DIR}/*.cpp"
-    "${CMAKE_CURRENT_SOURCE_DIR}/FrameInterpolationSwapchain/*.h"
-    "${CMAKE_CURRENT_SOURCE_DIR}/FrameInterpolationSwapchain/*.cpp"
+    # "${CMAKE_CURRENT_SOURCE_DIR}/FrameInterpolationSwapchain/*.h"
+    # "${CMAKE_CURRENT_SOURCE_DIR}/FrameInterpolationSwapchain/*.cpp"
 )
 
 if (FFX_FSR1 OR FFX_ALL)
@@ -403,9 +403,9 @@ file(GLOB_RECURSE PUBLIC_SOURCE
     "${FFX_HOST_BACKENDS_PATH}/vk/*.h")
 
 if (FFX_BUILD_AS_DLL)
-    add_library(ffx_backend_vk_${FFX_PLATFORM_NAME} SHARED ${PRIVATE_SOURCE} ${PUBLIC_SOURCE} ${PRIVATE_SHADERS} ${PUBLIC_SHADERS})
+    add_library(backend_vk SHARED ${PRIVATE_SOURCE} ${PUBLIC_SOURCE} ${PRIVATE_SHADERS} ${PUBLIC_SHADERS})
 else()
-    add_library(ffx_backend_vk_${FFX_PLATFORM_NAME} STATIC ${PRIVATE_SOURCE} ${PUBLIC_SOURCE} ${PRIVATE_SHADERS} ${PUBLIC_SHADERS})
+    add_library(backend_vk STATIC ${PRIVATE_SOURCE} ${PUBLIC_SOURCE} ${PRIVATE_SHADERS} ${PUBLIC_SHADERS})
 endif()
 
 # vk backend source
@@ -416,15 +416,17 @@ source_group("public_shaders"  FILES ${PUBLIC_SHADERS})
 
 get_filename_component(FFX_PASS_SHADER_OUTPUT_PATH ${CMAKE_CURRENT_BINARY_DIR}/../shaders/vk ABSOLUTE)
 
-target_include_directories(ffx_backend_vk_${FFX_PLATFORM_NAME} PUBLIC ${FFX_INCLUDE_PATH})
-target_include_directories(ffx_backend_vk_${FFX_PLATFORM_NAME} PUBLIC ${FFX_LIB_PATH})
-target_include_directories(ffx_backend_vk_${FFX_PLATFORM_NAME} PUBLIC ${FFX_PASS_SHADER_OUTPUT_PATH})
-target_include_directories(ffx_backend_vk_${FFX_PLATFORM_NAME} PRIVATE ${FFX_COMPONENTS_PATH})
-target_include_directories(ffx_backend_vk_${FFX_PLATFORM_NAME} PRIVATE ${FFX_SHARED_PATH})
-target_include_directories(ffx_backend_vk_${FFX_PLATFORM_NAME} PRIVATE "${FFX_SRC_BACKENDS_PATH}/shared")
-target_include_directories(ffx_backend_vk_${FFX_PLATFORM_NAME} PRIVATE ${FFX_PASS_SHADER_OUTPUT_PATH})
+target_include_directories(backend_vk PUBLIC
+	$<BUILD_INTERFACE:${FFX_INCLUDE_PATH}>
+	$<INSTALL_INTERFACE:include>)
+target_include_directories(backend_vk PRIVATE ${FFX_LIB_PATH})
+# target_include_directories(backend_vk PUBLIC ${FFX_PASS_SHADER_OUTPUT_PATH})
+target_include_directories(backend_vk PRIVATE ${FFX_COMPONENTS_PATH})
+target_include_directories(backend_vk PRIVATE ${FFX_SHARED_PATH})
+target_include_directories(backend_vk PRIVATE "${FFX_SRC_BACKENDS_PATH}/shared")
+target_include_directories(backend_vk PRIVATE ${FFX_PASS_SHADER_OUTPUT_PATH})
 
-target_link_libraries(ffx_backend_vk_${FFX_PLATFORM_NAME} "Vulkan::Vulkan")
+target_link_libraries(backend_vk Vulkan::Headers)
 
 set_source_files_properties(${PRIVATE_SHADERS} PROPERTIES HEADER_FILE_ONLY TRUE)
 set_source_files_properties(${PUBLIC_SHADERS} PROPERTIES HEADER_FILE_ONLY TRUE)
@@ -432,11 +434,11 @@ set_source_files_properties(${PUBLIC_SHADERS} PROPERTIES HEADER_FILE_ONLY TRUE)
 file(MAKE_DIRECTORY ${FFX_PASS_SHADER_OUTPUT_PATH})
 
 if (FFX_AUTO_COMPILE_SHADERS)
-    set(FFX_SC_DEPENDENT_TARGET ffx_backend_vk_${FFX_PLATFORM_NAME})
+    set(FFX_SC_DEPENDENT_TARGET backend_vk)
 else()
-    set(FFX_SC_DEPENDENT_TARGET ffx_backend_vk_shaders_${FFX_PLATFORM_NAME})
+    set(FFX_SC_DEPENDENT_TARGET backend_vk_shaders)
     add_custom_target(${FFX_SC_DEPENDENT_TARGET})
-    #add_dependencies(ffx_backend_vk_${FFX_PLATFORM_NAME} ${FFX_SC_DEPENDENT_TARGET})
+    #add_dependencies(backend_vk ${FFX_SC_DEPENDENT_TARGET})
 endif()
 
 if(${CMAKE_VERSION} VERSION_GREATER_EQUAL "3.20.0")
@@ -445,110 +447,110 @@ endif()
 
 # add pass shaders for all the components
 if (FFX_FSR1 OR FFX_ALL)
-	target_compile_definitions(ffx_backend_vk_${FFX_PLATFORM_NAME} PRIVATE FFX_FSR1)
+	target_compile_definitions(backend_vk PRIVATE FFX_FSR1)
     include (CMakeShadersFSR1.txt)
 endif()
 
 if (FFX_FSR2 OR FFX_ALL)
-	target_compile_definitions(ffx_backend_vk_${FFX_PLATFORM_NAME} PRIVATE FFX_FSR2)
+	target_compile_definitions(backend_vk PRIVATE FFX_FSR2)
 	include (CMakeShadersFSR2.txt)
 endif()
 
 if (FFX_FSR3 OR FFX_ALL)
-	target_compile_definitions(ffx_backend_vk_${FFX_PLATFORM_NAME} PRIVATE FFX_FSR3)
+	target_compile_definitions(backend_vk PRIVATE FFX_FSR3)
 endif()
 
 if (FFX_FSR3UPSCALER OR FFX_ALL)
-	target_compile_definitions(ffx_backend_vk_${FFX_PLATFORM_NAME} PRIVATE FFX_FSR3UPSCALER)
+	target_compile_definitions(backend_vk PRIVATE FFX_FSR3UPSCALER)
 	include (CMakeShadersFSR3Upscaler.txt)
 endif()
 
 if (FFX_FI OR FFX_ALL)
-	target_compile_definitions(ffx_backend_vk_${FFX_PLATFORM_NAME} PRIVATE FFX_FI)
+	target_compile_definitions(backend_vk PRIVATE FFX_FI)
 	include (CMakeShadersFrameinterpolation.txt)
 endif()
 
 if (FFX_OF OR FFX_ALL)
-	target_compile_definitions(ffx_backend_vk_${FFX_PLATFORM_NAME} PRIVATE FFX_OF)
+	target_compile_definitions(backend_vk PRIVATE FFX_OF)
 	include (CMakeShadersOpticalflow.txt)
 endif()
 
 if (FFX_SPD OR FFX_ALL)
-	target_compile_definitions(ffx_backend_vk_${FFX_PLATFORM_NAME} PRIVATE FFX_SPD)
+	target_compile_definitions(backend_vk PRIVATE FFX_SPD)
 	include (CMakeShadersSPD.txt)
 endif()
 
 if (FFX_CACAO OR FFX_ALL)
-	target_compile_definitions(ffx_backend_vk_${FFX_PLATFORM_NAME} PRIVATE FFX_CACAO)
+	target_compile_definitions(backend_vk PRIVATE FFX_CACAO)
 	include (CMakeShadersCACAO.txt)
 endif()
 
 if (FFX_LPM OR FFX_ALL)
-target_compile_definitions(ffx_backend_vk_${FFX_PLATFORM_NAME} PRIVATE FFX_LPM)
+target_compile_definitions(backend_vk PRIVATE FFX_LPM)
 	include (CMakeShadersLPM.txt)
 endif()
 
 if (FFX_BLUR OR FFX_ALL)
-	target_compile_definitions(ffx_backend_vk_${FFX_PLATFORM_NAME} PRIVATE FFX_BLUR)
-	include (CMakeShadersBlur.txt)
+	target_compile_definitions(backend_vk PRIVATE FFX_BLUR)
+	include (CMakeShadersBLUR.txt)
 endif()
 
 if (FFX_VRS OR FFX_ALL)
-	target_compile_definitions(ffx_backend_vk_${FFX_PLATFORM_NAME} PRIVATE FFX_VRS)
+	target_compile_definitions(backend_vk PRIVATE FFX_VRS)
 	include (CMakeShadersVRS.txt)
 endif()
 
 if (FFX_CAS OR FFX_ALL)
-	target_compile_definitions(ffx_backend_vk_${FFX_PLATFORM_NAME} PRIVATE FFX_CAS)
+	target_compile_definitions(backend_vk PRIVATE FFX_CAS)
 	include (CMakeShadersCAS.txt)
 endif()
 
 if (FFX_DOF OR FFX_ALL)
-	target_compile_definitions(ffx_backend_vk_${FFX_PLATFORM_NAME} PRIVATE FFX_DOF)
+	target_compile_definitions(backend_vk PRIVATE FFX_DOF)
 	include (CMakeShadersDOF.txt)
 endif()
 
 if (FFX_LENS OR FFX_ALL)
-	target_compile_definitions(ffx_backend_vk_${FFX_PLATFORM_NAME} PRIVATE FFX_LENS)
+	target_compile_definitions(backend_vk PRIVATE FFX_LENS)
 	include (CMakeShadersLENS.txt)
 endif()
 
 if (FFX_PARALLEL_SORT OR FFX_ALL)
-	target_compile_definitions(ffx_backend_vk_${FFX_PLATFORM_NAME} PRIVATE FFX_PARALLEL_SORT)
+	target_compile_definitions(backend_vk PRIVATE FFX_PARALLEL_SORT)
 	include (CMakeShadersParallelSort.txt)
 endif()
 
 if (FFX_DENOISER OR FFX_ALL)
-	target_compile_definitions(ffx_backend_vk_${FFX_PLATFORM_NAME} PRIVATE FFX_DENOISER)
+	target_compile_definitions(backend_vk PRIVATE FFX_DENOISER)
 	include (CMakeShadersDenoiser.txt)
 endif()
 
 if (FFX_CLASSIFIER OR FFX_ALL)
-	target_compile_definitions(ffx_backend_vk_${FFX_PLATFORM_NAME} PRIVATE FFX_CLASSIFIER)
+	target_compile_definitions(backend_vk PRIVATE FFX_CLASSIFIER)
 	include (CMakeShadersClassifier.txt)
 endif()
 
 if (FFX_SSSR OR FFX_ALL)
-	target_compile_definitions(ffx_backend_vk_${FFX_PLATFORM_NAME} PRIVATE FFX_SSSR)
+	target_compile_definitions(backend_vk PRIVATE FFX_SSSR)
 	include (CMakeShadersSSSR.txt)
 endif()
 
 if (FFX_BREADCRUMBS OR FFX_ALL)
-	target_compile_definitions(ffx_backend_vk_${FFX_PLATFORM_NAME} PRIVATE FFX_BREADCRUMBS)
+	target_compile_definitions(backend_vk PRIVATE FFX_BREADCRUMBS)
 endif()
 
 if (FFX_BRIXELIZER OR FFX_ALL)
-	target_compile_definitions(ffx_backend_vk_${FFX_PLATFORM_NAME} PRIVATE FFX_BRIXELIZER)
+	target_compile_definitions(backend_vk PRIVATE FFX_BRIXELIZER)
 	include (CMakeShadersBrixelizer.txt)
 endif()
 
 if (FFX_BRIXELIZER_GI OR FFX_ALL)
-	target_compile_definitions(ffx_backend_vk_${FFX_PLATFORM_NAME} PRIVATE FFX_BRIXELIZER_GI)
+	target_compile_definitions(backend_vk PRIVATE FFX_BRIXELIZER_GI)
 	include (CMakeShadersBrixelizerGI.txt)
 endif()
 
 if (FFX_CLASSIFIER OR FFX_ALL)
-    target_compile_definitions(ffx_backend_vk_${FFX_PLATFORM_NAME} PRIVATE FFX_CLASSIFIER)
+    target_compile_definitions(backend_vk PRIVATE FFX_CLASSIFIER)
     include (CMakeShadersClassifier.txt)
 endif()
 
@@ -556,8 +558,13 @@ add_custom_target(ffx_shader_permutations_vk DEPENDS ${FFX_SC_PERMUTATION_OUTPUT
 add_dependencies(${FFX_SC_DEPENDENT_TARGET} ffx_shader_permutations_vk)
 
 # Make sure shader builds are a dependency of the backend
-add_dependencies(ffx_backend_vk_${FFX_PLATFORM_NAME} ffx_shader_permutations_vk)
+add_dependencies(backend_vk ffx_shader_permutations_vk)
 
 # Add to solution folder.
-set_target_properties(ffx_backend_vk_${FFX_PLATFORM_NAME} PROPERTIES FOLDER Backends)
+set_target_properties(backend_vk PROPERTIES FOLDER Backends)
 set_target_properties(ffx_shader_permutations_vk PROPERTIES FOLDER Backends)
+
+install(TARGETS backend_vk EXPORT backend_vk-targets)
+install(EXPORT backend_vk-targets 
+	DESTINATION "${CMAKE_INSTALL_DATADIR}/cmake/${PROJECT_NAME}"
+	NAMESPACE fidelityfx::)
diff --git a/sdk/src/backends/vk/CMakeShadersBLUR.txt b/sdk/src/backends/vk/CMakeShadersBLUR.txt
index 106757d..b3a6c0c 100644
--- a/sdk/src/backends/vk/CMakeShadersBLUR.txt
+++ b/sdk/src/backends/vk/CMakeShadersBLUR.txt
@@ -25,4 +25,4 @@ set(BLUR_API_BASE_ARGS
     -compiler=glslang -e CS --target-env vulkan1.2 -S comp -Os -DFFX_GLSL=1)
 
 # Compile glsl blur shader
-include("${FFX_GPU_PATH}/blur/CmakeCompileBlurShaders.txt")
+include("${FFX_GPU_PATH}/blur/CMakeCompileBlurShaders.txt")
diff --git a/sdk/src/backends/vk/FrameInterpolationSwapchain/FrameInterpolationSwapchainVK.cpp b/sdk/src/backends/vk/FrameInterpolationSwapchain/FrameInterpolationSwapchainVK.cpp
index 2afa222..1c0cc0d 100644
--- a/sdk/src/backends/vk/FrameInterpolationSwapchain/FrameInterpolationSwapchainVK.cpp
+++ b/sdk/src/backends/vk/FrameInterpolationSwapchain/FrameInterpolationSwapchainVK.cpp
@@ -22,6 +22,9 @@
 
 #pragma once
 
+#include <array>
+#include <stdio.h>
+
 #include "FrameInterpolationSwapchainVK.h"
 #include "FrameInterpolationSwapchainVK_UiComposition.h"
 
@@ -330,7 +333,7 @@ bool waitForSemaphoreValue(VkDevice device, VkSemaphore semaphore, uint64_t valu
                 while (res == VK_TIMEOUT)
                 {
                     res = vkWaitSemaphores(device, &waitInfo, waitIntervalInNanoSeconds);
-                    waitCallback(L"FenceName", value);
+                    waitCallback("FenceName", value);
                 }
             }
             else
@@ -349,6 +352,7 @@ bool waitForSemaphoreValue(VkDevice device, VkSemaphore semaphore, uint64_t valu
     return false;
 }
 
+#ifdef _WIN32
 inline void SafeCloseHandle(HANDLE& handle)
 {
     if (handle)
@@ -357,6 +361,7 @@ inline void SafeCloseHandle(HANDLE& handle)
         handle = NULL;
     }
 }
+#endif
 
 FrameInterpolationSwapChainVK* createFrameInterpolationSwapChain(const VkAllocationCallbacks* pAllocator)
 {
@@ -655,7 +660,7 @@ FfxErrorCode ffxConfigureFrameInterpolationSwapchainVK(FfxSwapchain gameSwapChai
         switch (key)
         {
             case FFX_FI_SWAPCHAIN_CONFIGURE_KEY_WAITCALLBACK:
-                pSwapChainVK->setWaitCallback(static_cast<FfxWaitCallbackFunc>(valuePtr));
+                pSwapChainVK->setWaitCallback((FfxWaitCallbackFunc) valuePtr);
             break;
             case FFX_FI_SWAPCHAIN_CONFIGURE_KEY_FRAMEPACINGTUNING:
                 if (valuePtr != nullptr)
@@ -767,9 +772,13 @@ VkResult presentToSwapChain(FrameinterpolationPresentInfo* pPresenter, uint32_t
     presentInfoKHR.pImageIndices      = &imageIndex;
     presentInfoKHR.pResults           = nullptr;  // Optional
 
+#ifdef _WIN32
     EnterCriticalSection(&pPresenter->swapchainCriticalSection);
+#endif
     VkResult res = vkQueuePresentKHR(pPresenter->presentQueue.queue, &presentInfoKHR);
+#ifdef _WIN32
     LeaveCriticalSection(&pPresenter->swapchainCriticalSection);
+#endif
 
     ++(pPresenter->realPresentCount);
     return res;
@@ -905,6 +914,7 @@ VkResult compositeSwapChainFrame(FrameinterpolationPresentInfo* pPresenter,
     }
 }
 
+#ifdef _WIN32
 DWORD WINAPI copyAndPresent_presenterThread(LPVOID pParam)
 {
     FrameinterpolationPresentInfo* presenter = static_cast<FrameinterpolationPresentInfo*>(pParam);
@@ -1048,7 +1058,6 @@ DWORD WINAPI copyAndPresent_presenterThread(LPVOID pParam)
     return 0;
 }
 
-
 DWORD WINAPI composeAndPresent_presenterThread(LPVOID pParam)
 {
     FrameinterpolationPresentInfo* presenter = static_cast<FrameinterpolationPresentInfo*>(pParam);
@@ -1255,6 +1264,7 @@ DWORD WINAPI interpolationThread(LPVOID param)
 
     return 0;
 }
+#endif
 
 //////////////////////////////////////////////
 /// FrameInterpolationSwapChainVK
@@ -1285,20 +1295,26 @@ VkResult FrameInterpolationSwapChainVK::acquireNextImage(VkDevice device, VkSwap
     if (pImageIndex == nullptr)
         return VK_INCOMPLETE;
 
+#ifdef _WIN32
     EnterCriticalSection(&criticalSection);
+#endif
 
     *pImageIndex = (uint32_t)(acquiredCount % gameBufferCount);
 
     if (replacementSwapBuffers[*pImageIndex].image == VK_NULL_HANDLE)
     {
+#ifdef _WIN32
         LeaveCriticalSection(&criticalSection);
+#endif
         return VK_ERROR_SURFACE_LOST_KHR;
     }
 
     // limit the acquired count
     if (acquiredCount > presentCount && (acquiredCount - presentCount) >= gameBufferCount)
     {
+#ifdef _WIN32
         LeaveCriticalSection(&criticalSection);
+#endif
         return VK_NOT_READY;
     }
 
@@ -1314,7 +1330,9 @@ VkResult FrameInterpolationSwapChainVK::acquireNextImage(VkDevice device, VkSwap
 
     ++acquiredCount;
 
+#ifdef _WIN32
     LeaveCriticalSection(&criticalSection);
+#endif
 
     return res;
 }
@@ -1326,8 +1344,10 @@ struct SwapchainCreationInfo
 
     VkImageCompressionControlEXT             imageCompressionControl;
     VkImageFormatListCreateInfo              imageFormatList;
+#ifdef _WIN32
     VkSurfaceFullScreenExclusiveInfoEXT      surfaceFullScreenExclusive;
     VkSurfaceFullScreenExclusiveWin32InfoEXT surfaceFullScreenExclusiveWin32;
+#endif
     VkSwapchainCounterCreateInfoEXT          swapchainCounter;
     VkSwapchainDisplayNativeHdrCreateInfoAMD swapchainDisplayNativeHdr;
     VkSwapchainPresentModesCreateInfoEXT     swapchainPresentModes;
@@ -1362,12 +1382,16 @@ VkResult getRealSwapchainCreateInfo(const VkSwapchainCreateInfoKHR* pCreateInfo,
             FFX_USE_PNEXT_AS_IS(imageFormatList, VkImageFormatListCreateInfo);
             break;
         case VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT:
+#ifdef _WIN32
             realSwapchainCreateInfo.surfaceFullScreenExclusive       = *reinterpret_cast<const VkSurfaceFullScreenExclusiveInfoEXT*>(pCurrent);
             realSwapchainCreateInfo.surfaceFullScreenExclusive.pNext = const_cast<void*>(realSwapchainCreateInfo.swapchain.pNext);  // because pNext is void* instead of const void* in vulkan header
             realSwapchainCreateInfo.swapchain.pNext                  = &realSwapchainCreateInfo.surfaceFullScreenExclusive;
+#endif
             break;
         case VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT:
+#ifdef _WIN32
             FFX_USE_PNEXT_AS_IS(surfaceFullScreenExclusiveWin32, VkSurfaceFullScreenExclusiveWin32InfoEXT);
+#endif
             break;
         case VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT:
             FFX_USE_PNEXT_AS_IS(swapchainCounter, VkSwapchainCounterCreateInfoEXT);
@@ -1550,6 +1574,7 @@ VkResult FrameInterpolationSwapChainVK::init(const VkSwapchainCreateInfoKHR* pCr
             return VK_ERROR_INITIALIZATION_FAILED;
     }
 
+#ifdef _WIN32
     InitializeCriticalSection(&criticalSection);
     InitializeCriticalSection(&criticalSectionUpdateConfig);
     InitializeCriticalSection(&presentInfo.scheduledFrameCriticalSection);
@@ -1558,6 +1583,7 @@ VkResult FrameInterpolationSwapChainVK::init(const VkSwapchainCreateInfoKHR* pCr
     presentInfo.presentEvent       = CreateEvent(NULL, FALSE, FALSE, TEXT("PresentEvent"));
     presentInfo.interpolationEvent = CreateEvent(NULL, FALSE, TRUE, TEXT("InterpolationEvent"));
     presentInfo.pacerEvent         = CreateEvent(NULL, FALSE, FALSE, TEXT("PacerEvent"));
+#endif
 
     // create the real swapchain
     SwapchainCreationInfo realSwapchainCreateInfo;
@@ -1657,7 +1683,7 @@ VkResult FrameInterpolationSwapChainVK::init(const VkSwapchainCreateInfoKHR* pCr
     }
     // No need to set the layout of the images as vulkan API states that a presentable image starts out at an undefined layout.
 
-    for (uint32_t i = 0; i < _countof(interpolationOutputs); ++i)
+    for (uint32_t i = 0; i < std::size(interpolationOutputs); ++i)
     {
         res = createImage(interpolationOutputs[i],
                           info,
@@ -1719,6 +1745,7 @@ void FrameInterpolationSwapChainVK::destroySwapchain(VkDevice device, const VkAl
     presentInfo.asyncComputeQueue.reset();
     presentInfo.presentQueue.reset();
 
+#ifdef _WIN32
     // delete win32 objects
     DeleteCriticalSection(&criticalSection);
     DeleteCriticalSection(&criticalSectionUpdateConfig);
@@ -1728,6 +1755,7 @@ void FrameInterpolationSwapChainVK::destroySwapchain(VkDevice device, const VkAl
     SafeCloseHandle(presentInfo.presentEvent);
     SafeCloseHandle(presentInfo.interpolationEvent);
     SafeCloseHandle(presentInfo.pacerEvent);
+#endif
 
     // delete real swapchain
     vkDestroySwapchainKHR(device, presentInfo.realSwapchain, pAllocator);
@@ -1746,7 +1774,7 @@ void FrameInterpolationSwapChainVK::destroySwapchain(VkDevice device, const VkAl
         destroyImage(replacementSwapBuffers[i], pAllocator);
     }
 
-    for (uint32_t i = 0; i < _countof(interpolationOutputs); ++i)
+    for (uint32_t i = 0; i < std::size(interpolationOutputs); ++i)
     {
         destroyImage(interpolationOutputs[i], pAllocator);
     }
@@ -1777,7 +1805,7 @@ VkResult FrameInterpolationSwapChainVK::getSwapchainImages(VkDevice device, uint
 void FrameInterpolationSwapChainVK::discardOutstandingInterpolationCommandLists()
 {
     // drop any outstanding interpolaton command lists
-    for (int i = 0; i < _countof(registeredInterpolationCommandLists); i++)
+    for (int i = 0; i < std::size(registeredInterpolationCommandLists); i++)
     {
         if (registeredInterpolationCommandLists[i] != nullptr)
         {
@@ -1791,7 +1819,9 @@ void FrameInterpolationSwapChainVK::setFrameGenerationConfig(FfxFrameGenerationC
 {
     FFX_ASSERT(config);
 
+#ifdef _WIN32
     EnterCriticalSection(&criticalSectionUpdateConfig);
+#endif
 
     // if config is a pointer to the internal config ::present called this function to apply the changes
     bool applyChangesNow = (config == &nextFrameGenerationConfig);
@@ -1824,7 +1854,9 @@ void FrameInterpolationSwapChainVK::setFrameGenerationConfig(FfxFrameGenerationC
 
     if (applyChangesNow)
     {
+#ifdef _WIN32
         EnterCriticalSection(&criticalSection);
+#endif
 
         currentFrameID          = config->frameID;
         presentInterpolatedOnly = config->onlyPresentInterpolated;
@@ -1866,10 +1898,14 @@ void FrameInterpolationSwapChainVK::setFrameGenerationConfig(FfxFrameGenerationC
             }
         }
 
+#ifdef _WIN32
         LeaveCriticalSection(&criticalSection);
+#endif
     }
 
+#ifdef _WIN32
     LeaveCriticalSection(&criticalSectionUpdateConfig);
+#endif
 }
 
 bool FrameInterpolationSwapChainVK::waitForPresents()
@@ -2131,7 +2167,9 @@ VkResult FrameInterpolationSwapChainVK::presentInterpolated(const VkPresentInfoK
     dispatchInterpolationCommands(
         currentBackBufferIndex, &interpolatedFrame, &realFrame, ToWaitInterpolationQueue);
 
+#ifdef _WIN32
     EnterCriticalSection(&presentInfo.scheduledFrameCriticalSection);
+#endif
 
     PacingData entry{};
     entry.presentCallback                  = presentCallback;
@@ -2186,24 +2224,30 @@ VkResult FrameInterpolationSwapChainVK::presentInterpolated(const VkPresentInfoK
 
     presentInfo.resetTimer              = frameInterpolationResetCondition;
     presentInfo.scheduledInterpolations = entry;
+#ifdef _WIN32
     LeaveCriticalSection(&presentInfo.scheduledFrameCriticalSection);
 
     // Set event to kick off async CPU present thread
     SetEvent(presentInfo.presentEvent);
+#endif
 
     return presentInfo.lastPresentResult.load();
 }
 
 void FrameInterpolationSwapChainVK::registerUiResource(FfxResource uiResource, uint32_t flags)
 {
+#ifdef _WIN32
     EnterCriticalSection(&criticalSection);
+#endif
 
     presentInfo.currentUiSurface = uiResource;
     presentInfo.uiCompositionFlags = flags;
     if (nullptr == uiResource.resource)
         presentInfo.uiCompositionFlags &= ~FFX_UI_COMPOSITION_FLAG_ENABLE_INTERNAL_UI_DOUBLE_BUFFERING;
 
+#ifdef _WIN32
     LeaveCriticalSection(&criticalSection);
+#endif
 }
 
 void FrameInterpolationSwapChainVK::setWaitCallback(FfxWaitCallbackFunc waitCallbackFunc)
@@ -2521,9 +2565,13 @@ VkResult FrameInterpolationSwapChainVK::presentNonInterpolatedWithUiCompositionO
 VkResult FrameinterpolationPresentInfo::acquireNextRealImage(uint32_t& imageIndex, VkSemaphore& acquireSemaphore)
 {
     acquireSemaphore = acquireSemaphores[nextAcquireSemaphoreIndex];
+#ifdef _WIN32
     EnterCriticalSection(&swapchainCriticalSection);
+#endif
     VkResult res = vkAcquireNextImageKHR(device, realSwapchain, UINT64_MAX, acquireSemaphore, VK_NULL_HANDLE, &imageIndex);
+#ifdef _WIN32
     LeaveCriticalSection(&swapchainCriticalSection);
+#endif
     
     // only increment on success
     // no need to handle VK_NOT_READY or VK_TIMEOUT as timeout is UINT64_MAX
@@ -2546,7 +2594,9 @@ VkResult FrameInterpolationSwapChainVK::queuePresent(VkQueue queue, const VkPres
 
     setFrameGenerationConfig(&nextFrameGenerationConfig);
 
+#ifdef _WIN32
     EnterCriticalSection(&criticalSection);
+#endif
 
     uint32_t currentBackBufferIndex = replacementSwapBufferIndex;
 
@@ -2572,7 +2622,9 @@ VkResult FrameInterpolationSwapChainVK::queuePresent(VkQueue queue, const VkPres
 
     if (runInterpolation)
     {
+#ifdef _WIN32
         WaitForSingleObject(presentInfo.interpolationEvent, INFINITE);
+#endif
 
         res = presentInterpolated(pPresentInfo, currentBackBufferIndex, needUICopy);
     }
@@ -2645,12 +2697,14 @@ VkResult FrameInterpolationSwapChainVK::queuePresent(VkQueue queue, const VkPres
     // Unregister any potential command list
     registeredInterpolationCommandLists[currentBackBufferIndex] = nullptr;
     presentCount++;
-    interpolationBufferIndex = presentCount % _countof(interpolationOutputs);
+    interpolationBufferIndex = presentCount % std::size(interpolationOutputs);
 
     // update active backbuffer and block when no buffer is available
     replacementSwapBufferIndex = presentCount % gameBufferCount;
 
+#ifdef _WIN32
     LeaveCriticalSection(&criticalSection);
+#endif
 
     waitForSemaphoreValue(
         presentInfo.device, presentInfo.replacementBufferSemaphore, replacementSwapBuffers[replacementSwapBufferIndex].availabilitySemaphoreValue, UINT64_MAX, presentInfo.waitCallback);
@@ -2660,6 +2714,7 @@ VkResult FrameInterpolationSwapChainVK::queuePresent(VkQueue queue, const VkPres
 
 bool FrameInterpolationSwapChainVK::spawnPresenterThread()
 {
+#ifdef _WIN32
     if (interpolationThreadHandle == NULL)
     {
         presentInfo.shutdown = false;
@@ -2676,10 +2731,14 @@ bool FrameInterpolationSwapChainVK::spawnPresenterThread()
     }
 
     return interpolationThreadHandle != NULL;
+#else
+    return false;
+#endif
 }
 
 bool FrameInterpolationSwapChainVK::killPresenterThread()
 {
+#ifdef _WIN32
     if (interpolationThreadHandle != NULL)
     {
         // prepare present CPU thread for shutdown
@@ -2692,6 +2751,9 @@ bool FrameInterpolationSwapChainVK::killPresenterThread()
     }
 
     return interpolationThreadHandle == NULL;
+#else
+    return false;
+#endif
 }
 
 void FrameInterpolationSwapChainVK::setHdrMetadata(VkDevice device, const VkHdrMetadataEXT* pMetadata)
@@ -2712,7 +2774,9 @@ uint64_t FrameInterpolationSwapChainVK::getLastPresentCount()
 
 VkCommandBuffer FrameInterpolationSwapChainVK::getInterpolationCommandList()
 {
+#ifdef _WIN32
     EnterCriticalSection(&criticalSection);
+#endif
 
     VkCommandBuffer commandBuffer = VK_NULL_HANDLE;
 
@@ -2738,7 +2802,9 @@ VkCommandBuffer FrameInterpolationSwapChainVK::getInterpolationCommandList()
         registeredInterpolationCommandLists[currentBackBufferIndex] = registeredCommands;
     }
 
+#ifdef _WIN32
     LeaveCriticalSection(&criticalSection);
+#endif
 
     return commandBuffer;
 }
@@ -2773,7 +2839,8 @@ VkResult FrameInterpolationSwapChainVK::submitCompositionOnGameQueue(const Pacin
         // if no frame was presented, we still need to update the semaphore
         if (toWait.count > 0)
         {
-            res = presentInfo.gameQueue.submit(VK_NULL_HANDLE, toWait, SubmissionSemaphores());
+            SubmissionSemaphores semaphores;
+            res = presentInfo.gameQueue.submit(VK_NULL_HANDLE, toWait, semaphores);
         }
     }
 
diff --git a/sdk/src/backends/vk/FrameInterpolationSwapchain/FrameInterpolationSwapchainVK.h b/sdk/src/backends/vk/FrameInterpolationSwapchain/FrameInterpolationSwapchainVK.h
index a6d305b..6e5712f 100644
--- a/sdk/src/backends/vk/FrameInterpolationSwapchain/FrameInterpolationSwapchainVK.h
+++ b/sdk/src/backends/vk/FrameInterpolationSwapchain/FrameInterpolationSwapchainVK.h
@@ -30,6 +30,7 @@
 
 #include <atomic>
 #include <cstdint>
+#include <cstring>
 
 #include "FrameInterpolationSwapchainVK_Helpers.h"
 
@@ -41,7 +42,7 @@
 //   - On Windows, critical section and events are faster than their std counterparts
 //   - using Win32 threads to set the priorities
 //   - this needs to be ported to standard C++ or other platform if necessary
-#include <Windows.h>
+// #include <Windows.h>
 
 #define FFX_FRAME_INTERPOLATION_SWAP_CHAIN_VERSION                     1
 #define FFX_FRAME_INTERPOLATION_SWAP_CHAIN_MAX_BUFFER_COUNT            6
@@ -111,7 +112,7 @@ typedef struct PacingData
     uint64_t replacementBufferSemaphoreSignal;
     uint64_t numFramesSentForPresentationBase;
     uint32_t numFramesToPresent;
-    UINT64   currentFrameID;
+    uint64_t currentFrameID;
 
     typedef enum FrameType
     {
@@ -195,12 +196,14 @@ struct FrameinterpolationPresentInfo
     uint64_t realPresentCount = 0;
 
     // using win32 threads to set the priorities
+#ifdef _WIN32
     HANDLE           presenterThreadHandle         = NULL;
     CRITICAL_SECTION scheduledFrameCriticalSection = {};
     HANDLE           presentEvent                  = NULL;
     HANDLE           interpolationEvent            = NULL;
     HANDLE           pacerEvent                    = NULL;
     CRITICAL_SECTION swapchainCriticalSection;
+#endif
 
     FGSwapchainCompositionMode compositionMode = FGSwapchainCompositionMode::eNone;
     volatile bool              resetTimer      = false;
@@ -333,17 +336,21 @@ private:
     bool presentInterpolatedOnly        = false;
     bool previousFrameWasInterpolated   = false;
 
-    UINT64        currentFrameID = 0;
+    uint64_t        currentFrameID = 0;
 
+#ifdef _WIN32
     LARGE_INTEGER lastTimestamp = {};
     LARGE_INTEGER currTimestamp = {};
     double        perfCountFreq = 0.0;
+#endif
 
     uint64_t framesSentForPresentation = 0;
 
+#ifdef _WIN32
     CRITICAL_SECTION criticalSection             = {};
     CRITICAL_SECTION criticalSectionUpdateConfig = {};
     HANDLE           interpolationThreadHandle   = NULL;
+#endif
 
     FfxPresentCallbackFunc         presentCallback                = nullptr;
     void*                          presentCallbackContext         = nullptr;
diff --git a/sdk/src/backends/vk/FrameInterpolationSwapchain/FrameInterpolationSwapchainVK_Helpers.cpp b/sdk/src/backends/vk/FrameInterpolationSwapchain/FrameInterpolationSwapchainVK_Helpers.cpp
index 326bb59..5f63e63 100644
--- a/sdk/src/backends/vk/FrameInterpolationSwapchain/FrameInterpolationSwapchainVK_Helpers.cpp
+++ b/sdk/src/backends/vk/FrameInterpolationSwapchain/FrameInterpolationSwapchainVK_Helpers.cpp
@@ -28,11 +28,13 @@
 
 void waitForPerformanceCount(const int64_t targetCount)
 {
+#ifdef _WIN32
     int64_t currentCount = 0;
     do
     {
         QueryPerformanceCounter(reinterpret_cast<LARGE_INTEGER*>(&currentCount));
     } while (currentCount < targetCount);
+#endif  // #ifdef _WIN32
 }
 
 VkResult VulkanQueue::submit(VkCommandBuffer commandBuffer, SubmissionSemaphores& semaphoresToWait, SubmissionSemaphores& semaphoresToSignal, VkFence fence)
diff --git a/sdk/src/backends/vk/FrameInterpolationSwapchain/FrameInterpolationSwapchainVK_Helpers.h b/sdk/src/backends/vk/FrameInterpolationSwapchain/FrameInterpolationSwapchainVK_Helpers.h
index 8775dcc..94172e0 100644
--- a/sdk/src/backends/vk/FrameInterpolationSwapchain/FrameInterpolationSwapchainVK_Helpers.h
+++ b/sdk/src/backends/vk/FrameInterpolationSwapchain/FrameInterpolationSwapchainVK_Helpers.h
@@ -27,8 +27,10 @@
 #include <FidelityFX/host/ffx_assert.h>
 #include <FidelityFX/host/backends/vk/ffx_vk.h>
 
-#include <Windows.h>
-#include <synchapi.h>
+#ifdef _WIN32
+# include <Windows.h>
+# include <synchapi.h>
+#endif
 
 
 void waitForPerformanceCount(const int64_t targetCount);
@@ -265,21 +267,29 @@ class VulkanCommandPool
 {
 public:
 private:
+
+#ifdef _WIN32
     CRITICAL_SECTION criticalSection                 = {};
+#endif
+
     uint32_t         queueFamilyIndices[NumFamilies] = {};
     VkCommands       buffer[NumFamilies][Capacity]   = {};
 
 public:
     VulkanCommandPool()
     {
+#ifdef _WIN32
         InitializeCriticalSection(&criticalSection);
+#endif
         for (size_t familyIndex = 0; familyIndex < NumFamilies; familyIndex++)
             queueFamilyIndices[familyIndex] = UINT32_MAX;
     }
 
     ~VulkanCommandPool()
     {
+#ifdef _WIN32
         EnterCriticalSection(&criticalSection);
+#endif
 
         for (size_t familyIndex = 0; familyIndex < NumFamilies; familyIndex++)
         {
@@ -296,14 +306,18 @@ public:
             queueFamilyIndices[familyIndex] = UINT32_MAX;
         }
 
+#ifdef _WIN32
         LeaveCriticalSection(&criticalSection);
 
         DeleteCriticalSection(&criticalSection);
+#endif
     }
 
     VkCommands* get(VkDevice device, VulkanQueue queue, const char* name)
     {
+#ifdef _WIN32
         EnterCriticalSection(&criticalSection);
+#endif
 
         uint32_t familyIndex = 0;
         // find family index
@@ -337,7 +351,9 @@ public:
 
         pCommands->occupy(queue, name);
 
+#ifdef _WIN32
         LeaveCriticalSection(&criticalSection);
+#endif
 
         return pCommands;
     }
diff --git a/sdk/src/backends/vk/FrameInterpolationSwapchain/FrameInterpolationSwapchainVK_UiComposition.cpp b/sdk/src/backends/vk/FrameInterpolationSwapchain/FrameInterpolationSwapchainVK_UiComposition.cpp
index 571ceb9..fa7504b 100644
--- a/sdk/src/backends/vk/FrameInterpolationSwapchain/FrameInterpolationSwapchainVK_UiComposition.cpp
+++ b/sdk/src/backends/vk/FrameInterpolationSwapchain/FrameInterpolationSwapchainVK_UiComposition.cpp
@@ -20,6 +20,8 @@
 // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 // THE SOFTWARE.
 
+#include <array>
+
 #include <vulkan/vulkan.h>
 #include "FrameInterpolationSwapchainVK_Helpers.h"
 #include "FrameInterpolationSwapchainVK_UiComposition.h"
@@ -64,7 +66,7 @@ VkResult CreateShaderModule(VkDevice device, size_t codeSize, const uint32_t* pC
 
 void releaseUiBlitGpuResources(const VkAllocationCallbacks* pAllocator)
 {
-    for (uint32_t i = 0; i < _countof(s_uiCompositionDescriptorSets); ++i)
+    for (uint32_t i = 0; i < std::size(s_uiCompositionDescriptorSets); ++i)
     {
         vkFreeDescriptorSets(s_uiCompositionDevice, s_uiCompositionDescriptorPool, 1, &s_uiCompositionDescriptorSets[i]);
         s_uiCompositionDescriptorSets[i] = VK_NULL_HANDLE;
@@ -87,12 +89,12 @@ void releaseUiBlitGpuResources(const VkAllocationCallbacks* pAllocator)
     vkDestroyRenderPass(s_uiCompositionDevice, s_uiCompositionRenderPass, pAllocator);
     s_uiCompositionRenderPass = nullptr;
 
-    for (uint32_t i = 0; i < _countof(s_uiCompositionImageViews); ++i)
+    for (uint32_t i = 0; i < std::size(s_uiCompositionImageViews); ++i)
     {
         vkDestroyImageView(s_uiCompositionDevice, s_uiCompositionImageViews[i], pAllocator);
         s_uiCompositionImageViews[i] = VK_NULL_HANDLE;
     }
-    for (uint32_t i = 0; i < _countof(s_uiCompositionFramebuffers); ++i)
+    for (uint32_t i = 0; i < std::size(s_uiCompositionFramebuffers); ++i)
     {
         vkDestroyFramebuffer(s_uiCompositionDevice, s_uiCompositionFramebuffers[i], pAllocator);
         s_uiCompositionFramebuffers[i] = VK_NULL_HANDLE;
@@ -304,7 +306,7 @@ VkResult CreateUiCompositionPipeline(VkDevice device, VkFormat fmt, const VkAllo
         dynamicStateCreateInfo.sType                            = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
         dynamicStateCreateInfo.pNext                            = nullptr;
         dynamicStateCreateInfo.flags                            = 0;
-        dynamicStateCreateInfo.dynamicStateCount                = _countof(dynamicStates);
+        dynamicStateCreateInfo.dynamicStateCount                = std::size(dynamicStates);
         dynamicStateCreateInfo.pDynamicStates                   = dynamicStates;
 
         // dynamic so put dummy values
@@ -344,7 +346,7 @@ VkResult CreateUiCompositionPipeline(VkDevice device, VkFormat fmt, const VkAllo
         info.sType                        = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
         info.pNext                        = nullptr;
         info.flags                        = 0;
-        info.stageCount                   = _countof(shaderStageCreateInfos);
+        info.stageCount                   = std::size(shaderStageCreateInfos);
         info.pStages                      = shaderStageCreateInfos;
         info.pVertexInputState            = &vertexInputStateCreateInfo;
         info.pInputAssemblyState          = &inputAssemblyStateCreateInfo;
@@ -467,7 +469,7 @@ FfxErrorCodes verifyUiBlitGpuResources(VkDevice device, VkFormat fmt, const VkAl
         info.descriptorPool     = s_uiCompositionDescriptorPool;
         info.descriptorSetCount = 1;
         info.pSetLayouts = &s_uiCompositionDescriptorSetLayout;
-        for (uint32_t i = 0; i < _countof(s_uiCompositionDescriptorSets); ++i)
+        for (uint32_t i = 0; i < std::size(s_uiCompositionDescriptorSets); ++i)
         {
             if (res == VK_SUCCESS && s_uiCompositionDescriptorSets[i] == VK_NULL_HANDLE)
             {
diff --git a/sdk/src/backends/vk/ffx_vk.cpp b/sdk/src/backends/vk/ffx_vk.cpp
index ef187c3..8aa96a6 100644
--- a/sdk/src/backends/vk/ffx_vk.cpp
+++ b/sdk/src/backends/vk/ffx_vk.cpp
@@ -20,6 +20,8 @@
 // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 // THE SOFTWARE.
 
+#include <cmath>
+
 #include <FidelityFX/host/ffx_interface.h>
 #include <FidelityFX/host/ffx_util.h>
 #include <FidelityFX/host/ffx_assert.h>
@@ -118,61 +120,68 @@ typedef struct BackendContext_VK {
 
     typedef struct VKFunctionTable
     {
-        PFN_vkGetDeviceProcAddr                 vkGetDeviceProcAddr = 0;
-        PFN_vkSetDebugUtilsObjectNameEXT        vkSetDebugUtilsObjectNameEXT = 0;
-        PFN_vkCreateDescriptorPool              vkCreateDescriptorPool = 0;
-        PFN_vkCreateSampler                     vkCreateSampler = 0;
-        PFN_vkCreateDescriptorSetLayout         vkCreateDescriptorSetLayout = 0;
-        PFN_vkCreateBuffer                      vkCreateBuffer = 0;
-        PFN_vkCreateBufferView                  vkCreateBufferView = 0;
-        PFN_vkCreateImage                       vkCreateImage = 0;
-        PFN_vkCreateImageView                   vkCreateImageView = 0;
-        PFN_vkCreateShaderModule                vkCreateShaderModule = 0;
-        PFN_vkCreatePipelineLayout              vkCreatePipelineLayout = 0;
-        PFN_vkCreateComputePipelines            vkCreateComputePipelines = 0;
-        PFN_vkDestroyPipelineLayout             vkDestroyPipelineLayout = 0;
-        PFN_vkDestroyPipeline                   vkDestroyPipeline = 0;
-        PFN_vkDestroyImage                      vkDestroyImage = 0;
-        PFN_vkDestroyImageView                  vkDestroyImageView = 0;
-        PFN_vkDestroyBuffer                     vkDestroyBuffer = 0;
-        PFN_vkDestroyBufferView                 vkDestroyBufferView = 0;
-        PFN_vkDestroyDescriptorSetLayout        vkDestroyDescriptorSetLayout = 0;
-        PFN_vkDestroyDescriptorPool             vkDestroyDescriptorPool = 0;
-        PFN_vkDestroySampler                    vkDestroySampler = 0;
-        PFN_vkDestroyShaderModule               vkDestroyShaderModule = 0;
-        PFN_vkGetBufferMemoryRequirements       vkGetBufferMemoryRequirements = 0;
-        PFN_vkGetBufferMemoryRequirements2KHR   vkGetBufferMemoryRequirements2KHR = 0;
-        PFN_vkGetImageMemoryRequirements        vkGetImageMemoryRequirements = 0;
-        PFN_vkAllocateDescriptorSets            vkAllocateDescriptorSets = 0;
-        PFN_vkFreeDescriptorSets                vkFreeDescriptorSets = 0;
-        PFN_vkAllocateMemory                    vkAllocateMemory = 0;
-        PFN_vkFreeMemory                        vkFreeMemory = 0;
-        PFN_vkMapMemory                         vkMapMemory = 0;
-        PFN_vkUnmapMemory                       vkUnmapMemory = 0;
-        PFN_vkBindBufferMemory                  vkBindBufferMemory = 0;
-        PFN_vkBindImageMemory                   vkBindImageMemory = 0;
-        PFN_vkUpdateDescriptorSets              vkUpdateDescriptorSets = 0;
-        PFN_vkFlushMappedMemoryRanges           vkFlushMappedMemoryRanges = 0;
-        PFN_vkCmdPipelineBarrier                vkCmdPipelineBarrier = 0;
-        PFN_vkCmdBindPipeline                   vkCmdBindPipeline = 0;
-        PFN_vkCmdBindDescriptorSets             vkCmdBindDescriptorSets = 0;
-        PFN_vkCmdDispatch                       vkCmdDispatch = 0;
-        PFN_vkCmdDispatchIndirect               vkCmdDispatchIndirect = 0;
-        PFN_vkCmdCopyBuffer                     vkCmdCopyBuffer = 0;
-        PFN_vkCmdCopyImage                      vkCmdCopyImage = 0;
-        PFN_vkCmdCopyBufferToImage              vkCmdCopyBufferToImage = 0;
-        PFN_vkCmdClearColorImage                vkCmdClearColorImage = 0;
-        PFN_vkCmdFillBuffer                     vkCmdFillBuffer = 0;
-        PFN_vkCmdWriteBufferMarkerAMD           vkCmdWriteBufferMarkerAMD = 0;
-        PFN_vkCmdWriteBufferMarker2AMD          vkCmdWriteBufferMarker2AMD = 0;
-        PFN_vkCmdBeginDebugUtilsLabelEXT        vkCmdBeginDebugUtilsLabelEXT = 0;
-        PFN_vkCmdEndDebugUtilsLabelEXT          vkCmdEndDebugUtilsLabelEXT = 0;
+        PFN_vkGetDeviceProcAddr                  vkGetDeviceProcAddr = 0;
+        PFN_vkSetDebugUtilsObjectNameEXT         vkSetDebugUtilsObjectNameEXT = 0;
+        PFN_vkCreateDescriptorPool               vkCreateDescriptorPool = 0;
+        PFN_vkCreateSampler                      vkCreateSampler = 0;
+        PFN_vkCreateDescriptorSetLayout          vkCreateDescriptorSetLayout = 0;
+        PFN_vkCreateBuffer                       vkCreateBuffer = 0;
+        PFN_vkCreateBufferView                   vkCreateBufferView = 0;
+        PFN_vkCreateImage                        vkCreateImage = 0;
+        PFN_vkCreateImageView                    vkCreateImageView = 0;
+        PFN_vkCreateShaderModule                 vkCreateShaderModule = 0;
+        PFN_vkCreatePipelineLayout               vkCreatePipelineLayout = 0;
+        PFN_vkCreateComputePipelines             vkCreateComputePipelines = 0;
+        PFN_vkDestroyPipelineLayout              vkDestroyPipelineLayout = 0;
+        PFN_vkDestroyPipeline                    vkDestroyPipeline = 0;
+        PFN_vkDestroyImage                       vkDestroyImage = 0;
+        PFN_vkDestroyImageView                   vkDestroyImageView = 0;
+        PFN_vkDestroyBuffer                      vkDestroyBuffer = 0;
+        PFN_vkDestroyBufferView                  vkDestroyBufferView = 0;
+        PFN_vkDestroyDescriptorSetLayout         vkDestroyDescriptorSetLayout = 0;
+        PFN_vkDestroyDescriptorPool              vkDestroyDescriptorPool = 0;
+        PFN_vkDestroySampler                     vkDestroySampler = 0;
+        PFN_vkDestroyShaderModule                vkDestroyShaderModule = 0;
+        PFN_vkGetBufferMemoryRequirements        vkGetBufferMemoryRequirements = 0;
+        PFN_vkGetBufferMemoryRequirements2KHR    vkGetBufferMemoryRequirements2KHR = 0;
+        PFN_vkGetImageMemoryRequirements         vkGetImageMemoryRequirements = 0;
+        PFN_vkAllocateDescriptorSets             vkAllocateDescriptorSets = 0;
+        PFN_vkFreeDescriptorSets                 vkFreeDescriptorSets = 0;
+        PFN_vkAllocateMemory                     vkAllocateMemory = 0;
+        PFN_vkFreeMemory                         vkFreeMemory = 0;
+        PFN_vkMapMemory                          vkMapMemory = 0;
+        PFN_vkUnmapMemory                        vkUnmapMemory = 0;
+        PFN_vkBindBufferMemory                   vkBindBufferMemory = 0;
+        PFN_vkBindImageMemory                    vkBindImageMemory = 0;
+        PFN_vkUpdateDescriptorSets               vkUpdateDescriptorSets = 0;
+        PFN_vkFlushMappedMemoryRanges            vkFlushMappedMemoryRanges = 0;
+        PFN_vkCmdPipelineBarrier                 vkCmdPipelineBarrier = 0;
+        PFN_vkCmdBindPipeline                    vkCmdBindPipeline = 0;
+        PFN_vkCmdBindDescriptorSets              vkCmdBindDescriptorSets = 0;
+        PFN_vkCmdDispatch                        vkCmdDispatch = 0;
+        PFN_vkCmdDispatchIndirect                vkCmdDispatchIndirect = 0;
+        PFN_vkCmdCopyBuffer                      vkCmdCopyBuffer = 0;
+        PFN_vkCmdCopyImage                       vkCmdCopyImage = 0;
+        PFN_vkCmdCopyBufferToImage               vkCmdCopyBufferToImage = 0;
+        PFN_vkCmdClearColorImage                 vkCmdClearColorImage = 0;
+        PFN_vkCmdFillBuffer                      vkCmdFillBuffer = 0;
+        PFN_vkCmdWriteBufferMarkerAMD            vkCmdWriteBufferMarkerAMD = 0;
+        PFN_vkCmdWriteBufferMarker2AMD           vkCmdWriteBufferMarker2AMD = 0;
+        PFN_vkCmdBeginDebugUtilsLabelEXT         vkCmdBeginDebugUtilsLabelEXT = 0;
+        PFN_vkCmdEndDebugUtilsLabelEXT           vkCmdEndDebugUtilsLabelEXT = 0;
+        PFN_vkEnumerateDeviceExtensionProperties vkEnumerateDeviceExtensionProperties = 0;
+        PFN_vkGetPhysicalDeviceMemoryProperties  vkGetPhysicalDeviceMemoryProperties = 0;
+        PFN_vkGetPhysicalDeviceProperties        vkGetPhysicalDeviceProperties = 0;
+        PFN_vkGetPhysicalDeviceProperties2       vkGetPhysicalDeviceProperties2 = 0;
+        PFN_vkGetPhysicalDeviceFeatures          vkGetPhysicalDeviceFeatures = 0;
+        PFN_vkGetPhysicalDeviceFeatures2         vkGetPhysicalDeviceFeatures2 = 0;
 
     } VkFunctionTable;
 
     uint32_t refCount;
     uint32_t maxEffectContexts;
 
+    VkInstance              instance = VK_NULL_HANDLE;
     VkDevice                device = VK_NULL_HANDLE;
     VkPhysicalDevice        physicalDevice = VK_NULL_HANDLE;
     VkFunctionTable         vkFunctionTable = {};
@@ -272,13 +281,16 @@ typedef struct BackendContext_VK {
 
 } BackendContext_VK;
 
-FFX_API size_t ffxGetScratchMemorySizeVK(VkPhysicalDevice physicalDevice, size_t maxContexts)
+FFX_API size_t ffxGetScratchMemorySizeVK(FfxDevice device, size_t maxContexts)
 {
-    uint32_t numExtensions = 0;
-
-    if (physicalDevice)
-        vkEnumerateDeviceExtensionProperties(physicalDevice, nullptr, &numExtensions, nullptr);
+    auto context = ((VkDeviceContext*)device);
 
+    uint32_t numExtensions = 0;
+    if (context->vkPhysicalDevice)
+    {
+        auto props = (PFN_vkEnumerateDeviceExtensionProperties)context->vkInstanceProcAddr(context->vkInstance, "vkEnumerateDeviceExtensionProperties");
+        props(context->vkPhysicalDevice, nullptr, &numExtensions, nullptr);
+    }
     uint32_t extensionPropArraySize = sizeof(VkExtensionProperties) * numExtensions;
     uint32_t gpuJobDescArraySize = FFX_ALIGN_UP(maxContexts * FFX_MAX_GPU_JOBS * sizeof(FfxGpuJobDescription), sizeof(uint32_t));
     uint32_t resourceViewArraySize = FFX_ALIGN_UP(((maxContexts * FFX_MAX_QUEUED_FRAMES * FFX_MAX_RESOURCE_COUNT * 2) + FFX_MAX_BINDLESS_DESCRIPTOR_COUNT) * sizeof(BackendContext_VK::VkResourceView), sizeof(uint32_t));
@@ -313,7 +325,7 @@ FfxErrorCode ffxGetInterfaceVK(
         scratchBuffer,
         FFX_ERROR_INVALID_POINTER);
     FFX_RETURN_ON_ERROR(
-        scratchBufferSize >= ffxGetScratchMemorySizeVK(((VkDeviceContext*)device)->vkPhysicalDevice, maxContexts),
+        scratchBufferSize >= ffxGetScratchMemorySizeVK(device, maxContexts),
         FFX_ERROR_INSUFFICIENT_MEMORY);
 
     backendInterface->fpGetSDKVersion = GetSDKVersionVK;
@@ -341,7 +353,7 @@ FfxErrorCode ffxGetInterfaceVK(
     backendInterface->fpBreadcrumbsWrite = BreadcrumbsWriteVK;
     backendInterface->fpBreadcrumbsPrintDeviceInfo = BreadcrumbsPrintDeviceInfoVK;
     backendInterface->fpRegisterConstantBufferAllocator = RegisterConstantBufferAllocatorVK;
-    backendInterface->fpSwapChainConfigureFrameGeneration = ffxSetFrameGenerationConfigToSwapchainVK;
+    // backendInterface->fpSwapChainConfigureFrameGeneration = ffxSetFrameGenerationConfigToSwapchainVK;
 
     // Memory assignments
     backendInterface->scratchBuffer = scratchBuffer;
@@ -377,7 +389,7 @@ FfxPipeline ffxGetPipelineVK(VkPipeline pipeline)
 
 FfxResource ffxGetResourceVK(void* vkResource,
     FfxResourceDescription          ffxResDescription,
-    const wchar_t* ffxResName,
+    const char*                     ffxResName,
     FfxResourceStates               state /*=FFX_RESOURCE_STATE_COMPUTE_READ*/)
 {
     FfxResource resource = {};
@@ -387,19 +399,19 @@ FfxResource ffxGetResourceVK(void* vkResource,
 
 #ifdef _DEBUG
     if (ffxResName) {
-        wcscpy_s(resource.name, ffxResName);
+        strcpy(resource.name, ffxResName);
     }
 #endif
 
     return resource;
 }
 
-uint32_t findMemoryTypeIndex(VkPhysicalDevice physicalDevice, VkMemoryRequirements memRequirements, VkMemoryPropertyFlags requestedProperties, VkMemoryPropertyFlags& outProperties)
+uint32_t findMemoryTypeIndex(BackendContext_VK* backendContext, VkMemoryRequirements memRequirements, VkMemoryPropertyFlags requestedProperties, VkMemoryPropertyFlags& outProperties)
 {
-    FFX_ASSERT(NULL != physicalDevice);
+    FFX_ASSERT(NULL != backendContext->physicalDevice);
 
     VkPhysicalDeviceMemoryProperties memProperties;
-    vkGetPhysicalDeviceMemoryProperties(physicalDevice, &memProperties);
+    backendContext->vkFunctionTable.vkGetPhysicalDeviceMemoryProperties(backendContext->physicalDevice, &memProperties);
 
     uint32_t bestCandidate = UINT32_MAX;
 
@@ -923,7 +935,7 @@ FfxErrorCode allocateDeviceMemory(BackendContext_VK* backendContext, VkMemoryReq
     VkMemoryAllocateInfo allocInfo{};
     allocInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
     allocInfo.allocationSize = memRequirements.size;
-    allocInfo.memoryTypeIndex = findMemoryTypeIndex(backendContext->physicalDevice, memRequirements, requiredMemoryProperties, backendResource->memoryProperties);
+    allocInfo.memoryTypeIndex = findMemoryTypeIndex(backendContext, memRequirements, requiredMemoryProperties, backendResource->memoryProperties);
 
     if (allocInfo.memoryTypeIndex == UINT32_MAX) {
         return FFX_ERROR_BACKEND_API_ERROR;
@@ -944,7 +956,7 @@ FfxErrorCode allocateDeviceMemory(BackendContext_VK* backendContext, VkMemoryReq
     return FFX_OK;
 }
 
-void setVKObjectName(BackendContext_VK::VKFunctionTable& vkFunctionTable, VkDevice device, VkObjectType objectType, uint64_t object, char* name)
+void setVKObjectName(BackendContext_VK::VKFunctionTable& vkFunctionTable, VkDevice device, VkObjectType objectType, uint64_t object, const char* name)
 {
     VkDebugUtilsObjectNameInfoEXT s{ VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT, nullptr, objectType, object, name };
 
@@ -1002,6 +1014,8 @@ VkAccessFlags getVKAccessFlagsFromResourceState(FfxResourceStates state)
         return VK_ACCESS_NONE;
     case FFX_RESOURCE_STATE_RENDER_TARGET:
         return VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT | VK_ACCESS_COLOR_ATTACHMENT_READ_BIT;
+    case FFX_RESOURCE_STATE_DEPTH_STENCIL_READ_ONLY:
+        return VK_ACCESS_SHADER_READ_BIT;
     default:
         FFX_ASSERT_MESSAGE(false, "State flag not yet supported");
         return VK_ACCESS_SHADER_READ_BIT;
@@ -1028,6 +1042,8 @@ VkPipelineStageFlags getVKPipelineStageFlagsFromResourceState(FfxResourceStates
         return VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT;
     case FFX_RESOURCE_STATE_RENDER_TARGET:
         return VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;
+    case FFX_RESOURCE_STATE_DEPTH_STENCIL_READ_ONLY:
+        return VK_PIPELINE_STAGE_VERTEX_SHADER_BIT | VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT | VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT;
     default:
         FFX_ASSERT_MESSAGE(false, "Pipeline stage flag not yet supported");
         return VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT;
@@ -1056,6 +1072,8 @@ VkImageLayout getVKImageLayoutFromResourceState(FfxResourceStates state)
         return VK_IMAGE_LAYOUT_PRESENT_SRC_KHR;
     case FFX_RESOURCE_STATE_RENDER_TARGET:
         return VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL;
+    case FFX_RESOURCE_STATE_DEPTH_STENCIL_READ_ONLY:
+        return VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL;
     case FFX_RESOURCE_STATE_INDIRECT_ARGUMENT:
         // this case is for buffers
     default:
@@ -1095,58 +1113,34 @@ void copyResourceState(BackendContext_VK::Resource* backendResource, const FfxRe
     }
 }
 
-#ifdef _WIN32
-void ConvertUTF8ToUTF16(const char* inputName, wchar_t* outputBuffer, size_t outputLen)
+void beginMarkerVK(BackendContext_VK* backendContext, VkCommandBuffer commandBuffer, const char* label)
 {
-    if (MultiByteToWideChar(CP_UTF8, 0, inputName, -1, outputBuffer, static_cast<int>(outputLen)) == 0)
+#ifndef NDEBUG
+    if (backendContext->vkFunctionTable.vkCmdBeginDebugUtilsLabelEXT)
     {
-        memset(outputBuffer, 0, outputLen * sizeof(wchar_t));
+        VkDebugUtilsLabelEXT debugLabel = {};
+        debugLabel.sType                = VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT;
+        debugLabel.pNext                = nullptr;
+        debugLabel.pLabelName           = label;
+
+        // not to saturated red
+        debugLabel.color[0] = 1.0f;
+        debugLabel.color[1] = 0.14f;
+        debugLabel.color[2] = 0.14f;
+        debugLabel.color[3] = 1.0f;
+        backendContext->vkFunctionTable.vkCmdBeginDebugUtilsLabelEXT(commandBuffer, &debugLabel);
     }
-}
-void ConvertUTF16ToUTF8(const wchar_t* inputName, char* outputBuffer, size_t outputLen)
-{
-    if (WideCharToMultiByte(CP_UTF8, 0, inputName, -1, outputBuffer, static_cast<int>(outputLen * sizeof(char)), NULL, NULL) == 0)
-    {
-        memset(outputBuffer, 0, outputLen * sizeof(char));
-    }
-}
-#else
-void ConvertUTF8ToUTF16(const char* inputName, wchar_t* outputBuffer, size_t outputLen)
-{
-    memset(outputBuffer, 0, outputLen * sizeof(wchar_t));
-    std::wstring_convert<std::codecvt_utf8<wchar_t>, wchar_t> converter;
-    wcscpy_s(outputBuffer, outputLen, converter.from_bytes(inputName).c_str());
-}
-void ConvertUTF16ToUTF8(const wchar_t* inputName, char* outputBuffer, size_t outputLen)
-{
-    memset(outputBuffer, 0, outputLen * sizeof(char));
-    std::wstring_convert<std::codecvt_utf8<wchar_t>, wchar_t> converter;
-    strcpy_s(outputBuffer, outputLen, converter.to_bytes(inputName).c_str());
-}
-#endif  // _WIN32
-
-void beginMarkerVK(BackendContext_VK* backendContext, VkCommandBuffer commandBuffer, const wchar_t* label)
-{
-    constexpr size_t strLen = 64;
-    char strLabel[strLen];
-    ConvertUTF16ToUTF8(label, strLabel, strLen);
-
-    VkDebugUtilsLabelEXT debugLabel = {};
-    debugLabel.sType                = VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT;
-    debugLabel.pNext                = nullptr;
-    debugLabel.pLabelName           = strLabel;
-
-    // not to saturated red
-    debugLabel.color[0] = 1.0f;
-    debugLabel.color[1] = 0.14f;
-    debugLabel.color[2] = 0.14f;
-    debugLabel.color[3] = 1.0f;
-    backendContext->vkFunctionTable.vkCmdBeginDebugUtilsLabelEXT(commandBuffer, &debugLabel);
+#endif
 }
 
 void endMarkerVK(BackendContext_VK* backendContext, VkCommandBuffer commandBuffer)
 {
-    backendContext->vkFunctionTable.vkCmdEndDebugUtilsLabelEXT(commandBuffer);
+#ifndef NDEBUG
+    if (backendContext->vkFunctionTable.vkCmdBeginDebugUtilsLabelEXT)
+    {
+        backendContext->vkFunctionTable.vkCmdEndDebugUtilsLabelEXT(commandBuffer);
+    }
+#endif
 }
 
 void addBarrier(BackendContext_VK* backendContext, FfxResourceInternal* resource, FfxResourceStates newState)
@@ -1243,7 +1237,7 @@ FfxConstantAllocation BackendContext_VK::FallbackConstantAllocator(void* data, F
 
         // get alignment
         VkPhysicalDeviceProperties physicalDeviceProperties = {};
-        vkGetPhysicalDeviceProperties(physicalDevice, &physicalDeviceProperties);
+        vkFunctionTable.vkGetPhysicalDeviceProperties(physicalDevice, &physicalDeviceProperties);
         uniformBufferAlignment = physicalDeviceProperties.limits.minUniformBufferOffsetAlignment;
 
         uniformBufferSize = FFX_ALIGN_UP(FFX_BUFFER_SIZE, uniformBufferAlignment) * maxEffectContexts * FFX_MAX_PASS_COUNT * FFX_MAX_QUEUED_FRAMES;
@@ -1271,12 +1265,12 @@ FfxConstantAllocation BackendContext_VK::FallbackConstantAllocator(void* data, F
 
             allocInfo.sType           = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
             allocInfo.allocationSize  = uniformBufferSize;
-            allocInfo.memoryTypeIndex = findMemoryTypeIndex(physicalDevice, memRequirements, requiredMemoryProperties, uniformBufferMemoryProperties);
+            allocInfo.memoryTypeIndex = findMemoryTypeIndex(this, memRequirements, requiredMemoryProperties, uniformBufferMemoryProperties);
 
             if (allocInfo.memoryTypeIndex == UINT32_MAX)
             {
                 requiredMemoryProperties  = VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT;
-                allocInfo.memoryTypeIndex = findMemoryTypeIndex(physicalDevice, memRequirements, requiredMemoryProperties, uniformBufferMemoryProperties);
+                allocInfo.memoryTypeIndex = findMemoryTypeIndex(this, memRequirements, requiredMemoryProperties, uniformBufferMemoryProperties);
 
                 if (allocInfo.memoryTypeIndex == UINT32_MAX)
                     res = VK_ERROR_INITIALIZATION_FAILED;
@@ -1435,8 +1429,12 @@ FfxErrorCode CreateBackendContextVK(FfxInterface* backendInterface, FfxEffect ef
         backendContext->extensionProperties = (VkExtensionProperties*)pMem;
 
         // if vkGetDeviceProcAddr is NULL, use the one from the vulkan header
-        if (vkDeviceContext->vkDeviceProcAddr == NULL)
-            vkDeviceContext->vkDeviceProcAddr = vkGetDeviceProcAddr;
+        // if (vkDeviceContext->vkDeviceProcAddr == NULL)
+        //     vkDeviceContext->vkDeviceProcAddr = vkGetDeviceProcAddr;
+
+        if (vkDeviceContext->vkInstance != VK_NULL_HANDLE) {
+            backendContext->instance = vkDeviceContext->vkInstance;
+        }
 
         if (vkDeviceContext->vkDevice != VK_NULL_HANDLE) {
             backendContext->device = vkDeviceContext->vkDevice;
@@ -1495,11 +1493,17 @@ FfxErrorCode CreateBackendContextVK(FfxInterface* backendInterface, FfxEffect ef
         backendContext->vkFunctionTable.vkCmdWriteBufferMarker2AMD = (PFN_vkCmdWriteBufferMarker2AMD)vkDeviceContext->vkDeviceProcAddr(backendContext->device, "vkCmdWriteBufferMarker2AMD");
         backendContext->vkFunctionTable.vkCmdBeginDebugUtilsLabelEXT = (PFN_vkCmdBeginDebugUtilsLabelEXT)vkDeviceContext->vkDeviceProcAddr(backendContext->device, "vkCmdBeginDebugUtilsLabelEXT");
         backendContext->vkFunctionTable.vkCmdEndDebugUtilsLabelEXT = (PFN_vkCmdEndDebugUtilsLabelEXT)vkDeviceContext->vkDeviceProcAddr(backendContext->device, "vkCmdEndDebugUtilsLabelEXT");
+        backendContext->vkFunctionTable.vkEnumerateDeviceExtensionProperties = (PFN_vkEnumerateDeviceExtensionProperties)vkDeviceContext->vkInstanceProcAddr(backendContext->instance, "vkEnumerateDeviceExtensionProperties");
+        backendContext->vkFunctionTable.vkGetPhysicalDeviceMemoryProperties = (PFN_vkGetPhysicalDeviceMemoryProperties)vkDeviceContext->vkInstanceProcAddr(backendContext->instance, "vkGetPhysicalDeviceMemoryProperties");
+        backendContext->vkFunctionTable.vkGetPhysicalDeviceProperties = (PFN_vkGetPhysicalDeviceProperties)vkDeviceContext->vkInstanceProcAddr(backendContext->instance, "vkGetPhysicalDeviceProperties");
+        backendContext->vkFunctionTable.vkGetPhysicalDeviceProperties2 = (PFN_vkGetPhysicalDeviceProperties2)vkDeviceContext->vkInstanceProcAddr(backendContext->instance, "vkGetPhysicalDeviceProperties2");
+        backendContext->vkFunctionTable.vkGetPhysicalDeviceFeatures = (PFN_vkGetPhysicalDeviceFeatures)vkDeviceContext->vkInstanceProcAddr(backendContext->instance, "vkGetPhysicalDeviceFeatures");
+        backendContext->vkFunctionTable.vkGetPhysicalDeviceFeatures2 = (PFN_vkGetPhysicalDeviceFeatures2)vkDeviceContext->vkInstanceProcAddr(backendContext->instance, "vkGetPhysicalDeviceFeatures2");
 
         // enumerate all the device extensions
         backendContext->numDeviceExtensions = 0;
-        vkEnumerateDeviceExtensionProperties(backendContext->physicalDevice, nullptr, &backendContext->numDeviceExtensions, nullptr);
-        vkEnumerateDeviceExtensionProperties(backendContext->physicalDevice, nullptr, &backendContext->numDeviceExtensions, backendContext->extensionProperties);
+        backendContext->vkFunctionTable.vkEnumerateDeviceExtensionProperties(backendContext->physicalDevice, nullptr, &backendContext->numDeviceExtensions, nullptr);
+        backendContext->vkFunctionTable.vkEnumerateDeviceExtensionProperties(backendContext->physicalDevice, nullptr, &backendContext->numDeviceExtensions, backendContext->extensionProperties);
 
         // create a global descriptor pool to hold all descriptors we'll need
         VkDescriptorPoolCreateInfo descriptorPoolCreateInfo = {};
@@ -1530,7 +1534,7 @@ FfxErrorCode CreateBackendContextVK(FfxInterface* backendInterface, FfxEffect ef
         {
             // get alignment
             VkPhysicalDeviceProperties physicalDeviceProperties = {};
-            vkGetPhysicalDeviceProperties(backendContext->physicalDevice, &physicalDeviceProperties);
+            backendContext->vkFunctionTable.vkGetPhysicalDeviceProperties(backendContext->physicalDevice, &physicalDeviceProperties);
             backendContext->uniformBufferAlignment = physicalDeviceProperties.limits.minUniformBufferOffsetAlignment;
 
             backendContext->uniformBufferSize =
@@ -1560,13 +1564,13 @@ FfxErrorCode CreateBackendContextVK(FfxInterface* backendInterface, FfxEffect ef
             allocInfo.sType          = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
             allocInfo.allocationSize = backendContext->uniformBufferSize;
             allocInfo.memoryTypeIndex =
-                findMemoryTypeIndex(backendContext->physicalDevice, memRequirements, requiredMemoryProperties, backendContext->uniformBufferMemoryProperties);
+                findMemoryTypeIndex(backendContext, memRequirements, requiredMemoryProperties, backendContext->uniformBufferMemoryProperties);
 
             if (allocInfo.memoryTypeIndex == UINT32_MAX)
             {
                 requiredMemoryProperties = VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT;
                 allocInfo.memoryTypeIndex = findMemoryTypeIndex(
-                    backendContext->physicalDevice, memRequirements, requiredMemoryProperties, backendContext->uniformBufferMemoryProperties);
+                    backendContext, memRequirements, requiredMemoryProperties, backendContext->uniformBufferMemoryProperties);
 
                 if (allocInfo.memoryTypeIndex == UINT32_MAX)
                 {
@@ -1621,7 +1625,7 @@ FfxErrorCode CreateBackendContextVK(FfxInterface* backendInterface, FfxEffect ef
             bufferInfo.pQueueFamilyIndices = nullptr;
 
             VkBuffer testBuffer = VK_NULL_HANDLE;
-            if (vkCreateBuffer(backendContext->device, &bufferInfo, nullptr, &testBuffer) != VK_SUCCESS)
+            if (backendContext->vkFunctionTable.vkCreateBuffer(backendContext->device, &bufferInfo, nullptr, &testBuffer) != VK_SUCCESS)
             {
                 FFX_ASSERT_FAIL("Cannot create test Breadcrumbs buffer to find memory requirements!");
                 return FFX_ERROR_BACKEND_API_ERROR;
@@ -1661,7 +1665,7 @@ FfxErrorCode CreateBackendContextVK(FfxInterface* backendInterface, FfxEffect ef
 
             // Find proper memory index for created buffers
             VkPhysicalDeviceMemoryProperties memoryProps = {};
-            vkGetPhysicalDeviceMemoryProperties(backendContext->physicalDevice, &memoryProps);
+            backendContext->vkFunctionTable.vkGetPhysicalDeviceMemoryProperties(backendContext->physicalDevice, &memoryProps);
 
             const VkMemoryPropertyFlags requiredMemoryFlags = VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT;
             VkMemoryPropertyFlags preferredFlags = VK_MEMORY_PROPERTY_HOST_CACHED_BIT;
@@ -1778,7 +1782,7 @@ FfxErrorCode CreateBackendContextVK(FfxInterface* backendInterface, FfxEffect ef
 
                 descriptorPoolCreateInfo.sType         = VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO;
                 descriptorPoolCreateInfo.pNext         = nullptr;
-                descriptorPoolCreateInfo.flags         = 0;
+                descriptorPoolCreateInfo.flags         = VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT;
                 descriptorPoolCreateInfo.poolSizeCount = poolSizeCount;
                 descriptorPoolCreateInfo.pPoolSizes    = poolSizes;
                 descriptorPoolCreateInfo.maxSets       = poolSizeCount;
@@ -1986,7 +1990,7 @@ FfxErrorCode GetDeviceCapabilitiesVK(FfxInterface* backendInterface, FfxDeviceCa
             VkPhysicalDeviceProperties2 deviceProperties2 = {};
             deviceProperties2.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2;
             deviceProperties2.pNext = &subgroupSizeControlProperties;
-            vkGetPhysicalDeviceProperties2(context->physicalDevice, &deviceProperties2);
+            backendContext->vkFunctionTable.vkGetPhysicalDeviceProperties2(context->physicalDevice, &deviceProperties2);
 
             deviceCapabilities->waveLaneCountMin = subgroupSizeControlProperties.minSubgroupSize;
             deviceCapabilities->waveLaneCountMax = subgroupSizeControlProperties.maxSubgroupSize;
@@ -2001,7 +2005,7 @@ FfxErrorCode GetDeviceCapabilitiesVK(FfxInterface* backendInterface, FfxDeviceCa
             physicalDeviceFeatures2.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
             physicalDeviceFeatures2.pNext = &shaderFloat18Int8Features;
 
-            vkGetPhysicalDeviceFeatures2(context->physicalDevice, &physicalDeviceFeatures2);
+            context->vkFunctionTable.vkGetPhysicalDeviceFeatures2(context->physicalDevice, &physicalDeviceFeatures2);
 
             deviceCapabilities->fp16Supported = (bool)shaderFloat18Int8Features.shaderFloat16;
         }
@@ -2015,7 +2019,7 @@ FfxErrorCode GetDeviceCapabilitiesVK(FfxInterface* backendInterface, FfxDeviceCa
             physicalDeviceFeatures2.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
             physicalDeviceFeatures2.pNext = &accelerationStructureFeatures;
 
-            vkGetPhysicalDeviceFeatures2(context->physicalDevice, &physicalDeviceFeatures2);
+            context->vkFunctionTable.vkGetPhysicalDeviceFeatures2(context->physicalDevice, &physicalDeviceFeatures2);
 
             deviceCapabilities->raytracingSupported = (bool)accelerationStructureFeatures.accelerationStructure;
         }
@@ -2029,7 +2033,7 @@ FfxErrorCode GetDeviceCapabilitiesVK(FfxInterface* backendInterface, FfxDeviceCa
             physicalDeviceFeatures2.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
             physicalDeviceFeatures2.pNext = &coherentMemoryFeatures;
 
-            vkGetPhysicalDeviceFeatures2(context->physicalDevice, &physicalDeviceFeatures2);
+            context->vkFunctionTable.vkGetPhysicalDeviceFeatures2(context->physicalDevice, &physicalDeviceFeatures2);
 
             deviceCapabilities->deviceCoherentMemorySupported = (bool)coherentMemoryFeatures.deviceCoherentMemory;
         }
@@ -2053,7 +2057,7 @@ FfxErrorCode GetDeviceCapabilitiesVK(FfxInterface* backendInterface, FfxDeviceCa
             physicalDeviceFeatures2.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
             physicalDeviceFeatures2.pNext = &synchronizationFeatures;
 
-            vkGetPhysicalDeviceFeatures2(context->physicalDevice, &physicalDeviceFeatures2);
+            context->vkFunctionTable.vkGetPhysicalDeviceFeatures2(context->physicalDevice, &physicalDeviceFeatures2);
 
             deviceCapabilities->extendedSynchronizationSupported = (bool)synchronizationFeatures.synchronization2;
         }
@@ -2067,7 +2071,7 @@ FfxErrorCode GetDeviceCapabilitiesVK(FfxInterface* backendInterface, FfxDeviceCa
             physicalDeviceFeatures2.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
             physicalDeviceFeatures2.pNext = &descriptorIndexingFeatures;
 
-            vkGetPhysicalDeviceFeatures2(context->physicalDevice, &physicalDeviceFeatures2);
+            context->vkFunctionTable.vkGetPhysicalDeviceFeatures2(context->physicalDevice, &physicalDeviceFeatures2);
 
             deviceCapabilities->shaderStorageBufferArrayNonUniformIndexing = (bool)descriptorIndexingFeatures.shaderStorageBufferArrayNonUniformIndexing;
         }
@@ -2224,9 +2228,7 @@ FfxErrorCode CreateResourceVK(
     backendResource->currentState = resourceState;
 
 #ifdef _DEBUG
-    size_t retval = 0;
-    wcstombs_s(&retval, backendResource->resourceName, sizeof(backendResource->resourceName), createResourceDescription->name, sizeof(backendResource->resourceName));
-    if (retval >= 64) backendResource->resourceName[63] = '\0';
+    strncpy(backendResource->resourceName, createResourceDescription->name, sizeof(backendResource->resourceName));
 #endif
 
     VkMemoryRequirements memRequirements = {};
@@ -2465,7 +2467,7 @@ FfxErrorCode CreateResourceVK(
         backendInterface->fpCreateResource(backendInterface, &uploadDesc, effectContextId, &copySrc);
 
         // setup the upload job
-        FfxGpuJobDescription copyJob  = { FFX_GPU_JOB_COPY, L"Resource Initialization Copy" };
+        FfxGpuJobDescription copyJob  = { FFX_GPU_JOB_COPY, "Resource Initialization Copy" };
         copyJob.copyJobDescriptor.src = copySrc;
         copyJob.copyJobDescriptor.dst = *outResource;
         copyJob.copyJobDescriptor.srcOffset = 0;
@@ -2660,9 +2662,7 @@ FfxErrorCode RegisterResourceVK(
     copyResourceState(backendResource, inFfxResource);
 
 #ifdef _DEBUG
-    size_t retval = 0;
-    wcstombs_s(&retval, backendResource->resourceName, sizeof(backendResource->resourceName), inFfxResource->name, sizeof(backendResource->resourceName));
-    if (retval >= 64) backendResource->resourceName[63] = '\0';
+    strncpy(backendResource->resourceName, inFfxResource->name, sizeof(backendResource->resourceName));
 #endif
 
     // the first call of RegisterResource can be identified because
@@ -2788,7 +2788,7 @@ FfxResource GetResourceVK(FfxInterface* backendInterface, FfxResourceInternal in
 #ifdef _DEBUG
     if (backendContext->pResources[inResource.internalIndex].resourceName)
     {
-        ConvertUTF8ToUTF16(backendContext->pResources[inResource.internalIndex].resourceName, resource.name, 64);
+        strncpy(resource.name, backendContext->pResources[inResource.internalIndex].resourceName, 64);
     }
 #endif
 
@@ -2908,16 +2908,11 @@ FfxErrorCode registerStaticTextureSrv(BackendContext_VK* backendContext, const F
         }
 
 #ifdef _DEBUG
-        size_t retval = 0;
-        char   resourceName[64];
-        wcstombs_s(&retval, resourceName, sizeof(resourceName), inResource->name, sizeof(resourceName));
-        if (retval >= 64) resourceName[63] = '\0';
-
         setVKObjectName(backendContext->vkFunctionTable,
                         backendContext->device,
                         VK_OBJECT_TYPE_IMAGE_VIEW,
                         (uint64_t)backendContext->pResourceViews[imageViewIndex].imageView,
-                        resourceName);
+                        inResource->name);
 #endif
 
         VkWriteDescriptorSet  writeDescriptorSet  = {};
@@ -3059,16 +3054,11 @@ FfxErrorCode registerStaticTextureUav(BackendContext_VK* backendContext, const F
         }
 
 #ifdef _DEBUG
-        size_t retval = 0;
-        char   resourceName[64];
-        wcstombs_s(&retval, resourceName, sizeof(resourceName), inResource->name, sizeof(resourceName));
-        if (retval >= 64) resourceName[63] = '\0';
-
         setVKObjectName(backendContext->vkFunctionTable,
                         backendContext->device,
                         VK_OBJECT_TYPE_IMAGE_VIEW,
                         (uint64_t)backendContext->pResourceViews[imageViewIndex].imageView,
-                        resourceName);
+                        inResource->name);
 #endif
 
         VkWriteDescriptorSet  writeDescriptorSet  = {};
@@ -3486,7 +3476,7 @@ FfxErrorCode CreatePipelineVK(FfxInterface* backendInterface,
 
             outPipeline->srvTextureBindings[bindingIndex].slotIndex  = slotIndex;
             outPipeline->srvTextureBindings[bindingIndex].arrayIndex = arrayIndex;
-            ConvertUTF8ToUTF16(shaderBlob.boundSRVTextureNames[srvIndex], outPipeline->srvTextureBindings[bindingIndex].name, FFX_RESOURCE_NAME_SIZE);
+            strncpy(outPipeline->srvTextureBindings[bindingIndex].name, shaderBlob.boundSRVTextureNames[srvIndex], FFX_RESOURCE_NAME_SIZE);
         }
     }
 
@@ -3506,7 +3496,7 @@ FfxErrorCode CreatePipelineVK(FfxInterface* backendInterface,
 
             outPipeline->uavTextureBindings[bindingIndex].slotIndex  = slotIndex;
             outPipeline->uavTextureBindings[bindingIndex].arrayIndex = arrayIndex;
-            ConvertUTF8ToUTF16(shaderBlob.boundUAVTextureNames[uavIndex], outPipeline->uavTextureBindings[bindingIndex].name, FFX_RESOURCE_NAME_SIZE);
+            strncpy(outPipeline->uavTextureBindings[bindingIndex].name, shaderBlob.boundUAVTextureNames[uavIndex], FFX_RESOURCE_NAME_SIZE);
         }
     }
 
@@ -3531,7 +3521,7 @@ FfxErrorCode CreatePipelineVK(FfxInterface* backendInterface,
 
             outPipeline->srvBufferBindings[bindingIndex].slotIndex  = slotIndex;
             outPipeline->srvBufferBindings[bindingIndex].arrayIndex = arrayIndex;
-            ConvertUTF8ToUTF16(shaderBlob.boundSRVBufferNames[srvIndex], outPipeline->srvBufferBindings[bindingIndex].name, FFX_RESOURCE_NAME_SIZE);
+            strncpy(outPipeline->srvBufferBindings[bindingIndex].name, shaderBlob.boundSRVBufferNames[srvIndex], FFX_RESOURCE_NAME_SIZE);
         }
     }
 
@@ -3551,7 +3541,7 @@ FfxErrorCode CreatePipelineVK(FfxInterface* backendInterface,
 
             outPipeline->uavBufferBindings[bindingIndex].slotIndex  = slotIndex;
             outPipeline->uavBufferBindings[bindingIndex].arrayIndex = arrayIndex;
-            ConvertUTF8ToUTF16(shaderBlob.boundUAVBufferNames[uavIndex], outPipeline->uavBufferBindings[bindingIndex].name, FFX_RESOURCE_NAME_SIZE);
+            strncpy(outPipeline->uavBufferBindings[bindingIndex].name, shaderBlob.boundUAVBufferNames[uavIndex], FFX_RESOURCE_NAME_SIZE);
         }
     }
 
@@ -3562,7 +3552,7 @@ FfxErrorCode CreatePipelineVK(FfxInterface* backendInterface,
     {
         outPipeline->constantBufferBindings[cbIndex].slotIndex  = shaderBlob.boundConstantBuffers[cbIndex];
         outPipeline->constantBufferBindings[cbIndex].arrayIndex = 1;
-        ConvertUTF8ToUTF16(shaderBlob.boundConstantBufferNames[cbIndex], outPipeline->constantBufferBindings[cbIndex].name, FFX_RESOURCE_NAME_SIZE);
+        strncpy(outPipeline->constantBufferBindings[cbIndex].name, shaderBlob.boundConstantBufferNames[cbIndex], FFX_RESOURCE_NAME_SIZE);
     }
 
     outPipeline->constCount = shaderBlob.cbvCount;
@@ -3636,7 +3626,7 @@ FfxErrorCode CreatePipelineVK(FfxInterface* backendInterface,
     outPipeline->pipeline = reinterpret_cast<FfxPipeline>(computePipeline);
 
     // Setup the pipeline name
-    wcscpy_s(outPipeline->name, pipelineDescription->name);
+    strcpy(outPipeline->name, pipelineDescription->name);
 
     return FFX_OK;
 }
@@ -4335,8 +4325,8 @@ void BreadcrumbsPrintDeviceInfoVK(
 
     VkPhysicalDeviceProperties devProps = {};
     VkPhysicalDeviceFeatures devFeatures = {};
-    vkGetPhysicalDeviceProperties(backendContext->physicalDevice, &devProps);
-    vkGetPhysicalDeviceFeatures(backendContext->physicalDevice, &devFeatures);
+    backendContext->vkFunctionTable.vkGetPhysicalDeviceProperties(backendContext->physicalDevice, &devProps);
+    backendContext->vkFunctionTable.vkGetPhysicalDeviceFeatures(backendContext->physicalDevice, &devFeatures);
 
     FFX_BREADCRUMBS_APPEND_STRING(buff, buffSize, "[VkPhysicalDeviceProperties]\n" FFX_BREADCRUMBS_PRINTING_INDENT "apiVersion: ");
     FFX_BREADCRUMBS_APPEND_UINT(buff, buffSize, VK_API_VERSION_MAJOR(devProps.apiVersion));
diff --git a/sdk/src/components/blur/CMakeLists.txt b/sdk/src/components/blur/CMakeLists.txt
index 5ed6328..9fad9b7 100644
--- a/sdk/src/components/blur/CMakeLists.txt
+++ b/sdk/src/components/blur/CMakeLists.txt
@@ -38,20 +38,28 @@ if (FFX_BLUR OR FFX_ALL)
 	list(APPEND PUBLIC_SOURCES ${FFX_PUBLIC_SOURCES})
 
 	if (FFX_BUILD_AS_DLL)
-		add_library(ffx_blur_${FFX_PLATFORM_NAME} SHARED ${SHARED_SOURCES} ${PRIVATE_SOURCES} ${PUBLIC_SOURCES})
+		add_library(blur SHARED ${SHARED_SOURCES} ${PRIVATE_SOURCES} ${PUBLIC_SOURCES})
 	else()
-		add_library(ffx_blur_${FFX_PLATFORM_NAME} STATIC ${SHARED_SOURCES} ${PRIVATE_SOURCES} ${PUBLIC_SOURCES})
+		add_library(blur STATIC ${SHARED_SOURCES} ${PRIVATE_SOURCES} ${PUBLIC_SOURCES})
 	endif()
+	add_library(fidelityfx::blur ALIAS blur)
 
 	# API
 	source_group("shared_source"  FILES ${SHARED_SOURCES})
 	source_group("private_source" FILES ${PRIVATE_SOURCES})
 	source_group("public_source"  FILES ${PUBLIC_SOURCES})
 
-	target_include_directories(ffx_blur_${FFX_PLATFORM_NAME} PUBLIC ${FFX_INCLUDE_PATH})
-	target_include_directories(ffx_blur_${FFX_PLATFORM_NAME} PUBLIC ${FFX_SHARED_PATH})
+	target_include_directories(blur PUBLIC
+		$<BUILD_INTERFACE:${FFX_INCLUDE_PATH}>
+		$<INSTALL_INTERFACE:include>)
+	target_include_directories(blur PRIVATE ${FFX_SHARED_PATH})
 
 	set_source_files_properties(${SHADERS} PROPERTIES HEADER_FILE_ONLY TRUE)
-	set_target_properties(ffx_blur_${FFX_PLATFORM_NAME} PROPERTIES FOLDER Components)
+	set_target_properties(blur PROPERTIES FOLDER Components)
+	
+	install(TARGETS blur EXPORT blur-targets)
+	install(EXPORT blur-targets 
+		DESTINATION "${CMAKE_INSTALL_DATADIR}/cmake/${PROJECT_NAME}"
+		NAMESPACE fidelityfx::)
 	
 endif()
diff --git a/sdk/src/components/blur/ffx_blur.cpp b/sdk/src/components/blur/ffx_blur.cpp
index 40be70a..d64b4eb 100644
--- a/sdk/src/components/blur/ffx_blur.cpp
+++ b/sdk/src/components/blur/ffx_blur.cpp
@@ -22,7 +22,7 @@
 
 #include <string>       // for wstring
 #include <string.h>     // for memset
-#include <stdlib.h>     // for _countof
+#include <stdlib.h>     // for std::size
 #include <cmath>        // for fabs, abs, sinf, sqrt, etc.
 
 #include <FidelityFX/host/ffx_blur.h>
@@ -37,60 +37,60 @@
 typedef struct ResourceBinding
 {
     uint32_t index;
-    wchar_t  name[64];
+    char     name[64];
 } ResourceBinding;
 
 static const ResourceBinding srvTextureBindingTable[] = {
-    {FFX_BLUR_RESOURCE_IDENTIFIER_INPUT_SRC, L"r_input_src"},
+    {FFX_BLUR_RESOURCE_IDENTIFIER_INPUT_SRC, "r_input_src"},
 };
 
 static const ResourceBinding uavTextureBindingTable[] = {
-    {FFX_BLUR_RESOURCE_IDENTIFIER_OUTPUT, L"rw_output"},
+    {FFX_BLUR_RESOURCE_IDENTIFIER_OUTPUT, "rw_output"},
 };
 
 static const ResourceBinding cbResourceBindingTable[] = {
-    {FFX_BLUR_CONSTANTBUFFER_IDENTIFIER_BLUR, L"cbBLUR"},
+    {FFX_BLUR_CONSTANTBUFFER_IDENTIFIER_BLUR, "cbBLUR"},
 };
 
-static wchar_t* getKernelSizeString(wchar_t* buffer, FfxBlurKernelSize kernelSize)
+static char* getKernelSizeString(char* buffer, FfxBlurKernelSize kernelSize)
 {
 #pragma warning(push)
 #pragma warning(disable : 4996) // Suppress the deprecation warning
     switch (kernelSize)
     {
     case FFX_BLUR_KERNEL_SIZE_3x3:
-        wcsncpy(buffer, L"3x3", wcslen(L"3x3"));
+        strncpy(buffer, "3x3", strlen("3x3"));
         break;
     case FFX_BLUR_KERNEL_SIZE_5x5:
-        wcsncpy(buffer, L"5x5", wcslen(L"5x5"));
+        strncpy(buffer, "5x5", strlen("5x5"));
         break;
     case FFX_BLUR_KERNEL_SIZE_7x7:
-        wcsncpy(buffer, L"7x7", wcslen(L"7x7"));
+        strncpy(buffer, "7x7", strlen("7x7"));
         break;
     case FFX_BLUR_KERNEL_SIZE_9x9:
-        wcsncpy(buffer, L"9x9", wcslen(L"9x9"));
+        strncpy(buffer, "9x9", strlen("9x9"));
         break;
     case FFX_BLUR_KERNEL_SIZE_11x11:
-        wcsncpy(buffer, L"11x11", wcslen(L"11x11"));
+        strncpy(buffer, "11x11", strlen("11x11"));
         break;
     case FFX_BLUR_KERNEL_SIZE_13x13:
-        wcsncpy(buffer, L"13x13", wcslen(L"13x13"));
+        strncpy(buffer, "13x13", strlen("13x13"));
         break;
     case FFX_BLUR_KERNEL_SIZE_15x15:
-        wcsncpy(buffer, L"15x15", wcslen(L"15x15"));
+        strncpy(buffer, "15x15", strlen("15x15"));
         break;
     case FFX_BLUR_KERNEL_SIZE_17x17:
-        wcsncpy(buffer, L"17x17", wcslen(L"17x17"));
+        strncpy(buffer, "17x17", strlen("17x17"));
         break;
     case FFX_BLUR_KERNEL_SIZE_19x19:
-        wcsncpy(buffer, L"19x19", wcslen(L"19x19"));
+        strncpy(buffer, "19x19", strlen("19x19"));
         break;
     case FFX_BLUR_KERNEL_SIZE_21x21:
-        wcsncpy(buffer, L"21x21", wcslen(L"21x21"));
+        strncpy(buffer, "21x21", strlen("21x21"));
         break;
     default:
         FFX_ASSERT_MESSAGE(false, "Unhandled kernel size in getKernelSizeString.");
-        wcsncpy(buffer, L"?x?", wcslen(L"?x?"));
+        strncpy(buffer, "?x?", strlen("?x?"));
         break;
     }
 #pragma warning(pop)
@@ -103,12 +103,12 @@ static FfxErrorCode patchResourceBindings(FfxPipelineState* inoutPipeline)
     for (uint32_t srvIndex = 0; srvIndex < inoutPipeline->srvTextureCount; ++srvIndex)
     {
         int32_t mapIndex = 0;
-        for (mapIndex = 0; mapIndex < _countof(srvTextureBindingTable); ++mapIndex)
+        for (mapIndex = 0; mapIndex < std::size(srvTextureBindingTable); ++mapIndex)
         {
-            if (0 == wcscmp(srvTextureBindingTable[mapIndex].name, inoutPipeline->srvTextureBindings[srvIndex].name))
+            if (0 == strcmp(srvTextureBindingTable[mapIndex].name, inoutPipeline->srvTextureBindings[srvIndex].name))
                 break;
         }
-        if (mapIndex == _countof(srvTextureBindingTable))
+        if (mapIndex == std::size(srvTextureBindingTable))
             return FFX_ERROR_INVALID_ARGUMENT;
 
         inoutPipeline->srvTextureBindings[srvIndex].resourceIdentifier = srvTextureBindingTable[mapIndex].index;
@@ -117,12 +117,12 @@ static FfxErrorCode patchResourceBindings(FfxPipelineState* inoutPipeline)
     for (uint32_t uavIndex = 0; uavIndex < inoutPipeline->uavTextureCount; ++uavIndex)
     {
         int32_t mapIndex = 0;
-        for (mapIndex = 0; mapIndex < _countof(uavTextureBindingTable); ++mapIndex)
+        for (mapIndex = 0; mapIndex < std::size(uavTextureBindingTable); ++mapIndex)
         {
-            if (0 == wcscmp(uavTextureBindingTable[mapIndex].name, inoutPipeline->uavTextureBindings[uavIndex].name))
+            if (0 == strcmp(uavTextureBindingTable[mapIndex].name, inoutPipeline->uavTextureBindings[uavIndex].name))
                 break;
         }
-        if (mapIndex == _countof(uavTextureBindingTable))
+        if (mapIndex == std::size(uavTextureBindingTable))
             return FFX_ERROR_INVALID_ARGUMENT;
 
         inoutPipeline->uavTextureBindings[uavIndex].resourceIdentifier = uavTextureBindingTable[mapIndex].index;
@@ -131,12 +131,12 @@ static FfxErrorCode patchResourceBindings(FfxPipelineState* inoutPipeline)
     for (uint32_t cbIndex = 0; cbIndex < inoutPipeline->constCount; ++cbIndex)
     {
         int32_t mapIndex = 0;
-        for (mapIndex = 0; mapIndex < _countof(cbResourceBindingTable); ++mapIndex)
+        for (mapIndex = 0; mapIndex < std::size(cbResourceBindingTable); ++mapIndex)
         {
-            if (0 == wcscmp(cbResourceBindingTable[mapIndex].name, inoutPipeline->constantBufferBindings[cbIndex].name))
+            if (0 == strcmp(cbResourceBindingTable[mapIndex].name, inoutPipeline->constantBufferBindings[cbIndex].name))
                 break;
         }
-        if (mapIndex == _countof(cbResourceBindingTable))
+        if (mapIndex == std::size(cbResourceBindingTable))
             return FFX_ERROR_INVALID_ARGUMENT;
 
         inoutPipeline->constantBufferBindings[cbIndex].resourceIdentifier = cbResourceBindingTable[mapIndex].index;
@@ -295,17 +295,17 @@ static FfxErrorCode createPipelineStateObjects(FfxBlurContext_Private* context)
             {
                 if (curKernelSize & context->contextDescription.kernelSizes)
                 {
-                    wcscpy_s(pipelineDescription.name, L"BLUR-BLUR_");
+                    strcpy(pipelineDescription.name, "BLUR-BLUR_");
 
-                    wchar_t kernelPermStr[32];
-                    swprintf_s(kernelPermStr, L"PERM%d_", kernPermIndex);
+                    char kernelPermStr[32];
+                    sprintf(kernelPermStr, "PERM%d_", kernPermIndex);
 
-                    wcscat_s(pipelineDescription.name, kernelPermStr);
+                    strcat(pipelineDescription.name, kernelPermStr);
 
-                    wchar_t kernel[10]; // 3x3 through 21x21
+                    char kernel[10]; // 3x3 through 21x21
                     getKernelSizeString(kernel, (FfxBlurKernelSize)curKernelSize);
 
-                    wcscat_s(pipelineDescription.name, kernel);
+                    strcat(pipelineDescription.name, kernel);
 
                     FfxPipelineState* pBlurPipeline = &context->pBlurPipelines[curPipelineIndex];
                     // Set up pipeline descriptors (basically RootSignature and binding)
@@ -475,7 +475,7 @@ static void scheduleDispatch(FfxBlurContext_Private* context,
                              uint32_t                dispatchZ)
 {
     FfxGpuJobDescription dispatchJob = {FFX_GPU_JOB_COMPUTE};
-    wcscpy_s(dispatchJob.jobLabel, pipeline->name);
+    strcpy(dispatchJob.jobLabel, pipeline->name);
 
     for (uint32_t currentShaderResourceViewIndex = 0; currentShaderResourceViewIndex < pipeline->srvTextureCount; ++currentShaderResourceViewIndex)
     {
@@ -484,7 +484,7 @@ static void scheduleDispatch(FfxBlurContext_Private* context,
 
         dispatchJob.computeJobDescriptor.srvTextures[currentShaderResourceViewIndex].resource = currentResource;
 #ifdef FFX_DEBUG
-        wcscpy_s(dispatchJob.computeJobDescriptor.srvTextures[currentShaderResourceViewIndex].name,
+        strcpy(dispatchJob.computeJobDescriptor.srvTextures[currentShaderResourceViewIndex].name,
             pipeline->srvTextureBindings[currentShaderResourceViewIndex].name);
 #endif
     }
@@ -499,7 +499,7 @@ static void scheduleDispatch(FfxBlurContext_Private* context,
         dispatchJob.computeJobDescriptor.uavTextures[uavEntry].resource = currentResource;
         dispatchJob.computeJobDescriptor.uavTextures[uavEntry++].mip = 0;
 #ifdef FFX_DEBUG
-        wcscpy_s(dispatchJob.computeJobDescriptor.uavTextures[currentUnorderedAccessViewIndex].name,
+        strcpy(dispatchJob.computeJobDescriptor.uavTextures[currentUnorderedAccessViewIndex].name,
             pipeline->uavTextureBindings[currentUnorderedAccessViewIndex].name);
 #endif
     }
@@ -511,7 +511,7 @@ static void scheduleDispatch(FfxBlurContext_Private* context,
 
     // Only 1 constant buffer
 #ifdef FFX_DEBUG
-    wcscpy_s(dispatchJob.computeJobDescriptor.cbNames[0], pipeline->constantBufferBindings[0].name);
+    strcpy(dispatchJob.computeJobDescriptor.cbNames[0], pipeline->constantBufferBindings[0].name);
 #endif
     dispatchJob.computeJobDescriptor.cbs[0] = context->blurConstants;
 
diff --git a/sdk/src/components/breadcrumbs/CMakeLists.txt b/sdk/src/components/breadcrumbs/CMakeLists.txt
index f32b0bf..5086af7 100644
--- a/sdk/src/components/breadcrumbs/CMakeLists.txt
+++ b/sdk/src/components/breadcrumbs/CMakeLists.txt
@@ -38,9 +38,9 @@ if (FFX_BREADCRUMBS OR FFX_ALL)
 	list(APPEND PUBLIC_SOURCES ${FFX_PUBLIC_SOURCES})
 
 	if (FFX_BUILD_AS_DLL)
-		add_library(ffx_breadcrumbs_${FFX_PLATFORM_NAME} SHARED ${SHARED_SOURCES} ${PRIVATE_SOURCES} ${PUBLIC_SOURCES})
+		add_library(breadcrumbs SHARED ${SHARED_SOURCES} ${PRIVATE_SOURCES} ${PUBLIC_SOURCES})
 	else()
-		add_library(ffx_breadcrumbs_${FFX_PLATFORM_NAME} STATIC ${SHARED_SOURCES} ${PRIVATE_SOURCES} ${PUBLIC_SOURCES})
+		add_library(breadcrumbs STATIC ${SHARED_SOURCES} ${PRIVATE_SOURCES} ${PUBLIC_SOURCES})
 	endif()
 
 	# API
@@ -48,10 +48,17 @@ if (FFX_BREADCRUMBS OR FFX_ALL)
 	source_group("private_source" FILES ${PRIVATE_SOURCES})
 	source_group("public_source"  FILES ${PUBLIC_SOURCES})
 
-	target_include_directories(ffx_breadcrumbs_${FFX_PLATFORM_NAME} PUBLIC ${FFX_INCLUDE_PATH})
-	target_include_directories(ffx_breadcrumbs_${FFX_PLATFORM_NAME} PUBLIC ${FFX_SHARED_PATH})
+	target_include_directories(breadcrumbs PUBLIC
+		$<BUILD_INTERFACE:${FFX_INCLUDE_PATH}>
+		$<INSTALL_INTERFACE:include>)
+	target_include_directories(breadcrumbs PRIVATE ${FFX_SHARED_PATH})
 
 	set_source_files_properties(${SHADERS} PROPERTIES HEADER_FILE_ONLY TRUE)
-	set_target_properties(ffx_breadcrumbs_${FFX_PLATFORM_NAME} PROPERTIES FOLDER Components)
+	set_target_properties(breadcrumbs PROPERTIES FOLDER Components)
+	
+	install(TARGETS breadcrumbs EXPORT breadcrumbs-targets)
+	install(EXPORT breadcrumbs-targets 
+		DESTINATION "${CMAKE_INSTALL_DATADIR}/cmake/${PROJECT_NAME}"
+		NAMESPACE fidelityfx::)
 	
 endif()
diff --git a/sdk/src/components/breadcrumbs/ffx_breadcrumbs.cpp b/sdk/src/components/breadcrumbs/ffx_breadcrumbs.cpp
index 54aed31..81330fa 100644
--- a/sdk/src/components/breadcrumbs/ffx_breadcrumbs.cpp
+++ b/sdk/src/components/breadcrumbs/ffx_breadcrumbs.cpp
@@ -20,6 +20,7 @@
 // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 // THE SOFTWARE.
 
+#include <new>
 #include <cstring>     // for memset
 
 #include <ffx_object_management.h>           
diff --git a/sdk/src/components/brixelizer/CMakeLists.txt b/sdk/src/components/brixelizer/CMakeLists.txt
index 719fdfe..a7e7a36 100644
--- a/sdk/src/components/brixelizer/CMakeLists.txt
+++ b/sdk/src/components/brixelizer/CMakeLists.txt
@@ -38,9 +38,9 @@ if (FFX_BRIXELIZER OR FFX_ALL)
 	list(APPEND PUBLIC_SOURCES ${FFX_PUBLIC_SOURCES})
 
 	if (FFX_BUILD_AS_DLL)
-		add_library(ffx_brixelizer_${FFX_PLATFORM_NAME} SHARED ${SHARED_SOURCES} ${PRIVATE_SOURCES} ${PUBLIC_SOURCES})
+		add_library(brixelizer SHARED ${SHARED_SOURCES} ${PRIVATE_SOURCES} ${PUBLIC_SOURCES})
 	else()
-		add_library(ffx_brixelizer_${FFX_PLATFORM_NAME} STATIC ${SHARED_SOURCES} ${PRIVATE_SOURCES} ${PUBLIC_SOURCES})
+		add_library(brixelizer STATIC ${SHARED_SOURCES} ${PRIVATE_SOURCES} ${PUBLIC_SOURCES})
 	endif()
 
 	# API
@@ -48,10 +48,17 @@ if (FFX_BRIXELIZER OR FFX_ALL)
 	source_group("private_source" FILES ${PRIVATE_SOURCES})
 	source_group("public_source"  FILES ${PUBLIC_SOURCES})
 
-	target_include_directories(ffx_brixelizer_${FFX_PLATFORM_NAME} PUBLIC ${FFX_INCLUDE_PATH})
-	target_include_directories(ffx_brixelizer_${FFX_PLATFORM_NAME} PUBLIC ${FFX_SHARED_PATH})
+	target_include_directories(brixelizer PUBLIC
+		$<BUILD_INTERFACE:${FFX_INCLUDE_PATH}>
+		$<INSTALL_INTERFACE:include>)
+	target_include_directories(brixelizer PRIVATE ${FFX_SHARED_PATH})
 
 	set_source_files_properties(${SHADERS} PROPERTIES HEADER_FILE_ONLY TRUE)
-	set_target_properties(ffx_brixelizer_${FFX_PLATFORM_NAME} PROPERTIES FOLDER Components)
+	set_target_properties(brixelizer PROPERTIES FOLDER Components)
+	
+	install(TARGETS brixelizer EXPORT brixelizer-targets)
+	install(EXPORT brixelizer-targets 
+		DESTINATION "${CMAKE_INSTALL_DATADIR}/cmake/${PROJECT_NAME}"
+		NAMESPACE fidelityfx::)
 	
 endif()
\ No newline at end of file
diff --git a/sdk/src/components/brixelizer/ffx_brixelizer_raw.cpp b/sdk/src/components/brixelizer/ffx_brixelizer_raw.cpp
index 377d9de..3ae9263 100644
--- a/sdk/src/components/brixelizer/ffx_brixelizer_raw.cpp
+++ b/sdk/src/components/brixelizer/ffx_brixelizer_raw.cpp
@@ -20,6 +20,8 @@
 // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 // THE SOFTWARE.
 
+#include <array>      // for std::size.
+#include <stdio.h>    // for snprintf.
 #include <stdint.h>   // for integer types.
 #include <algorithm>  // for max used inside SPD CPU code.
 #include <cmath>      // for fabs, abs, sinf, sqrt, etc.
@@ -39,59 +41,59 @@
 typedef struct ResourceBinding
 {
     uint32_t index;
-    wchar_t  name[64];
+    char     name[64];
 } ResourceBinding;
 
 static const ResourceBinding srvResourceBindingTable[] = {
-    {FFX_BRIXELIZER_RESOURCE_IDENTIFIER_UPLOAD_JOB_BUFFER, L"r_job_buffer"},
-    {FFX_BRIXELIZER_RESOURCE_IDENTIFIER_UPLOAD_JOB_INDEX_BUFFER, L"r_job_index_buffer"},
-    {FFX_BRIXELIZER_RESOURCE_IDENTIFIER_INSTANCE_INFO_BUFFER, L"r_instance_info_buffer"},
-    {FFX_BRIXELIZER_RESOURCE_IDENTIFIER_INSTANCE_TRANSFORM_BUFFER, L"r_instance_transform_buffer"},
-    {FFX_BRIXELIZER_RESOURCE_IDENTIFIER_CONTEXT_SDF_ATLAS, L"r_sdf_atlas"},
-    {FFX_BRIXELIZER_RESOURCE_IDENTIFIER_UPLOAD_DEBUG_INSTANCE_ID_BUFFER, L"r_debug_instance_id"},
+    {FFX_BRIXELIZER_RESOURCE_IDENTIFIER_UPLOAD_JOB_BUFFER, "r_job_buffer"},
+    {FFX_BRIXELIZER_RESOURCE_IDENTIFIER_UPLOAD_JOB_INDEX_BUFFER, "r_job_index_buffer"},
+    {FFX_BRIXELIZER_RESOURCE_IDENTIFIER_INSTANCE_INFO_BUFFER, "r_instance_info_buffer"},
+    {FFX_BRIXELIZER_RESOURCE_IDENTIFIER_INSTANCE_TRANSFORM_BUFFER, "r_instance_transform_buffer"},
+    {FFX_BRIXELIZER_RESOURCE_IDENTIFIER_CONTEXT_SDF_ATLAS, "r_sdf_atlas"},
+    {FFX_BRIXELIZER_RESOURCE_IDENTIFIER_UPLOAD_DEBUG_INSTANCE_ID_BUFFER, "r_debug_instance_id"},
 };
 
 static const ResourceBinding uavResourceBindingTable[] = {
-    {FFX_BRIXELIZER_RESOURCE_IDENTIFIER_CASCADE_AABB_TREE, L"rw_cascade_aabbtree"},
-    {FFX_BRIXELIZER_RESOURCE_IDENTIFIER_CASCADE_AABB_TREES, L"rw_cascade_aabbtrees"},
-    {FFX_BRIXELIZER_RESOURCE_IDENTIFIER_CASCADE_BRICK_MAP, L"rw_cascade_brick_map"},
-    {FFX_BRIXELIZER_RESOURCE_IDENTIFIER_CASCADE_BRICK_MAPS, L"rw_cascade_brick_maps"},
-    {FFX_BRIXELIZER_RESOURCE_IDENTIFIER_SCRATCH_COUNTERS, L"rw_scratch_counters"},
-    {FFX_BRIXELIZER_RESOURCE_IDENTIFIER_SCRATCH_INDEX_SWAP, L"rw_scratch_index_swap"},
-    {FFX_BRIXELIZER_RESOURCE_IDENTIFIER_SCRATCH_VOXEL_ALLOCATION_FAIL_COUNTER, L"rw_scratch_voxel_allocation_fail_counter"},
-    {FFX_BRIXELIZER_RESOURCE_IDENTIFIER_SCRATCH_BRICKS_STORAGE, L"rw_scratch_bricks_storage"},
-    {FFX_BRIXELIZER_RESOURCE_IDENTIFIER_SCRATCH_BRICKS_STORAGE_OFFSETS, L"rw_scratch_bricks_storage_offsets"},
-    {FFX_BRIXELIZER_RESOURCE_IDENTIFIER_SCRATCH_BRICKS_COMPRESSION_LIST, L"rw_scratch_bricks_compression_list"},
-    {FFX_BRIXELIZER_RESOURCE_IDENTIFIER_SCRATCH_BRICKS_CLEAR_LIST, L"rw_scratch_bricks_clear_list"},
-    {FFX_BRIXELIZER_RESOURCE_IDENTIFIER_SCRATCH_JOB_COUNTERS, L"rw_scratch_job_counters"},
-    {FFX_BRIXELIZER_RESOURCE_IDENTIFIER_SCRATCH_JOB_COUNTERS_SCAN, L"rw_scratch_job_counters_scan"},
-    {FFX_BRIXELIZER_RESOURCE_IDENTIFIER_SCRATCH_JOB_GLOBAL_COUNTERS_SCAN, L"rw_scratch_job_global_counters_scan"},
-    {FFX_BRIXELIZER_RESOURCE_IDENTIFIER_SCRATCH_CR1_REFERENCES, L"rw_scratch_cr1_references"},
-    {FFX_BRIXELIZER_RESOURCE_IDENTIFIER_SCRATCH_CR1_COMPACTED_REFERENCES, L"rw_scratch_cr1_compacted_references"},
-    {FFX_BRIXELIZER_RESOURCE_IDENTIFIER_SCRATCH_CR1_REF_COUNTERS, L"rw_scratch_cr1_ref_counters"},
-    {FFX_BRIXELIZER_RESOURCE_IDENTIFIER_SCRATCH_CR1_REF_COUNTER_SCAN, L"rw_scratch_cr1_ref_counter_scan"},
-    {FFX_BRIXELIZER_RESOURCE_IDENTIFIER_SCRATCH_CR1_REF_GLOBAL_SCAN, L"rw_scratch_cr1_ref_global_scan"},
-    {FFX_BRIXELIZER_RESOURCE_IDENTIFIER_SCRATCH_CR1_STAMP_SCAN, L"rw_scratch_cr1_stamp_scan"},
-    {FFX_BRIXELIZER_RESOURCE_IDENTIFIER_SCRATCH_CR1_STAMP_GLOBAL_SCAN, L"rw_scratch_cr1_stamp_global_scan"},
-    {FFX_BRIXELIZER_RESOURCE_IDENTIFIER_INDIRECT_ARGS_1, L"rw_indirect_args_1"},
-    {FFX_BRIXELIZER_RESOURCE_IDENTIFIER_CONTEXT_BRICKS_VOXEL_MAP, L"rw_bctx_bricks_voxel_map"},
-    {FFX_BRIXELIZER_RESOURCE_IDENTIFIER_CONTEXT_BRICKS_AABB, L"rw_bctx_bricks_aabb"},
-    {FFX_BRIXELIZER_RESOURCE_IDENTIFIER_CONTEXT_BRICKS_FREE_LIST, L"rw_bctx_bricks_free_list"},
-    {FFX_BRIXELIZER_RESOURCE_IDENTIFIER_CONTEXT_BRICKS_CLEAR_LIST, L"rw_bctx_bricks_clear_list"},
-    {FFX_BRIXELIZER_RESOURCE_IDENTIFIER_CONTEXT_BRICKS_EIKONAL_LIST, L"rw_bctx_bricks_eikonal_list"},
-    {FFX_BRIXELIZER_RESOURCE_IDENTIFIER_CONTEXT_BRICKS_MERGE_LIST, L"rw_bctx_bricks_merge_list"},
-    {FFX_BRIXELIZER_RESOURCE_IDENTIFIER_CONTEXT_BRICKS_EIKONAL_COUNTERS, L"rw_bctx_bricks_eikonal_counters"},
-    {FFX_BRIXELIZER_RESOURCE_IDENTIFIER_CONTEXT_COUNTERS, L"rw_bctx_counters"},
-    {FFX_BRIXELIZER_RESOURCE_IDENTIFIER_CONTEXT_SDF_ATLAS, L"rw_sdf_atlas"},
-    {FFX_BRIXELIZER_RESOURCE_IDENTIFIER_DEBUG_OUTPUT, L"rw_debug_output"},
-    {FFX_BRIXELIZER_RESOURCE_IDENTIFIER_SCRATCH_DEBUG_AABBS, L"rw_debug_aabbs"},
+    {FFX_BRIXELIZER_RESOURCE_IDENTIFIER_CASCADE_AABB_TREE, "rw_cascade_aabbtree"},
+    {FFX_BRIXELIZER_RESOURCE_IDENTIFIER_CASCADE_AABB_TREES, "rw_cascade_aabbtrees"},
+    {FFX_BRIXELIZER_RESOURCE_IDENTIFIER_CASCADE_BRICK_MAP, "rw_cascade_brick_map"},
+    {FFX_BRIXELIZER_RESOURCE_IDENTIFIER_CASCADE_BRICK_MAPS, "rw_cascade_brick_maps"},
+    {FFX_BRIXELIZER_RESOURCE_IDENTIFIER_SCRATCH_COUNTERS, "rw_scratch_counters"},
+    {FFX_BRIXELIZER_RESOURCE_IDENTIFIER_SCRATCH_INDEX_SWAP, "rw_scratch_index_swap"},
+    {FFX_BRIXELIZER_RESOURCE_IDENTIFIER_SCRATCH_VOXEL_ALLOCATION_FAIL_COUNTER, "rw_scratch_voxel_allocation_fail_counter"},
+    {FFX_BRIXELIZER_RESOURCE_IDENTIFIER_SCRATCH_BRICKS_STORAGE, "rw_scratch_bricks_storage"},
+    {FFX_BRIXELIZER_RESOURCE_IDENTIFIER_SCRATCH_BRICKS_STORAGE_OFFSETS, "rw_scratch_bricks_storage_offsets"},
+    {FFX_BRIXELIZER_RESOURCE_IDENTIFIER_SCRATCH_BRICKS_COMPRESSION_LIST, "rw_scratch_bricks_compression_list"},
+    {FFX_BRIXELIZER_RESOURCE_IDENTIFIER_SCRATCH_BRICKS_CLEAR_LIST, "rw_scratch_bricks_clear_list"},
+    {FFX_BRIXELIZER_RESOURCE_IDENTIFIER_SCRATCH_JOB_COUNTERS, "rw_scratch_job_counters"},
+    {FFX_BRIXELIZER_RESOURCE_IDENTIFIER_SCRATCH_JOB_COUNTERS_SCAN, "rw_scratch_job_counters_scan"},
+    {FFX_BRIXELIZER_RESOURCE_IDENTIFIER_SCRATCH_JOB_GLOBAL_COUNTERS_SCAN, "rw_scratch_job_global_counters_scan"},
+    {FFX_BRIXELIZER_RESOURCE_IDENTIFIER_SCRATCH_CR1_REFERENCES, "rw_scratch_cr1_references"},
+    {FFX_BRIXELIZER_RESOURCE_IDENTIFIER_SCRATCH_CR1_COMPACTED_REFERENCES, "rw_scratch_cr1_compacted_references"},
+    {FFX_BRIXELIZER_RESOURCE_IDENTIFIER_SCRATCH_CR1_REF_COUNTERS, "rw_scratch_cr1_ref_counters"},
+    {FFX_BRIXELIZER_RESOURCE_IDENTIFIER_SCRATCH_CR1_REF_COUNTER_SCAN, "rw_scratch_cr1_ref_counter_scan"},
+    {FFX_BRIXELIZER_RESOURCE_IDENTIFIER_SCRATCH_CR1_REF_GLOBAL_SCAN, "rw_scratch_cr1_ref_global_scan"},
+    {FFX_BRIXELIZER_RESOURCE_IDENTIFIER_SCRATCH_CR1_STAMP_SCAN, "rw_scratch_cr1_stamp_scan"},
+    {FFX_BRIXELIZER_RESOURCE_IDENTIFIER_SCRATCH_CR1_STAMP_GLOBAL_SCAN, "rw_scratch_cr1_stamp_global_scan"},
+    {FFX_BRIXELIZER_RESOURCE_IDENTIFIER_INDIRECT_ARGS_1, "rw_indirect_args_1"},
+    {FFX_BRIXELIZER_RESOURCE_IDENTIFIER_CONTEXT_BRICKS_VOXEL_MAP, "rw_bctx_bricks_voxel_map"},
+    {FFX_BRIXELIZER_RESOURCE_IDENTIFIER_CONTEXT_BRICKS_AABB, "rw_bctx_bricks_aabb"},
+    {FFX_BRIXELIZER_RESOURCE_IDENTIFIER_CONTEXT_BRICKS_FREE_LIST, "rw_bctx_bricks_free_list"},
+    {FFX_BRIXELIZER_RESOURCE_IDENTIFIER_CONTEXT_BRICKS_CLEAR_LIST, "rw_bctx_bricks_clear_list"},
+    {FFX_BRIXELIZER_RESOURCE_IDENTIFIER_CONTEXT_BRICKS_EIKONAL_LIST, "rw_bctx_bricks_eikonal_list"},
+    {FFX_BRIXELIZER_RESOURCE_IDENTIFIER_CONTEXT_BRICKS_MERGE_LIST, "rw_bctx_bricks_merge_list"},
+    {FFX_BRIXELIZER_RESOURCE_IDENTIFIER_CONTEXT_BRICKS_EIKONAL_COUNTERS, "rw_bctx_bricks_eikonal_counters"},
+    {FFX_BRIXELIZER_RESOURCE_IDENTIFIER_CONTEXT_COUNTERS, "rw_bctx_counters"},
+    {FFX_BRIXELIZER_RESOURCE_IDENTIFIER_CONTEXT_SDF_ATLAS, "rw_sdf_atlas"},
+    {FFX_BRIXELIZER_RESOURCE_IDENTIFIER_DEBUG_OUTPUT, "rw_debug_output"},
+    {FFX_BRIXELIZER_RESOURCE_IDENTIFIER_SCRATCH_DEBUG_AABBS, "rw_debug_aabbs"},
 };
 
 static const ResourceBinding cbvResourceBindingTable[] = {
-    {FFX_BRIXELIZER_CONSTANTBUFFER_IDENTIFIER_CASCADE_INFO, L"cbBrixelizerCascadeInfo"},
-    {FFX_BRIXELIZER_CONSTANTBUFFER_IDENTIFIER_CONTEXT_INFO, L"cbBrixelizerContextInfo"},
-    {FFX_BRIXELIZER_CONSTANTBUFFER_IDENTIFIER_BUILD_INFO, L"cbBrixelizerBuildInfo"},
-    {FFX_BRIXELIZER_CONSTANTBUFFER_IDENTIFIER_DEBUG_INFO, L"cbBrixelizerDebugInfo"},
+    {FFX_BRIXELIZER_CONSTANTBUFFER_IDENTIFIER_CASCADE_INFO, "cbBrixelizerCascadeInfo"},
+    {FFX_BRIXELIZER_CONSTANTBUFFER_IDENTIFIER_CONTEXT_INFO, "cbBrixelizerContextInfo"},
+    {FFX_BRIXELIZER_CONSTANTBUFFER_IDENTIFIER_BUILD_INFO, "cbBrixelizerBuildInfo"},
+    {FFX_BRIXELIZER_CONSTANTBUFFER_IDENTIFIER_DEBUG_INFO, "cbBrixelizerDebugInfo"},
 };
 
 static size_t cbSizes[] = {
@@ -189,12 +191,12 @@ static void patchResourceBindings(FfxPipelineState* inoutPipeline)
         FfxResourceBinding& binding = inoutPipeline->srvTextureBindings[srvTextureIndex];
 
         int32_t mapIndex = 0;
-        for (mapIndex = 0; mapIndex < _countof(srvResourceBindingTable); ++mapIndex)
+        for (mapIndex = 0; mapIndex < std::size(srvResourceBindingTable); ++mapIndex)
         {
-            if (0 == wcscmp(srvResourceBindingTable[mapIndex].name, binding.name))
+            if (0 == strcmp(srvResourceBindingTable[mapIndex].name, binding.name))
                 break;
         }
-        if (mapIndex == _countof(srvResourceBindingTable))
+        if (mapIndex == std::size(srvResourceBindingTable))
             return;
 
         binding.resourceIdentifier = srvResourceBindingTable[mapIndex].index + binding.arrayIndex;
@@ -205,12 +207,12 @@ static void patchResourceBindings(FfxPipelineState* inoutPipeline)
         FfxResourceBinding& binding = inoutPipeline->srvBufferBindings[srvBufferIndex];
 
         int32_t mapIndex = 0;
-        for (mapIndex = 0; mapIndex < _countof(srvResourceBindingTable); ++mapIndex)
+        for (mapIndex = 0; mapIndex < std::size(srvResourceBindingTable); ++mapIndex)
         {
-            if (0 == wcscmp(srvResourceBindingTable[mapIndex].name, binding.name))
+            if (0 == strcmp(srvResourceBindingTable[mapIndex].name, binding.name))
                 break;
         }
-        if (mapIndex == _countof(srvResourceBindingTable))
+        if (mapIndex == std::size(srvResourceBindingTable))
             return;
 
         binding.resourceIdentifier = srvResourceBindingTable[mapIndex].index + binding.arrayIndex;
@@ -219,12 +221,12 @@ static void patchResourceBindings(FfxPipelineState* inoutPipeline)
     for (uint32_t uavTextureIndex = 0; uavTextureIndex < inoutPipeline->uavTextureCount; ++uavTextureIndex)
     {
         int32_t mapIndex = 0;
-        for (mapIndex = 0; mapIndex < _countof(uavResourceBindingTable); ++mapIndex)
+        for (mapIndex = 0; mapIndex < std::size(uavResourceBindingTable); ++mapIndex)
         {
-            if (0 == wcscmp(uavResourceBindingTable[mapIndex].name, inoutPipeline->uavTextureBindings[uavTextureIndex].name))
+            if (0 == strcmp(uavResourceBindingTable[mapIndex].name, inoutPipeline->uavTextureBindings[uavTextureIndex].name))
                 break;
         }
-        if (mapIndex == _countof(uavResourceBindingTable))
+        if (mapIndex == std::size(uavResourceBindingTable))
             return;
 
         inoutPipeline->uavTextureBindings[uavTextureIndex].resourceIdentifier = uavResourceBindingTable[mapIndex].index;
@@ -235,12 +237,12 @@ static void patchResourceBindings(FfxPipelineState* inoutPipeline)
         FfxResourceBinding& binding = inoutPipeline->uavBufferBindings[uavBufferIndex];
 
         int32_t mapIndex = 0;
-        for (mapIndex = 0; mapIndex < _countof(uavResourceBindingTable); ++mapIndex)
+        for (mapIndex = 0; mapIndex < std::size(uavResourceBindingTable); ++mapIndex)
         {
-            if (0 == wcscmp(uavResourceBindingTable[mapIndex].name, binding.name))
+            if (0 == strcmp(uavResourceBindingTable[mapIndex].name, binding.name))
                 break;
         }
-        if (mapIndex == _countof(uavResourceBindingTable))
+        if (mapIndex == std::size(uavResourceBindingTable))
             return;
 
         binding.resourceIdentifier = uavResourceBindingTable[mapIndex].index + binding.arrayIndex;
@@ -251,12 +253,12 @@ static void patchResourceBindings(FfxPipelineState* inoutPipeline)
         FfxResourceBinding& binding = inoutPipeline->constantBufferBindings[cbvIndex];
 
         int32_t mapIndex = 0;
-        for (mapIndex = 0; mapIndex < _countof(cbvResourceBindingTable); ++mapIndex)
+        for (mapIndex = 0; mapIndex < std::size(cbvResourceBindingTable); ++mapIndex)
         {
-            if (0 == wcscmp(cbvResourceBindingTable[mapIndex].name, binding.name))
+            if (0 == strcmp(cbvResourceBindingTable[mapIndex].name, binding.name))
                 break;
         }
-        if (mapIndex == _countof(cbvResourceBindingTable))
+        if (mapIndex == std::size(cbvResourceBindingTable))
             return;
 
         binding.resourceIdentifier = cbvResourceBindingTable[mapIndex].index;
@@ -308,7 +310,7 @@ static FfxErrorCode createPipelineStates(FfxBrixelizerRawContext_Private* contex
     memset(&pipelineDescription, 0, sizeof(FfxPipelineDescription));
 
     // Set up pipeline descriptor (basically RootSignature and binding)
-    wcscpy_s(pipelineDescription.name, L"FFX_BRIXELIZER_PASS_CASCADE_MARK_UNINITIALIZED");
+    strcpy(pipelineDescription.name, "FFX_BRIXELIZER_PASS_CASCADE_MARK_UNINITIALIZED");
     FFX_VALIDATE(context->contextDescription.backendInterface.fpCreatePipeline(&context->contextDescription.backendInterface,
                                                                                FFX_EFFECT_BRIXELIZER,
                                                                                FFX_BRIXELIZER_PASS_CASCADE_MARK_UNINITIALIZED,
@@ -316,7 +318,7 @@ static FfxErrorCode createPipelineStates(FfxBrixelizerRawContext_Private* contex
                                                                                &pipelineDescription,
                                                                                context->effectContextId,
                                                                                &context->pipelineCascadeMarkCascadeUninitialized));
-    wcscpy_s(pipelineDescription.name, L"FFX_BRIXELIZER_PASS_CONTEXT_CLEAR_COUNTERS");
+    strcpy(pipelineDescription.name, "FFX_BRIXELIZER_PASS_CONTEXT_CLEAR_COUNTERS");
     FFX_VALIDATE(context->contextDescription.backendInterface.fpCreatePipeline(&context->contextDescription.backendInterface,
                                                                                FFX_EFFECT_BRIXELIZER,
                                                                                FFX_BRIXELIZER_PASS_CONTEXT_CLEAR_COUNTERS,
@@ -324,7 +326,7 @@ static FfxErrorCode createPipelineStates(FfxBrixelizerRawContext_Private* contex
                                                                                &pipelineDescription,
                                                                                context->effectContextId,
                                                                                &context->pipelineContextClearCounters));
-    wcscpy_s(pipelineDescription.name, L"FFX_BRIXELIZER_PASS_CONTEXT_COLLECT_CLEAR_BRICKS");
+    strcpy(pipelineDescription.name, "FFX_BRIXELIZER_PASS_CONTEXT_COLLECT_CLEAR_BRICKS");
     FFX_VALIDATE(context->contextDescription.backendInterface.fpCreatePipeline(&context->contextDescription.backendInterface,
                                                                                FFX_EFFECT_BRIXELIZER,
                                                                                FFX_BRIXELIZER_PASS_CONTEXT_COLLECT_CLEAR_BRICKS,
@@ -332,7 +334,7 @@ static FfxErrorCode createPipelineStates(FfxBrixelizerRawContext_Private* contex
                                                                                &pipelineDescription,
                                                                                context->effectContextId,
                                                                                &context->pipelineContextCollectClearBricks));
-    wcscpy_s(pipelineDescription.name, L"FFX_BRIXELIZER_PASS_CONTEXT_PREPARE_CLEAR_BRICKS");
+    strcpy(pipelineDescription.name, "FFX_BRIXELIZER_PASS_CONTEXT_PREPARE_CLEAR_BRICKS");
     FFX_VALIDATE(context->contextDescription.backendInterface.fpCreatePipeline(&context->contextDescription.backendInterface,
                                                                                FFX_EFFECT_BRIXELIZER,
                                                                                FFX_BRIXELIZER_PASS_CONTEXT_PREPARE_CLEAR_BRICKS,
@@ -340,7 +342,7 @@ static FfxErrorCode createPipelineStates(FfxBrixelizerRawContext_Private* contex
                                                                                &pipelineDescription,
                                                                                context->effectContextId,
                                                                                &context->pipelineContextPrepareClearBricks));
-    wcscpy_s(pipelineDescription.name, L"FFX_BRIXELIZER_PASS_CONTEXT_COLLECT_DIRTY_BRICKS");
+    strcpy(pipelineDescription.name, "FFX_BRIXELIZER_PASS_CONTEXT_COLLECT_DIRTY_BRICKS");
     FFX_VALIDATE(context->contextDescription.backendInterface.fpCreatePipeline(&context->contextDescription.backendInterface,
                                                                                FFX_EFFECT_BRIXELIZER,
                                                                                FFX_BRIXELIZER_PASS_CONTEXT_COLLECT_DIRTY_BRICKS,
@@ -348,7 +350,7 @@ static FfxErrorCode createPipelineStates(FfxBrixelizerRawContext_Private* contex
                                                                                &pipelineDescription,
                                                                                context->effectContextId,
                                                                                &context->pipelineContextCollectDirtyBricks));
-    wcscpy_s(pipelineDescription.name, L"FFX_BRIXELIZER_PASS_CONTEXT_PREPARE_EIKONAL_ARGS");
+    strcpy(pipelineDescription.name, "FFX_BRIXELIZER_PASS_CONTEXT_PREPARE_EIKONAL_ARGS");
     FFX_VALIDATE(context->contextDescription.backendInterface.fpCreatePipeline(&context->contextDescription.backendInterface,
                                                                                FFX_EFFECT_BRIXELIZER,
                                                                                FFX_BRIXELIZER_PASS_CONTEXT_PREPARE_EIKONAL_ARGS,
@@ -356,7 +358,7 @@ static FfxErrorCode createPipelineStates(FfxBrixelizerRawContext_Private* contex
                                                                                &pipelineDescription,
                                                                                context->effectContextId,
                                                                                &context->pipelineContextPrepareEikonalArgs));
-    wcscpy_s(pipelineDescription.name, L"FFX_BRIXELIZER_PASS_CONTEXT_MERGE_CASCADES");
+    strcpy(pipelineDescription.name, "FFX_BRIXELIZER_PASS_CONTEXT_MERGE_CASCADES");
     FFX_VALIDATE(context->contextDescription.backendInterface.fpCreatePipeline(&context->contextDescription.backendInterface,
                                                                                FFX_EFFECT_BRIXELIZER,
                                                                                FFX_BRIXELIZER_PASS_CONTEXT_MERGE_CASCADES,
@@ -364,7 +366,7 @@ static FfxErrorCode createPipelineStates(FfxBrixelizerRawContext_Private* contex
                                                                                &pipelineDescription,
                                                                                context->effectContextId,
                                                                                &context->pipelineContextMergeCascades));
-    wcscpy_s(pipelineDescription.name, L"FFX_BRIXELIZER_PASS_CONTEXT_PREPARE_MERGE_BRICKS_ARGS");
+    strcpy(pipelineDescription.name, "FFX_BRIXELIZER_PASS_CONTEXT_PREPARE_MERGE_BRICKS_ARGS");
     FFX_VALIDATE(context->contextDescription.backendInterface.fpCreatePipeline(&context->contextDescription.backendInterface,
                                                                                FFX_EFFECT_BRIXELIZER,
                                                                                FFX_BRIXELIZER_PASS_CONTEXT_PREPARE_MERGE_BRICKS_ARGS,
@@ -372,7 +374,7 @@ static FfxErrorCode createPipelineStates(FfxBrixelizerRawContext_Private* contex
                                                                                &pipelineDescription,
                                                                                context->effectContextId,
                                                                                &context->pipelineContextPrepareMergeBricksArgs));
-    wcscpy_s(pipelineDescription.name, L"FFX_BRIXELIZER_PASS_CASCADE_CLEAR_BUILD_COUNTERS");
+    strcpy(pipelineDescription.name, "FFX_BRIXELIZER_PASS_CASCADE_CLEAR_BUILD_COUNTERS");
     FFX_VALIDATE(context->contextDescription.backendInterface.fpCreatePipeline(&context->contextDescription.backendInterface,
                                                                                FFX_EFFECT_BRIXELIZER,
                                                                                FFX_BRIXELIZER_PASS_CASCADE_CLEAR_BUILD_COUNTERS,
@@ -380,7 +382,7 @@ static FfxErrorCode createPipelineStates(FfxBrixelizerRawContext_Private* contex
                                                                                &pipelineDescription,
                                                                                context->effectContextId,
                                                                                &context->pipelineCascadeClearBuildCounters));
-    wcscpy_s(pipelineDescription.name, L"FFX_BRIXELIZER_PASS_CASCADE_RESET_CASCADE");
+    strcpy(pipelineDescription.name, "FFX_BRIXELIZER_PASS_CASCADE_RESET_CASCADE");
     FFX_VALIDATE(context->contextDescription.backendInterface.fpCreatePipeline(&context->contextDescription.backendInterface,
                                                                                FFX_EFFECT_BRIXELIZER,
                                                                                FFX_BRIXELIZER_PASS_CASCADE_RESET_CASCADE,
@@ -388,7 +390,7 @@ static FfxErrorCode createPipelineStates(FfxBrixelizerRawContext_Private* contex
                                                                                &pipelineDescription,
                                                                                context->effectContextId,
                                                                                &context->pipelineCascadeResetCascade));
-    wcscpy_s(pipelineDescription.name, L"FFX_BRIXELIZER_PASS_CASCADE_SCROLL_CASCADE");
+    strcpy(pipelineDescription.name, "FFX_BRIXELIZER_PASS_CASCADE_SCROLL_CASCADE");
     FFX_VALIDATE(context->contextDescription.backendInterface.fpCreatePipeline(&context->contextDescription.backendInterface,
                                                                                FFX_EFFECT_BRIXELIZER,
                                                                                FFX_BRIXELIZER_PASS_CASCADE_SCROLL_CASCADE,
@@ -396,7 +398,7 @@ static FfxErrorCode createPipelineStates(FfxBrixelizerRawContext_Private* contex
                                                                                &pipelineDescription,
                                                                                context->effectContextId,
                                                                                &context->pipelineCascadeScrollCascade));
-    wcscpy_s(pipelineDescription.name, L"FFX_BRIXELIZER_PASS_CASCADE_CLEAR_REF_COUNTERS");
+    strcpy(pipelineDescription.name, "FFX_BRIXELIZER_PASS_CASCADE_CLEAR_REF_COUNTERS");
     FFX_VALIDATE(context->contextDescription.backendInterface.fpCreatePipeline(&context->contextDescription.backendInterface,
                                                                                FFX_EFFECT_BRIXELIZER,
                                                                                FFX_BRIXELIZER_PASS_CASCADE_CLEAR_REF_COUNTERS,
@@ -404,7 +406,7 @@ static FfxErrorCode createPipelineStates(FfxBrixelizerRawContext_Private* contex
                                                                                &pipelineDescription,
                                                                                context->effectContextId,
                                                                                &context->pipelineCascadeClearRefCounters));
-    wcscpy_s(pipelineDescription.name, L"FFX_BRIXELIZER_PASS_CASCADE_CLEAR_JOB_COUNTER");
+    strcpy(pipelineDescription.name, "FFX_BRIXELIZER_PASS_CASCADE_CLEAR_JOB_COUNTER");
     FFX_VALIDATE(context->contextDescription.backendInterface.fpCreatePipeline(&context->contextDescription.backendInterface,
                                                                                FFX_EFFECT_BRIXELIZER,
                                                                                FFX_BRIXELIZER_PASS_CASCADE_CLEAR_JOB_COUNTER,
@@ -412,7 +414,7 @@ static FfxErrorCode createPipelineStates(FfxBrixelizerRawContext_Private* contex
                                                                                &pipelineDescription,
                                                                                context->effectContextId,
                                                                                &context->pipelineCascadeClearJobCounter));
-    wcscpy_s(pipelineDescription.name, L"FFX_BRIXELIZER_PASS_CASCADE_INVALIDATE_JOB_AREAS");
+    strcpy(pipelineDescription.name, "FFX_BRIXELIZER_PASS_CASCADE_INVALIDATE_JOB_AREAS");
     FFX_VALIDATE(context->contextDescription.backendInterface.fpCreatePipeline(&context->contextDescription.backendInterface,
                                                                                FFX_EFFECT_BRIXELIZER,
                                                                                FFX_BRIXELIZER_PASS_CASCADE_INVALIDATE_JOB_AREAS,
@@ -420,7 +422,7 @@ static FfxErrorCode createPipelineStates(FfxBrixelizerRawContext_Private* contex
                                                                                &pipelineDescription,
                                                                                context->effectContextId,
                                                                                &context->pipelineCascadeInvalidateJobAreas));
-    wcscpy_s(pipelineDescription.name, L"FFX_BRIXELIZER_PASS_CASCADE_COARSE_CULLING");
+    strcpy(pipelineDescription.name, "FFX_BRIXELIZER_PASS_CASCADE_COARSE_CULLING");
     FFX_VALIDATE(context->contextDescription.backendInterface.fpCreatePipeline(&context->contextDescription.backendInterface,
                                                                                FFX_EFFECT_BRIXELIZER,
                                                                                FFX_BRIXELIZER_PASS_CASCADE_COARSE_CULLING,
@@ -428,7 +430,7 @@ static FfxErrorCode createPipelineStates(FfxBrixelizerRawContext_Private* contex
                                                                                &pipelineDescription,
                                                                                context->effectContextId,
                                                                                &context->pipelineCascadeCoarseCulling));
-    wcscpy_s(pipelineDescription.name, L"FFX_BRIXELIZER_PASS_CASCADE_SCAN_JOBS");
+    strcpy(pipelineDescription.name, "FFX_BRIXELIZER_PASS_CASCADE_SCAN_JOBS");
     FFX_VALIDATE(context->contextDescription.backendInterface.fpCreatePipeline(&context->contextDescription.backendInterface,
                                                                                FFX_EFFECT_BRIXELIZER,
                                                                                FFX_BRIXELIZER_PASS_CASCADE_SCAN_JOBS,
@@ -436,7 +438,7 @@ static FfxErrorCode createPipelineStates(FfxBrixelizerRawContext_Private* contex
                                                                                &pipelineDescription,
                                                                                context->effectContextId,
                                                                                &context->pipelineCascadeScanJobs));
-    wcscpy_s(pipelineDescription.name, L"FFX_BRIXELIZER_PASS_CASCADE_SCAN_REFERENCES");
+    strcpy(pipelineDescription.name, "FFX_BRIXELIZER_PASS_CASCADE_SCAN_REFERENCES");
     FFX_VALIDATE(context->contextDescription.backendInterface.fpCreatePipeline(&context->contextDescription.backendInterface,
                                                                                FFX_EFFECT_BRIXELIZER,
                                                                                FFX_BRIXELIZER_PASS_CASCADE_SCAN_REFERENCES,
@@ -444,7 +446,7 @@ static FfxErrorCode createPipelineStates(FfxBrixelizerRawContext_Private* contex
                                                                                &pipelineDescription,
                                                                                context->effectContextId,
                                                                                &context->pipelineCascadeScanReferences));
-    wcscpy_s(pipelineDescription.name, L"FFX_BRIXELIZER_PASS_CASCADE_INITIALIZE_CASCADE");
+    strcpy(pipelineDescription.name, "FFX_BRIXELIZER_PASS_CASCADE_INITIALIZE_CASCADE");
     FFX_VALIDATE(context->contextDescription.backendInterface.fpCreatePipeline(&context->contextDescription.backendInterface,
                                                                                FFX_EFFECT_BRIXELIZER,
                                                                                FFX_BRIXELIZER_PASS_CASCADE_INITIALIZE_CASCADE,
@@ -452,7 +454,7 @@ static FfxErrorCode createPipelineStates(FfxBrixelizerRawContext_Private* contex
                                                                                &pipelineDescription,
                                                                                context->effectContextId,
                                                                                &context->pipelineCascadeInitializeCascade));
-    wcscpy_s(pipelineDescription.name, L"FFX_BRIXELIZER_PASS_CASCADE_BUILD_TREE_AABB");
+    strcpy(pipelineDescription.name, "FFX_BRIXELIZER_PASS_CASCADE_BUILD_TREE_AABB");
     FFX_VALIDATE(context->contextDescription.backendInterface.fpCreatePipeline(&context->contextDescription.backendInterface,
                                                                                FFX_EFFECT_BRIXELIZER,
                                                                                FFX_BRIXELIZER_PASS_CASCADE_BUILD_TREE_AABB,
@@ -460,7 +462,7 @@ static FfxErrorCode createPipelineStates(FfxBrixelizerRawContext_Private* contex
                                                                                &pipelineDescription,
                                                                                context->effectContextId,
                                                                                &context->pipelineCascadeBuildTreeAABB));
-    wcscpy_s(pipelineDescription.name, L"FFX_BRIXELIZER_PASS_CASCADE_FREE_CASCADE");
+    strcpy(pipelineDescription.name, "FFX_BRIXELIZER_PASS_CASCADE_FREE_CASCADE");
     FFX_VALIDATE(context->contextDescription.backendInterface.fpCreatePipeline(&context->contextDescription.backendInterface,
                                                                                FFX_EFFECT_BRIXELIZER,
                                                                                FFX_BRIXELIZER_PASS_CASCADE_FREE_CASCADE,
@@ -470,7 +472,7 @@ static FfxErrorCode createPipelineStates(FfxBrixelizerRawContext_Private* contex
                                                                                &context->pipelineCascadeFreeCascade));
     pipelineDescription.samplerCount = samplerCount;
     pipelineDescription.samplers     = samplers;
-    wcscpy_s(pipelineDescription.name, L"FFX_BRIXELIZER_PASS_DEBUG_VISUALIZATION");
+    strcpy(pipelineDescription.name, "FFX_BRIXELIZER_PASS_DEBUG_VISUALIZATION");
     FFX_VALIDATE(context->contextDescription.backendInterface.fpCreatePipeline(&context->contextDescription.backendInterface,
                                                                                FFX_EFFECT_BRIXELIZER,
                                                                                FFX_BRIXELIZER_PASS_DEBUG_VISUALIZATION,
@@ -478,7 +480,7 @@ static FfxErrorCode createPipelineStates(FfxBrixelizerRawContext_Private* contex
                                                                                &pipelineDescription,
                                                                                context->effectContextId,
                                                                                &context->pipelineDebugVisualization));
-    wcscpy_s(pipelineDescription.name, L"FFX_BRIXELIZER_PASS_DEBUG_INSTANCE_AABBS");
+    strcpy(pipelineDescription.name, "FFX_BRIXELIZER_PASS_DEBUG_INSTANCE_AABBS");
     FFX_VALIDATE(context->contextDescription.backendInterface.fpCreatePipeline(&context->contextDescription.backendInterface,
                                                                                FFX_EFFECT_BRIXELIZER,
                                                                                FFX_BRIXELIZER_PASS_DEBUG_INSTANCE_AABBS,
@@ -486,7 +488,7 @@ static FfxErrorCode createPipelineStates(FfxBrixelizerRawContext_Private* contex
                                                                                &pipelineDescription,
                                                                                context->effectContextId,
                                                                                &context->pipelineDebugInstanceAABBs));
-    wcscpy_s(pipelineDescription.name, L"FFX_BRIXELIZER_PASS_DEBUG_DRAW_AABB_TREE");
+    strcpy(pipelineDescription.name, "FFX_BRIXELIZER_PASS_DEBUG_DRAW_AABB_TREE");
     FFX_VALIDATE(context->contextDescription.backendInterface.fpCreatePipeline(&context->contextDescription.backendInterface,
                                                                                FFX_EFFECT_BRIXELIZER,
                                                                                FFX_BRIXELIZER_PASS_DEBUG_AABB_TREE,
@@ -495,7 +497,7 @@ static FfxErrorCode createPipelineStates(FfxBrixelizerRawContext_Private* contex
                                                                                context->effectContextId,
                                                                                &context->pipelineDebugDrawAABBTree));
     pipelineDescription.indirectWorkload = 1;
-    wcscpy_s(pipelineDescription.name, L"FFX_BRIXELIZER_PASS_CONTEXT_CLEAR_BRICK");
+    strcpy(pipelineDescription.name, "FFX_BRIXELIZER_PASS_CONTEXT_CLEAR_BRICK");
     FFX_VALIDATE(context->contextDescription.backendInterface.fpCreatePipeline(&context->contextDescription.backendInterface,
                                                                                FFX_EFFECT_BRIXELIZER,
                                                                                FFX_BRIXELIZER_PASS_CONTEXT_CLEAR_BRICK,
@@ -503,7 +505,7 @@ static FfxErrorCode createPipelineStates(FfxBrixelizerRawContext_Private* contex
                                                                                &pipelineDescription,
                                                                                context->effectContextId,
                                                                                &context->pipelineContextClearBrick));
-    wcscpy_s(pipelineDescription.name, L"FFX_BRIXELIZER_PASS_CONTEXT_EIKONAL");
+    strcpy(pipelineDescription.name, "FFX_BRIXELIZER_PASS_CONTEXT_EIKONAL");
     FFX_VALIDATE(context->contextDescription.backendInterface.fpCreatePipeline(&context->contextDescription.backendInterface,
                                                                                FFX_EFFECT_BRIXELIZER,
                                                                                FFX_BRIXELIZER_PASS_CONTEXT_EIKONAL,
@@ -511,7 +513,7 @@ static FfxErrorCode createPipelineStates(FfxBrixelizerRawContext_Private* contex
                                                                                &pipelineDescription,
                                                                                context->effectContextId,
                                                                                &context->pipelineContextEikonal));
-    wcscpy_s(pipelineDescription.name, L"FFX_BRIXELIZER_PASS_CASCADE_VOXELIZE");
+    strcpy(pipelineDescription.name, "FFX_BRIXELIZER_PASS_CASCADE_VOXELIZE");
     FFX_VALIDATE(context->contextDescription.backendInterface.fpCreatePipeline(&context->contextDescription.backendInterface,
                                                                                FFX_EFFECT_BRIXELIZER,
                                                                                FFX_BRIXELIZER_PASS_CASCADE_VOXELIZE,
@@ -519,7 +521,7 @@ static FfxErrorCode createPipelineStates(FfxBrixelizerRawContext_Private* contex
                                                                                &pipelineDescription,
                                                                                context->effectContextId,
                                                                                &context->pipelineCascadeVoxelize));
-    wcscpy_s(pipelineDescription.name, L"FFX_BRIXELIZER_PASS_CASCADE_COMPACT_REFERENCES");
+    strcpy(pipelineDescription.name, "FFX_BRIXELIZER_PASS_CASCADE_COMPACT_REFERENCES");
     FFX_VALIDATE(context->contextDescription.backendInterface.fpCreatePipeline(&context->contextDescription.backendInterface,
                                                                                FFX_EFFECT_BRIXELIZER,
                                                                                FFX_BRIXELIZER_PASS_CASCADE_COMPACT_REFERENCES,
@@ -527,7 +529,7 @@ static FfxErrorCode createPipelineStates(FfxBrixelizerRawContext_Private* contex
                                                                                &pipelineDescription,
                                                                                context->effectContextId,
                                                                                &context->pipelineCascadeCompactReferences));
-    wcscpy_s(pipelineDescription.name, L"FFX_BRIXELIZER_PASS_CASCADE_CLEAR_BRICK_STORAGE");
+    strcpy(pipelineDescription.name, "FFX_BRIXELIZER_PASS_CASCADE_CLEAR_BRICK_STORAGE");
     FFX_VALIDATE(context->contextDescription.backendInterface.fpCreatePipeline(&context->contextDescription.backendInterface,
                                                                                FFX_EFFECT_BRIXELIZER,
                                                                                FFX_BRIXELIZER_PASS_CASCADE_CLEAR_BRICK_STORAGE,
@@ -535,7 +537,7 @@ static FfxErrorCode createPipelineStates(FfxBrixelizerRawContext_Private* contex
                                                                                &pipelineDescription,
                                                                                context->effectContextId,
                                                                                &context->pipelineCascadeClearBrickStorage));
-    wcscpy_s(pipelineDescription.name, L"FFX_BRIXELIZER_PASS_CASCADE_EMIT_SDF");
+    strcpy(pipelineDescription.name, "FFX_BRIXELIZER_PASS_CASCADE_EMIT_SDF");
     FFX_VALIDATE(context->contextDescription.backendInterface.fpCreatePipeline(&context->contextDescription.backendInterface,
                                                                                FFX_EFFECT_BRIXELIZER,
                                                                                FFX_BRIXELIZER_PASS_CASCADE_EMIT_SDF,
@@ -543,7 +545,7 @@ static FfxErrorCode createPipelineStates(FfxBrixelizerRawContext_Private* contex
                                                                                &pipelineDescription,
                                                                                context->effectContextId,
                                                                                &context->pipelineCascadeEmitSDF));
-    wcscpy_s(pipelineDescription.name, L"FFX_BRIXELIZER_PASS_CASCADE_COMPRESS_BRICK");
+    strcpy(pipelineDescription.name, "FFX_BRIXELIZER_PASS_CASCADE_COMPRESS_BRICK");
     FFX_VALIDATE(context->contextDescription.backendInterface.fpCreatePipeline(&context->contextDescription.backendInterface,
                                                                                FFX_EFFECT_BRIXELIZER,
                                                                                FFX_BRIXELIZER_PASS_CASCADE_COMPRESS_BRICK,
@@ -551,7 +553,7 @@ static FfxErrorCode createPipelineStates(FfxBrixelizerRawContext_Private* contex
                                                                                &pipelineDescription,
                                                                                context->effectContextId,
                                                                                &context->pipelineCascadeCompressBrick));
-    wcscpy_s(pipelineDescription.name, L"FFX_BRIXELIZER_PASS_CONTEXT_MERGE_BRICKS");
+    strcpy(pipelineDescription.name, "FFX_BRIXELIZER_PASS_CONTEXT_MERGE_BRICKS");
     FFX_VALIDATE(context->contextDescription.backendInterface.fpCreatePipeline(&context->contextDescription.backendInterface,
                                                                                FFX_EFFECT_BRIXELIZER,
                                                                                FFX_BRIXELIZER_PASS_CONTEXT_MERGE_BRICKS,
@@ -606,7 +608,7 @@ static void scheduleDispatchInternal(FfxBrixelizerRawContext_Private*   context,
 {
     context->gpuJobDescription = {FFX_GPU_JOB_COMPUTE};
 
-    wcscpy_s(context->gpuJobDescription.jobLabel, pipeline->name);
+    strcpy(context->gpuJobDescription.jobLabel, pipeline->name);
     
     FFX_ASSERT(pipeline->srvTextureCount < FFX_MAX_NUM_SRVS);
 
@@ -619,7 +621,7 @@ static void scheduleDispatchInternal(FfxBrixelizerRawContext_Private*   context,
         context->gpuJobDescription.computeJobDescriptor.srvTextures[currentShaderResourceViewIndex].resource = currentResource;
 
 #ifdef FFX_DEBUG
-        wcscpy_s(context->gpuJobDescription.computeJobDescriptor.srvTextures[currentShaderResourceViewIndex].name, pipeline->srvTextureBindings[currentShaderResourceViewIndex].name);
+        strcpy(context->gpuJobDescription.computeJobDescriptor.srvTextures[currentShaderResourceViewIndex].name, pipeline->srvTextureBindings[currentShaderResourceViewIndex].name);
 #endif
     }
 
@@ -636,7 +638,7 @@ static void scheduleDispatchInternal(FfxBrixelizerRawContext_Private*   context,
         context->gpuJobDescription.computeJobDescriptor.srvBuffers[currentShaderResourceViewIndex].size     = srvInfo.size;
         context->gpuJobDescription.computeJobDescriptor.srvBuffers[currentShaderResourceViewIndex].stride   = srvInfo.stride;
 #ifdef FFX_DEBUG
-        wcscpy_s(context->gpuJobDescription.computeJobDescriptor.srvBuffers[currentShaderResourceViewIndex].name, pipeline->srvBufferBindings[currentShaderResourceViewIndex].name);
+        strcpy(context->gpuJobDescription.computeJobDescriptor.srvBuffers[currentShaderResourceViewIndex].name, pipeline->srvBufferBindings[currentShaderResourceViewIndex].name);
 #endif
     }
 
@@ -651,7 +653,7 @@ static void scheduleDispatchInternal(FfxBrixelizerRawContext_Private*   context,
         context->gpuJobDescription.computeJobDescriptor.uavTextures[currentUnorderedAccessViewIndex].resource = currentResource;
         context->gpuJobDescription.computeJobDescriptor.uavTextures[currentUnorderedAccessViewIndex].mip      = 0;
 #ifdef FFX_DEBUG
-        wcscpy_s(context->gpuJobDescription.computeJobDescriptor.uavTextures[currentUnorderedAccessViewIndex].name, pipeline->uavTextureBindings[currentUnorderedAccessViewIndex].name);
+        strcpy(context->gpuJobDescription.computeJobDescriptor.uavTextures[currentUnorderedAccessViewIndex].name, pipeline->uavTextureBindings[currentUnorderedAccessViewIndex].name);
 #endif
     }
 
@@ -669,7 +671,7 @@ static void scheduleDispatchInternal(FfxBrixelizerRawContext_Private*   context,
         context->gpuJobDescription.computeJobDescriptor.uavBuffers[currentUnorderedAccessViewIndex].size     = context->uavInfo[currentResourceId].size;
         context->gpuJobDescription.computeJobDescriptor.uavBuffers[currentUnorderedAccessViewIndex].stride   = context->uavInfo[currentResourceId].stride;
 #ifdef FFX_DEBUG
-        wcscpy_s(context->gpuJobDescription.computeJobDescriptor.uavBuffers[currentUnorderedAccessViewIndex].name, pipeline->uavBufferBindings[currentUnorderedAccessViewIndex].name);
+        strcpy(context->gpuJobDescription.computeJobDescriptor.uavBuffers[currentUnorderedAccessViewIndex].name, pipeline->uavBufferBindings[currentUnorderedAccessViewIndex].name);
 #endif
     }
 
@@ -691,7 +693,7 @@ static void scheduleDispatchInternal(FfxBrixelizerRawContext_Private*   context,
 
         context->gpuJobDescription.computeJobDescriptor.cbs[currentConstantBufferViewIndex] = context->constantBuffers[cbvInfoIdx];
 #ifdef FFX_DEBUG
-        wcscpy_s(context->gpuJobDescription.computeJobDescriptor.cbNames[currentConstantBufferViewIndex], pipeline->constantBufferBindings[currentConstantBufferViewIndex].name);
+        strcpy(context->gpuJobDescription.computeJobDescriptor.cbNames[currentConstantBufferViewIndex], pipeline->constantBufferBindings[currentConstantBufferViewIndex].name);
 #endif
     }
 
@@ -705,11 +707,11 @@ static void scheduleDispatchInternal(FfxBrixelizerRawContext_Private*   context,
     context->contextDescription.backendInterface.fpScheduleGpuJob(&context->contextDescription.backendInterface, &context->gpuJobDescription);
 }
 
-static void scheduleCopy(FfxBrixelizerRawContext_Private* context, FfxResourceInternal src, uint32_t srcOffset, FfxResourceInternal dst, uint32_t dstOffset, uint32_t size, const wchar_t* name)
+static void scheduleCopy(FfxBrixelizerRawContext_Private* context, FfxResourceInternal src, uint32_t srcOffset, FfxResourceInternal dst, uint32_t dstOffset, uint32_t size, const char* name)
 {
     context->gpuJobDescription = {FFX_GPU_JOB_COPY};
 
-    wcscpy_s(context->gpuJobDescription.jobLabel, name);
+    strcpy(context->gpuJobDescription.jobLabel, name);
     
     context->gpuJobDescription.copyJobDescriptor.src       = src;
     context->gpuJobDescription.copyJobDescriptor.srcOffset = srcOffset;
@@ -918,7 +920,7 @@ static FfxErrorCode brixelizerCreate(FfxBrixelizerRawContext_Private* context, c
     {
         const FfxInternalResourceDescription internalSurfaceDesc[] = {
             {FFX_BRIXELIZER_RESOURCE_IDENTIFIER_INSTANCE_INFO_BUFFER,
-             L"Brixelizer_InstanceBuffer",
+             "Brixelizer_InstanceBuffer",
              FFX_RESOURCE_TYPE_BUFFER,
              FFX_RESOURCE_USAGE_UAV,
              FFX_SURFACE_FORMAT_R32_FLOAT,
@@ -927,7 +929,7 @@ static FfxErrorCode brixelizerCreate(FfxBrixelizerRawContext_Private* context, c
              1,
              FFX_RESOURCE_FLAGS_NONE},
             {FFX_BRIXELIZER_RESOURCE_IDENTIFIER_INSTANCE_TRANSFORM_BUFFER,
-             L"Brixelizer_TransformBuffer",
+             "Brixelizer_TransformBuffer",
              FFX_RESOURCE_TYPE_BUFFER,
              FFX_RESOURCE_USAGE_UAV,
              FFX_SURFACE_FORMAT_R32_FLOAT,
@@ -936,7 +938,7 @@ static FfxErrorCode brixelizerCreate(FfxBrixelizerRawContext_Private* context, c
              1,
              FFX_RESOURCE_FLAGS_NONE},
             {FFX_BRIXELIZER_RESOURCE_IDENTIFIER_INDIRECT_ARGS_1,
-             L"Brixelizer_IndirectArgs1",
+             "Brixelizer_IndirectArgs1",
              FFX_RESOURCE_TYPE_BUFFER,
              FfxResourceUsage(FFX_RESOURCE_USAGE_UAV | FFX_RESOURCE_USAGE_INDIRECT),
              FFX_SURFACE_FORMAT_R32_FLOAT,
@@ -945,7 +947,7 @@ static FfxErrorCode brixelizerCreate(FfxBrixelizerRawContext_Private* context, c
              1,
              FFX_RESOURCE_FLAGS_NONE},
             {FFX_BRIXELIZER_RESOURCE_IDENTIFIER_CONTEXT_BRICKS_VOXEL_MAP,
-             L"Brixelizer_BrickVoxelMap",
+             "Brixelizer_BrickVoxelMap",
              FFX_RESOURCE_TYPE_BUFFER,
              FFX_RESOURCE_USAGE_UAV,
              FFX_SURFACE_FORMAT_R32_FLOAT,
@@ -954,7 +956,7 @@ static FfxErrorCode brixelizerCreate(FfxBrixelizerRawContext_Private* context, c
              1,
              FFX_RESOURCE_FLAGS_NONE},
             {FFX_BRIXELIZER_RESOURCE_IDENTIFIER_CONTEXT_BRICKS_FREE_LIST,
-             L"Brixelizer_BrickFreeList",
+             "Brixelizer_BrickFreeList",
              FFX_RESOURCE_TYPE_BUFFER,
              FFX_RESOURCE_USAGE_UAV,
              FFX_SURFACE_FORMAT_R32_FLOAT,
@@ -963,7 +965,7 @@ static FfxErrorCode brixelizerCreate(FfxBrixelizerRawContext_Private* context, c
              1,
              FFX_RESOURCE_FLAGS_NONE},
             {FFX_BRIXELIZER_RESOURCE_IDENTIFIER_CONTEXT_BRICKS_CLEAR_LIST,
-             L"Brixelizer_BrickClearList",
+             "Brixelizer_BrickClearList",
              FFX_RESOURCE_TYPE_BUFFER,
              FFX_RESOURCE_USAGE_UAV,
              FFX_SURFACE_FORMAT_R32_FLOAT,
@@ -972,7 +974,7 @@ static FfxErrorCode brixelizerCreate(FfxBrixelizerRawContext_Private* context, c
              1,
              FFX_RESOURCE_FLAGS_NONE},
             {FFX_BRIXELIZER_RESOURCE_IDENTIFIER_CONTEXT_BRICKS_EIKONAL_LIST,
-             L"Brixelizer_BrickEikonalList",
+             "Brixelizer_BrickEikonalList",
              FFX_RESOURCE_TYPE_BUFFER,
              FFX_RESOURCE_USAGE_UAV,
              FFX_SURFACE_FORMAT_R32_FLOAT,
@@ -981,7 +983,7 @@ static FfxErrorCode brixelizerCreate(FfxBrixelizerRawContext_Private* context, c
              1,
              FFX_RESOURCE_FLAGS_NONE},
             { FFX_BRIXELIZER_RESOURCE_IDENTIFIER_CONTEXT_BRICKS_MERGE_LIST,
-             L"Brixelizer_BrickMergeList",
+             "Brixelizer_BrickMergeList",
              FFX_RESOURCE_TYPE_BUFFER,
              FFX_RESOURCE_USAGE_UAV,
              FFX_SURFACE_FORMAT_R32_FLOAT,
@@ -990,7 +992,7 @@ static FfxErrorCode brixelizerCreate(FfxBrixelizerRawContext_Private* context, c
              1,
              FFX_RESOURCE_FLAGS_NONE },
             { FFX_BRIXELIZER_RESOURCE_IDENTIFIER_CONTEXT_BRICKS_EIKONAL_COUNTERS,
-             L"Brixelizer_BrickEikonalCounters",
+             "Brixelizer_BrickEikonalCounters",
              FFX_RESOURCE_TYPE_BUFFER,
              FFX_RESOURCE_USAGE_UAV,
              FFX_SURFACE_FORMAT_R32_FLOAT,
@@ -999,7 +1001,7 @@ static FfxErrorCode brixelizerCreate(FfxBrixelizerRawContext_Private* context, c
              1,
              FFX_RESOURCE_FLAGS_NONE },
             { FFX_BRIXELIZER_RESOURCE_IDENTIFIER_CONTEXT_COUNTERS,
-             L"Brixelizer_Counters",
+             "Brixelizer_Counters",
              FFX_RESOURCE_TYPE_BUFFER,
              FFX_RESOURCE_USAGE_UAV,
              FFX_SURFACE_FORMAT_R32_FLOAT,
@@ -1069,7 +1071,7 @@ static FfxErrorCode brixelizerCreate(FfxBrixelizerRawContext_Private* context, c
         const uint32_t ids[]   = {FFX_BRIXELIZER_RESOURCE_IDENTIFIER_CONTEXT_COUNTERS_READBACK_0,
                                 FFX_BRIXELIZER_RESOURCE_IDENTIFIER_CONTEXT_COUNTERS_READBACK_1,
                                 FFX_BRIXELIZER_RESOURCE_IDENTIFIER_CONTEXT_COUNTERS_READBACK_2};
-        const wchar_t* names[] = {L"Brixelizer_CountersReadback0", L"Brixelizer_CountersReadback1", L"Brixelizer_CountersReadback2"};
+        const char* names[] = {"Brixelizer_CountersReadback0", "Brixelizer_CountersReadback1", "Brixelizer_CountersReadback2"};
 
         for (int32_t currentBufferIndex = 0; currentBufferIndex < FFX_ARRAY_ELEMENTS(ids); ++currentBufferIndex)
         {
@@ -1341,7 +1343,7 @@ static FfxErrorCode brixelizerDispatchEnd(FfxBrixelizerRawContext_Private* conte
                      counterReadbackBuffers[context->frameIndex % 3],
                      0,
                      sizeof(FfxBrixelizerDebugCounters),
-                     L"Copy Debug Counters");
+                     "Copy Debug Counters");
     }
 
     return FFX_OK;
@@ -1552,7 +1554,7 @@ static FfxErrorCode brixelizerDispatchUpdateCascade(FfxBrixelizerRawContext_Priv
                      context->resources[readbackBufferResourceID],
                      0,
                      sizeof(FfxBrixelizerScratchCounters),
-                     L"Copy Scratch Counters");
+                     "Copy Scratch Counters");
 
         context->cascadeCounterPositions[cascade->info.index] = (cascadeCounterPos + 1) % 3;
     }
@@ -1714,7 +1716,7 @@ static void brixelizerFlushInstances(FfxBrixelizerRawContext_Private* context, F
                      context->resources[FFX_BRIXELIZER_RESOURCE_IDENTIFIER_INSTANCE_INFO_BUFFER],
                      idx * sizeof(FfxBrixelizerInstanceInfo),
                      sizeof(FfxBrixelizerInstanceInfo),
-                     L"Instance Info");
+                     "Instance Info");
 
         scheduleCopy(context,
                      context->resources[FFX_BRIXELIZER_RESOURCE_IDENTIFIER_UPLOAD_INSTANCE_TRANSFORM_BUFFER],
@@ -1722,7 +1724,7 @@ static void brixelizerFlushInstances(FfxBrixelizerRawContext_Private* context, F
                      context->resources[FFX_BRIXELIZER_RESOURCE_IDENTIFIER_INSTANCE_TRANSFORM_BUFFER],
                      idx * sizeof(FfxFloat32x3x4),
                      sizeof(FfxFloat32x3x4),
-                     L"Instance Transform");
+                     "Instance Transform");
 
         context->contextDescription.backendInterface.fpExecuteGpuJobs(&context->contextDescription.backendInterface, cmdList, context->effectContextId);
     }
@@ -1816,8 +1818,8 @@ FfxErrorCode ffxBrixelizerRawContextCreateCascade(FfxBrixelizerRawContext* conte
     if (contextPrivate->contextDescription.flags & FFX_BRIXELIZER_CONTEXT_FLAG_DEBUG_CASCADE_READBACK_BUFFERS)
     {
         for (uint32_t i = 0; i < 3; ++i) {
-            wchar_t readbackBufferName[64] = {};
-            swprintf(readbackBufferName, FFX_ARRAY_ELEMENTS(readbackBufferName), L"Brixelizer_CascadeReadbackBuffer%u_%u", i, cascadePrivate->info.index);
+            char readbackBufferName[64] = {};
+            snprintf(readbackBufferName, FFX_ARRAY_ELEMENTS(readbackBufferName), "Brixelizer_CascadeReadbackBuffer%u_%u", i, cascadePrivate->info.index);
 
             uint32_t readbackBufferID = getCascadeReadbackBufferID(cascadePrivate->info.index, i);
             uint32_t readbackBufferResourceID = getCascadeReadbackBufferResourceID(cascadePrivate->info.index, i);
diff --git a/sdk/src/components/brixelizer/ffx_brixelizer_raw_private.h b/sdk/src/components/brixelizer/ffx_brixelizer_raw_private.h
index f52fe1b..90cc161 100644
--- a/sdk/src/components/brixelizer/ffx_brixelizer_raw_private.h
+++ b/sdk/src/components/brixelizer/ffx_brixelizer_raw_private.h
@@ -92,17 +92,17 @@ typedef struct FfxBrixelizerUploadBufferMetaData {
     uint32_t          id;
     FfxResourceUsage  usage;
     FfxResourceStates state;
-    const wchar_t    *name;
+    const char       *name;
 } FfxBrixelizerUploadBufferMetaData;
 
 #define ALIGN_UP_256(val) ((val + 255) & ~(255))
 
 static const FfxBrixelizerUploadBufferMetaData uploadBufferMetaData[] = {
-    { FFX_BRIXELIZER_MAX_INSTANCES * FFX_BRIXELIZER_NUM_IN_FLIGHT_FRAMES * sizeof(FfxBrixelizerInstanceInfo),     sizeof(FfxBrixelizerInstanceInfo),     FFX_BRIXELIZER_RESOURCE_IDENTIFIER_UPLOAD_INSTANCE_INFO_BUFFER,      FFX_RESOURCE_USAGE_UAV, FFX_RESOURCE_STATE_COPY_SRC,     L"Brixelizer_UploadInstanceBuffer"        },
-    { FFX_BRIXELIZER_MAX_INSTANCES * FFX_BRIXELIZER_NUM_IN_FLIGHT_FRAMES * sizeof(FfxFloat32x3x4),                sizeof(FfxFloat32x4),                  FFX_BRIXELIZER_RESOURCE_IDENTIFIER_UPLOAD_INSTANCE_TRANSFORM_BUFFER, FFX_RESOURCE_USAGE_UAV, FFX_RESOURCE_STATE_COPY_SRC,     L"Brixelizer_UploadTransformBuffer"       },
-    { FFX_BRIXELIZER_MAX_INSTANCES * FFX_BRIXELIZER_NUM_IN_FLIGHT_FRAMES * sizeof(FfxBrixelizerBrixelizationJob), sizeof(FfxBrixelizerBrixelizationJob), FFX_BRIXELIZER_RESOURCE_IDENTIFIER_UPLOAD_JOB_BUFFER,                FFX_RESOURCE_USAGE_UAV, FFX_RESOURCE_STATE_GENERIC_READ, L"Brixelizer_UploadJobBuffer"             },
-    { FFX_BRIXELIZER_MAX_INSTANCES * FFX_BRIXELIZER_NUM_IN_FLIGHT_FRAMES * sizeof(uint32_t),                      sizeof(uint32_t),                      FFX_BRIXELIZER_RESOURCE_IDENTIFIER_UPLOAD_JOB_INDEX_BUFFER,          FFX_RESOURCE_USAGE_UAV, FFX_RESOURCE_STATE_GENERIC_READ, L"Brixelizer_UploadJobIndexBuffer"        },
-    { FFX_BRIXELIZER_MAX_INSTANCES * FFX_BRIXELIZER_NUM_IN_FLIGHT_FRAMES * sizeof(uint32_t),                      sizeof(uint32_t),                      FFX_BRIXELIZER_RESOURCE_IDENTIFIER_UPLOAD_DEBUG_INSTANCE_ID_BUFFER,  FFX_RESOURCE_USAGE_UAV, FFX_RESOURCE_STATE_COPY_SRC,     L"Brixelizer_UploadDebugInstanceIDBuffer" },
+    { FFX_BRIXELIZER_MAX_INSTANCES * FFX_BRIXELIZER_NUM_IN_FLIGHT_FRAMES * sizeof(FfxBrixelizerInstanceInfo),     sizeof(FfxBrixelizerInstanceInfo),     FFX_BRIXELIZER_RESOURCE_IDENTIFIER_UPLOAD_INSTANCE_INFO_BUFFER,      FFX_RESOURCE_USAGE_UAV, FFX_RESOURCE_STATE_COPY_SRC,     "Brixelizer_UploadInstanceBuffer"        },
+    { FFX_BRIXELIZER_MAX_INSTANCES * FFX_BRIXELIZER_NUM_IN_FLIGHT_FRAMES * sizeof(FfxFloat32x3x4),                sizeof(FfxFloat32x4),                  FFX_BRIXELIZER_RESOURCE_IDENTIFIER_UPLOAD_INSTANCE_TRANSFORM_BUFFER, FFX_RESOURCE_USAGE_UAV, FFX_RESOURCE_STATE_COPY_SRC,     "Brixelizer_UploadTransformBuffer"       },
+    { FFX_BRIXELIZER_MAX_INSTANCES * FFX_BRIXELIZER_NUM_IN_FLIGHT_FRAMES * sizeof(FfxBrixelizerBrixelizationJob), sizeof(FfxBrixelizerBrixelizationJob), FFX_BRIXELIZER_RESOURCE_IDENTIFIER_UPLOAD_JOB_BUFFER,                FFX_RESOURCE_USAGE_UAV, FFX_RESOURCE_STATE_GENERIC_READ, "Brixelizer_UploadJobBuffer"             },
+    { FFX_BRIXELIZER_MAX_INSTANCES * FFX_BRIXELIZER_NUM_IN_FLIGHT_FRAMES * sizeof(uint32_t),                      sizeof(uint32_t),                      FFX_BRIXELIZER_RESOURCE_IDENTIFIER_UPLOAD_JOB_INDEX_BUFFER,          FFX_RESOURCE_USAGE_UAV, FFX_RESOURCE_STATE_GENERIC_READ, "Brixelizer_UploadJobIndexBuffer"        },
+    { FFX_BRIXELIZER_MAX_INSTANCES * FFX_BRIXELIZER_NUM_IN_FLIGHT_FRAMES * sizeof(uint32_t),                      sizeof(uint32_t),                      FFX_BRIXELIZER_RESOURCE_IDENTIFIER_UPLOAD_DEBUG_INSTANCE_ID_BUFFER,  FFX_RESOURCE_USAGE_UAV, FFX_RESOURCE_STATE_COPY_SRC,     "Brixelizer_UploadDebugInstanceIDBuffer" },
 };
 
 #define FFX_BRIXELIZER_NUM_UPLOAD_BUFFERS FFX_ARRAY_ELEMENTS(uploadBufferMetaData)
diff --git a/sdk/src/components/brixelizergi/CMakeLists.txt b/sdk/src/components/brixelizergi/CMakeLists.txt
index 5dfe2b2..4a921d0 100644
--- a/sdk/src/components/brixelizergi/CMakeLists.txt
+++ b/sdk/src/components/brixelizergi/CMakeLists.txt
@@ -41,9 +41,9 @@ if (FFX_BRIXELIZER_GI OR FFX_ALL)
 	if (FFX_BUILD_AS_DLL)
 		# file(GLOB BRIXELIZER_PRIVATE_SOURCES "${FFX_COMPONENTS_PATH}/brixelizer/*.cpp")
 		# list(APPEND PRIVATE_SOURCES "${BRIXELIZER_PRIVATE_SOURCES}")
-		add_library(ffx_brixelizergi_${FFX_PLATFORM_NAME} SHARED ${SHARED_SOURCES} ${PRIVATE_SOURCES} ${PUBLIC_SOURCES})
+		add_library(brixelizergi SHARED ${SHARED_SOURCES} ${PRIVATE_SOURCES} ${PUBLIC_SOURCES})
 	else()
-		add_library(ffx_brixelizergi_${FFX_PLATFORM_NAME} STATIC ${SHARED_SOURCES} ${PRIVATE_SOURCES} ${PUBLIC_SOURCES})
+		add_library(brixelizergi STATIC ${SHARED_SOURCES} ${PRIVATE_SOURCES} ${PUBLIC_SOURCES})
 	endif()
 
 	# API
@@ -52,12 +52,19 @@ if (FFX_BRIXELIZER_GI OR FFX_ALL)
 	source_group("public_source"  FILES ${PUBLIC_SOURCES})
 
 	# Dependencies
-	target_link_libraries(ffx_brixelizergi_${FFX_PLATFORM_NAME} PRIVATE ffx_brixelizer_${FFX_PLATFORM_NAME})
+	target_link_libraries(brixelizergi PRIVATE brixelizer)
 
-	target_include_directories(ffx_brixelizergi_${FFX_PLATFORM_NAME} PUBLIC ${FFX_INCLUDE_PATH})
-	target_include_directories(ffx_brixelizergi_${FFX_PLATFORM_NAME} PUBLIC ${FFX_SHARED_PATH})
+	target_include_directories(brixelizergi PUBLIC
+		$<BUILD_INTERFACE:${FFX_INCLUDE_PATH}>
+		$<INSTALL_INTERFACE:include>)
+	target_include_directories(brixelizergi PRIVATE ${FFX_SHARED_PATH})
 
 	set_source_files_properties(${SHADERS} PROPERTIES HEADER_FILE_ONLY TRUE)
-	set_target_properties(ffx_brixelizergi_${FFX_PLATFORM_NAME} PROPERTIES FOLDER Components)
+	set_target_properties(brixelizergi PROPERTIES FOLDER Components)
+	
+	install(TARGETS brixelizergi EXPORT brixelizergi-targets)
+	install(EXPORT brixelizergi-targets 
+		DESTINATION "${CMAKE_INSTALL_DATADIR}/cmake/${PROJECT_NAME}"
+		NAMESPACE fidelityfx::)
 	
 endif()
\ No newline at end of file
diff --git a/sdk/src/components/brixelizergi/ffx_brixelizergi.cpp b/sdk/src/components/brixelizergi/ffx_brixelizergi.cpp
index ae6c1b0..7d5ae8b 100644
--- a/sdk/src/components/brixelizergi/ffx_brixelizergi.cpp
+++ b/sdk/src/components/brixelizergi/ffx_brixelizergi.cpp
@@ -20,6 +20,9 @@
 // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 // THE SOFTWARE.
 
+#include <array>
+#include <cstring>
+
 #include <FidelityFX/host/ffx_brixelizergi.h>
 
 #define FFX_CPU
@@ -36,83 +39,83 @@
 typedef struct ResourceBinding
 {
     uint32_t index;
-    wchar_t  name[64];
+    char     name[64];
 } ResourceBinding;
 
 static const ResourceBinding srvResourceBindingTable[] = {
-    {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_DISOCCLUSION_MASK, L"g_r_disocclusion_mask"},
-    {FFX_BRIXELIZER_GI_PING_PONG_RESOURCE_STATIC_GI_TARGET_READ, L"g_sdfgi_r_static_gitarget"},
-    {FFX_BRIXELIZER_GI_PING_PONG_RESOURCE_STATIC_SCREEN_PROBES_READ, L"g_sdfgi_r_static_screen_probes"},
-    {FFX_BRIXELIZER_GI_PING_PONG_RESOURCE_STATIC_SPECULAR_TARGET_READ, L"g_sdfgi_r_specular_target"},
-    {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_RADIANCE_CACHE, L"g_bctx_radiance_cache"},
-    {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_INPUT_ENVIRONMENT_MAP, L"g_environment_map"},
-    {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_INPUT_PREV_LIT_OUTPUT, L"g_prev_lit_output"},
-    {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_INPUT_DEPTH, L"g_depth"},
-    {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_INPUT_HISTORY_DEPTH, L"g_history_depth"},
-    {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_INPUT_NORMAL, L"g_normal"},
-    {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_INPUT_HISTORY_NORMAL, L"g_history_normal"},
-    {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_INPUT_ROUGHNESS, L"g_roughness"},
-    {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_INPUT_MOTION_VECTORS, L"g_motion_vectors"},
-    {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_INPUT_BLUE_NOISE, L"g_blue_noise"},
-    {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_INPUT_SDF_ATLAS, L"r_sdf_atlas"},
-    {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_INPUT_CONTEXT_BRICKS_AABB, L"r_bctx_bricks_aabb"},
-    {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_INPUT_CONTEXT_BRICKS_VOXEL_MAP, L"r_bctx_bricks_voxel_map"},
-    {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_INPUT_CONTEXT_COUNTERS, L"r_bctx_counters"},
-    {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_INPUT_BRICKS_CLEAR_LIST, L"r_bctx_bricks_clear_list"},
-    {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_INPUT_CASCADE_AABB_TREES, L"r_cascade_aabbtrees"},
-    {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_INPUT_CASCADE_BRICK_MAPS, L"r_cascade_brick_maps"},
-    {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_SOURCE_DEPTH, L"g_src_depth"},
-    {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_SOURCE_HISTORY_DEPTH, L"g_src_history_depth"},
-    {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_SOURCE_NORMAL, L"g_src_normal"},
-    {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_SOURCE_HISTORY_NORMAL, L"g_src_history_normal"},
-    {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_SOURCE_ROUGHNESS, L"g_src_roughness"},
-    {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_SOURCE_MOTION_VECTORS, L"g_src_motion_vectors"},
-    {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_SOURCE_LIT_OUTPUT, L"g_src_prev_lit_output"},
-    {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_OUTPUT_DIFFUSE_GI, L"g_downsampled_diffuse_gi"},
-    {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_OUTPUT_SPECULAR_GI, L"g_downsampled_specular_gi"},
+    {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_DISOCCLUSION_MASK, "g_r_disocclusion_mask"},
+    {FFX_BRIXELIZER_GI_PING_PONG_RESOURCE_STATIC_GI_TARGET_READ, "g_sdfgi_r_static_gitarget"},
+    {FFX_BRIXELIZER_GI_PING_PONG_RESOURCE_STATIC_SCREEN_PROBES_READ, "g_sdfgi_r_static_screen_probes"},
+    {FFX_BRIXELIZER_GI_PING_PONG_RESOURCE_STATIC_SPECULAR_TARGET_READ, "g_sdfgi_r_specular_target"},
+    {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_RADIANCE_CACHE, "g_bctx_radiance_cache"},
+    {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_INPUT_ENVIRONMENT_MAP, "g_environment_map"},
+    {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_INPUT_PREV_LIT_OUTPUT, "g_prev_lit_output"},
+    {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_INPUT_DEPTH, "g_depth"},
+    {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_INPUT_HISTORY_DEPTH, "g_history_depth"},
+    {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_INPUT_NORMAL, "g_normal"},
+    {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_INPUT_HISTORY_NORMAL, "g_history_normal"},
+    {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_INPUT_ROUGHNESS, "g_roughness"},
+    {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_INPUT_MOTION_VECTORS, "g_motion_vectors"},
+    {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_INPUT_BLUE_NOISE, "g_blue_noise"},
+    {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_INPUT_SDF_ATLAS, "r_sdf_atlas"},
+    {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_INPUT_CONTEXT_BRICKS_AABB, "r_bctx_bricks_aabb"},
+    {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_INPUT_CONTEXT_BRICKS_VOXEL_MAP, "r_bctx_bricks_voxel_map"},
+    {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_INPUT_CONTEXT_COUNTERS, "r_bctx_counters"},
+    {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_INPUT_BRICKS_CLEAR_LIST, "r_bctx_bricks_clear_list"},
+    {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_INPUT_CASCADE_AABB_TREES, "r_cascade_aabbtrees"},
+    {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_INPUT_CASCADE_BRICK_MAPS, "r_cascade_brick_maps"},
+    {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_SOURCE_DEPTH, "g_src_depth"},
+    {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_SOURCE_HISTORY_DEPTH, "g_src_history_depth"},
+    {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_SOURCE_NORMAL, "g_src_normal"},
+    {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_SOURCE_HISTORY_NORMAL, "g_src_history_normal"},
+    {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_SOURCE_ROUGHNESS, "g_src_roughness"},
+    {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_SOURCE_MOTION_VECTORS, "g_src_motion_vectors"},
+    {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_SOURCE_LIT_OUTPUT, "g_src_prev_lit_output"},
+    {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_OUTPUT_DIFFUSE_GI, "g_downsampled_diffuse_gi"},
+    {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_OUTPUT_SPECULAR_GI, "g_downsampled_specular_gi"},
 };
 
 static const ResourceBinding uavResourceBindingTable[] = {
-    {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_DISOCCLUSION_MASK, L"g_rw_disocclusion_mask"},
-    {FFX_BRIXELIZER_GI_PING_PONG_RESOURCE_STATIC_SCREEN_PROBES_WRITE, L"g_sdfgi_rw_static_screen_probes"},
-    {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_STATIC_PUSHOFF_MAP, L"g_sdfgi_rw_static_pushoff_map"},
-    {FFX_BRIXELIZER_GI_PING_PONG_RESOURCE_STATIC_GI_TARGET_WRITE, L"g_sdfgi_rw_static_gitarget"},
-    {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_DEBUG_TARGET, L"g_sdfgi_rw_debug_target"},
-    {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_RADIANCE_CACHE, L"g_rw_bctx_radiance_cache"},
-    {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_TEMP_SPAWN_MASK, L"g_sdfgi_rw_temp_spawn_mask"},
-    {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_TEMP_RAND_SEED, L"g_sdfgi_rw_temp_rand_seed"},
-    {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_TEMP_SPECULAR_PRETRACE_TARGET, L"g_sdfgi_rw_temp_specular_pretrace_target"},
-    {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_TEMP_BLUR_MASK, L"g_sdfgi_rw_temp_blur_mask"},
-    {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_STATIC_SCREEN_PROBES_STAT, L"g_sdfgi_rw_static_screen_probes_stat"},
-    {FFX_BRIXELIZER_GI_PING_PONG_RESOURCE_STATIC_SPECULAR_TARGET_WRITE, L"g_sdfgi_rw_specular_target"},
-    {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_STATIC_PROBE_INFO, L"g_sdfgi_rw_static_probe_info"},
-    {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_STATIC_PROBE_SH, L"g_sdfgi_rw_static_probe_sh_buffer"},
-    {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_TEMP_PROBE_INFO, L"g_sdfgi_rw_temp_probe_info"},
-    {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_TEMP_PROBE_SH, L"g_sdfgi_rw_temp_probe_sh_buffer"},
-    {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_RAY_SWAP_INDIRECT_ARGS, L"g_sdfgi_rw_ray_swap_indirect_args"},
-    {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_BRICKS_DIRECT_SH, L"g_bctx_bricks_direct_sh"},
-    {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_BRICKS_SH, L"g_bctx_bricks_sh"},
-    {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_BRICKS_SH_STATE, L"g_bctx_bricks_sh_state"},
-    {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_TEMP_SPECULAR_RAY_SWAP, L"g_sdfgi_rw_temp_specular_ray_swap"},
-    {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_OUTPUT_DIFFUSE_GI, L"g_rw_diffuse_output_copy"},
-    {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_OUTPUT_SPECULAR_GI, L"g_rw_specular_output_copy"},
-    {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_OUTPUT_DEBUG_VISUALIZATION, L"g_rw_debug_visualization"},
-    {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_DOWNSAMPLED_LIT_OUTPUT, L"g_downsampled_prev_lit_output"},
-    {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_DOWNSAMPLED_DEPTH, L"g_downsampled_depth"},
-    {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_DOWNSAMPLED_HISTORY_DEPTH, L"g_downsampled_history_depth"},
-    {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_DOWNSAMPLED_NORMAL, L"g_downsampled_normal"},
-    {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_DOWNSAMPLED_HISTORY_NORMAL, L"g_downsampled_history_normal"},
-    {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_DOWNSAMPLED_ROUGHNESS, L"g_downsampled_roughness"},
-    {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_DOWNSAMPLED_MOTION_VECTORS, L"g_downsampled_motion_vectors"},
-    {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_UPSAMPLED_DIFFUSE_GI, L"g_upsampled_diffuse_gi"},
-    {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_UPSAMPLED_SPECULAR_GI, L"g_upsampled_specular_gi"},
+    {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_DISOCCLUSION_MASK, "g_rw_disocclusion_mask"},
+    {FFX_BRIXELIZER_GI_PING_PONG_RESOURCE_STATIC_SCREEN_PROBES_WRITE, "g_sdfgi_rw_static_screen_probes"},
+    {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_STATIC_PUSHOFF_MAP, "g_sdfgi_rw_static_pushoff_map"},
+    {FFX_BRIXELIZER_GI_PING_PONG_RESOURCE_STATIC_GI_TARGET_WRITE, "g_sdfgi_rw_static_gitarget"},
+    {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_DEBUG_TARGET, "g_sdfgi_rw_debug_target"},
+    {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_RADIANCE_CACHE, "g_rw_bctx_radiance_cache"},
+    {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_TEMP_SPAWN_MASK, "g_sdfgi_rw_temp_spawn_mask"},
+    {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_TEMP_RAND_SEED, "g_sdfgi_rw_temp_rand_seed"},
+    {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_TEMP_SPECULAR_PRETRACE_TARGET, "g_sdfgi_rw_temp_specular_pretrace_target"},
+    {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_TEMP_BLUR_MASK, "g_sdfgi_rw_temp_blur_mask"},
+    {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_STATIC_SCREEN_PROBES_STAT, "g_sdfgi_rw_static_screen_probes_stat"},
+    {FFX_BRIXELIZER_GI_PING_PONG_RESOURCE_STATIC_SPECULAR_TARGET_WRITE, "g_sdfgi_rw_specular_target"},
+    {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_STATIC_PROBE_INFO, "g_sdfgi_rw_static_probe_info"},
+    {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_STATIC_PROBE_SH, "g_sdfgi_rw_static_probe_sh_buffer"},
+    {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_TEMP_PROBE_INFO, "g_sdfgi_rw_temp_probe_info"},
+    {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_TEMP_PROBE_SH, "g_sdfgi_rw_temp_probe_sh_buffer"},
+    {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_RAY_SWAP_INDIRECT_ARGS, "g_sdfgi_rw_ray_swap_indirect_args"},
+    {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_BRICKS_DIRECT_SH, "g_bctx_bricks_direct_sh"},
+    {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_BRICKS_SH, "g_bctx_bricks_sh"},
+    {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_BRICKS_SH_STATE, "g_bctx_bricks_sh_state"},
+    {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_TEMP_SPECULAR_RAY_SWAP, "g_sdfgi_rw_temp_specular_ray_swap"},
+    {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_OUTPUT_DIFFUSE_GI, "g_rw_diffuse_output_copy"},
+    {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_OUTPUT_SPECULAR_GI, "g_rw_specular_output_copy"},
+    {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_OUTPUT_DEBUG_VISUALIZATION, "g_rw_debug_visualization"},
+    {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_DOWNSAMPLED_LIT_OUTPUT, "g_downsampled_prev_lit_output"},
+    {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_DOWNSAMPLED_DEPTH, "g_downsampled_depth"},
+    {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_DOWNSAMPLED_HISTORY_DEPTH, "g_downsampled_history_depth"},
+    {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_DOWNSAMPLED_NORMAL, "g_downsampled_normal"},
+    {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_DOWNSAMPLED_HISTORY_NORMAL, "g_downsampled_history_normal"},
+    {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_DOWNSAMPLED_ROUGHNESS, "g_downsampled_roughness"},
+    {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_DOWNSAMPLED_MOTION_VECTORS, "g_downsampled_motion_vectors"},
+    {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_UPSAMPLED_DIFFUSE_GI, "g_upsampled_diffuse_gi"},
+    {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_UPSAMPLED_SPECULAR_GI, "g_upsampled_specular_gi"},
 };
 
 static const ResourceBinding cbvResourceBindingTable[] = {
-    {FFX_BRIXELIZER_GI_CONSTANTBUFFER_IDENTIFIER_GI_CONSTANTS, L"g_sdfgi_constants"},
-    {FFX_BRIXELIZER_GI_CONSTANTBUFFER_IDENTIFIER_PASS_CONSTANTS, L"g_pass_constants"},
-    {FFX_BRIXELIZER_GI_CONSTANTBUFFER_IDENTIFIER_SCALING_CONSTANTS, L"g_scaling_constants"},
-    {FFX_BRIXELIZER_GI_CONSTANTBUFFER_IDENTIFIER_CONTEXT_INFO, L"g_bx_context_info"},
+    {FFX_BRIXELIZER_GI_CONSTANTBUFFER_IDENTIFIER_GI_CONSTANTS, "g_sdfgi_constants"},
+    {FFX_BRIXELIZER_GI_CONSTANTBUFFER_IDENTIFIER_PASS_CONSTANTS, "g_pass_constants"},
+    {FFX_BRIXELIZER_GI_CONSTANTBUFFER_IDENTIFIER_SCALING_CONSTANTS, "g_scaling_constants"},
+    {FFX_BRIXELIZER_GI_CONSTANTBUFFER_IDENTIFIER_CONTEXT_INFO, "g_bx_context_info"},
 };
 
 static size_t cbSizes[] = {
@@ -335,12 +338,12 @@ static void patchResourceBindings(FfxPipelineState* inoutPipeline)
         FfxResourceBinding& binding = inoutPipeline->srvTextureBindings[srvTextureIndex];
 
         int32_t mapIndex = 0;
-        for (mapIndex = 0; mapIndex < _countof(srvResourceBindingTable); ++mapIndex)
+        for (mapIndex = 0; mapIndex < std::size(srvResourceBindingTable); ++mapIndex)
         {
-            if (0 == wcscmp(srvResourceBindingTable[mapIndex].name, binding.name))
+            if (0 == strcmp(srvResourceBindingTable[mapIndex].name, binding.name))
                 break;
         }
-        if (mapIndex == _countof(srvResourceBindingTable))
+        if (mapIndex == std::size(srvResourceBindingTable))
             return;
 
         binding.resourceIdentifier = srvResourceBindingTable[mapIndex].index + binding.arrayIndex;
@@ -351,12 +354,12 @@ static void patchResourceBindings(FfxPipelineState* inoutPipeline)
         FfxResourceBinding& binding = inoutPipeline->srvBufferBindings[srvBufferIndex];
 
         int32_t mapIndex = 0;
-        for (mapIndex = 0; mapIndex < _countof(srvResourceBindingTable); ++mapIndex)
+        for (mapIndex = 0; mapIndex < std::size(srvResourceBindingTable); ++mapIndex)
         {
-            if (0 == wcscmp(srvResourceBindingTable[mapIndex].name, binding.name))
+            if (0 == strcmp(srvResourceBindingTable[mapIndex].name, binding.name))
                 break;
         }
-        if (mapIndex == _countof(srvResourceBindingTable))
+        if (mapIndex == std::size(srvResourceBindingTable))
             return;
 
         binding.resourceIdentifier = srvResourceBindingTable[mapIndex].index + binding.arrayIndex;
@@ -365,12 +368,12 @@ static void patchResourceBindings(FfxPipelineState* inoutPipeline)
     for (uint32_t uavTextureIndex = 0; uavTextureIndex < inoutPipeline->uavTextureCount; ++uavTextureIndex)
     {
         int32_t mapIndex = 0;
-        for (mapIndex = 0; mapIndex < _countof(uavResourceBindingTable); ++mapIndex)
+        for (mapIndex = 0; mapIndex < std::size(uavResourceBindingTable); ++mapIndex)
         {
-            if (0 == wcscmp(uavResourceBindingTable[mapIndex].name, inoutPipeline->uavTextureBindings[uavTextureIndex].name))
+            if (0 == strcmp(uavResourceBindingTable[mapIndex].name, inoutPipeline->uavTextureBindings[uavTextureIndex].name))
                 break;
         }
-        if (mapIndex == _countof(uavResourceBindingTable))
+        if (mapIndex == std::size(uavResourceBindingTable))
             return;
 
         inoutPipeline->uavTextureBindings[uavTextureIndex].resourceIdentifier = uavResourceBindingTable[mapIndex].index;
@@ -381,12 +384,12 @@ static void patchResourceBindings(FfxPipelineState* inoutPipeline)
         FfxResourceBinding& binding = inoutPipeline->uavBufferBindings[uavBufferIndex];
 
         int32_t mapIndex = 0;
-        for (mapIndex = 0; mapIndex < _countof(uavResourceBindingTable); ++mapIndex)
+        for (mapIndex = 0; mapIndex < std::size(uavResourceBindingTable); ++mapIndex)
         {
-            if (0 == wcscmp(uavResourceBindingTable[mapIndex].name, binding.name))
+            if (0 == strcmp(uavResourceBindingTable[mapIndex].name, binding.name))
                 break;
         }
-        if (mapIndex == _countof(uavResourceBindingTable))
+        if (mapIndex == std::size(uavResourceBindingTable))
             return;
 
         binding.resourceIdentifier = uavResourceBindingTable[mapIndex].index + binding.arrayIndex;
@@ -397,12 +400,12 @@ static void patchResourceBindings(FfxPipelineState* inoutPipeline)
         FfxResourceBinding& binding = inoutPipeline->constantBufferBindings[cbvIndex];
 
         int32_t mapIndex = 0;
-        for (mapIndex = 0; mapIndex < _countof(cbvResourceBindingTable); ++mapIndex)
+        for (mapIndex = 0; mapIndex < std::size(cbvResourceBindingTable); ++mapIndex)
         {
-            if (0 == wcscmp(cbvResourceBindingTable[mapIndex].name, binding.name))
+            if (0 == strcmp(cbvResourceBindingTable[mapIndex].name, binding.name))
                 break;
         }
-        if (mapIndex == _countof(cbvResourceBindingTable))
+        if (mapIndex == std::size(cbvResourceBindingTable))
             return;
 
         binding.resourceIdentifier = cbvResourceBindingTable[mapIndex].index;
@@ -479,7 +482,7 @@ static FfxErrorCode createPipelineStates(FfxBrixelizerGIContext_Private* pContex
     uint32_t pipelineFlags = getPipelinePermutationFlags(pContext->contextDescription.flags, supportedFP16, false /*canForceWave64*/); 
 
     // Set up pipeline descriptor (basically RootSignature and binding)
-    wcscpy_s(pipelineDescription.name, L"FFX_BRIXELIZER_GI_PASS_PREPARE_CLEAR_CACHE");
+    strcpy(pipelineDescription.name, "FFX_BRIXELIZER_GI_PASS_PREPARE_CLEAR_CACHE");
     FFX_VALIDATE(pContext->contextDescription.backendInterface.fpCreatePipeline(&pContext->contextDescription.backendInterface,
                                                                                 FFX_EFFECT_BRIXELIZER_GI,
                                                                                 FFX_BRIXELIZER_GI_PASS_PREPARE_CLEAR_CACHE,
@@ -488,7 +491,7 @@ static FfxErrorCode createPipelineStates(FfxBrixelizerGIContext_Private* pContex
                                                                                 pContext->effectContextId,
                                                                                 &pContext->pipelinePrepareClearCache));
     pipelineDescription.indirectWorkload = 1;
-    wcscpy_s(pipelineDescription.name, L"FFX_BRIXELIZER_GI_PASS_CLEAR_CACHE");
+    strcpy(pipelineDescription.name, "FFX_BRIXELIZER_GI_PASS_CLEAR_CACHE");
     FFX_VALIDATE(pContext->contextDescription.backendInterface.fpCreatePipeline(&pContext->contextDescription.backendInterface,
                                                                                 FFX_EFFECT_BRIXELIZER_GI,
                                                                                 FFX_BRIXELIZER_GI_PASS_CLEAR_CACHE,
@@ -497,7 +500,7 @@ static FfxErrorCode createPipelineStates(FfxBrixelizerGIContext_Private* pContex
                                                                                 pContext->effectContextId,
                                                                                 &pContext->pipelineClearCache));
     pipelineDescription.indirectWorkload = 0;
-    wcscpy_s(pipelineDescription.name, L"FFX_BRIXELIZER_GI_PASS_EMIT_PRIMARY_RAY_RADIANCE");
+    strcpy(pipelineDescription.name, "FFX_BRIXELIZER_GI_PASS_EMIT_PRIMARY_RAY_RADIANCE");
     FFX_VALIDATE(pContext->contextDescription.backendInterface.fpCreatePipeline(&pContext->contextDescription.backendInterface,
                                                                                 FFX_EFFECT_BRIXELIZER_GI,
                                                                                 FFX_BRIXELIZER_GI_PASS_EMIT_PRIMARY_RAY_RADIANCE,
@@ -505,7 +508,7 @@ static FfxErrorCode createPipelineStates(FfxBrixelizerGIContext_Private* pContex
                                                                                 &pipelineDescription,
                                                                                 pContext->effectContextId,
                                                                                 &pContext->pipelineEmitPrimaryRayRadiance));
-    wcscpy_s(pipelineDescription.name, L"FFX_BRIXELIZER_GI_PASS_PROPAGATE_SH");
+    strcpy(pipelineDescription.name, "FFX_BRIXELIZER_GI_PASS_PROPAGATE_SH");
     FFX_VALIDATE(pContext->contextDescription.backendInterface.fpCreatePipeline(&pContext->contextDescription.backendInterface,
                                                                                 FFX_EFFECT_BRIXELIZER_GI,
                                                                                 FFX_BRIXELIZER_GI_PASS_PROPAGATE_SH,
@@ -513,7 +516,7 @@ static FfxErrorCode createPipelineStates(FfxBrixelizerGIContext_Private* pContex
                                                                                 &pipelineDescription,
                                                                                 pContext->effectContextId,
                                                                                 &pContext->pipelinePropagateSH));
-    wcscpy_s(pipelineDescription.name, L"FFX_BRIXELIZER_GI_PASS_SPAWN_SCREEN_PROBES");
+    strcpy(pipelineDescription.name, "FFX_BRIXELIZER_GI_PASS_SPAWN_SCREEN_PROBES");
     FFX_VALIDATE(pContext->contextDescription.backendInterface.fpCreatePipeline(&pContext->contextDescription.backendInterface,
                                                                                 FFX_EFFECT_BRIXELIZER_GI,
                                                                                 FFX_BRIXELIZER_GI_PASS_SPAWN_SCREEN_PROBES,
@@ -521,7 +524,7 @@ static FfxErrorCode createPipelineStates(FfxBrixelizerGIContext_Private* pContex
                                                                                 &pipelineDescription,
                                                                                 pContext->effectContextId,
                                                                                 &pContext->pipelineSpawnScreenProbes));
-    wcscpy_s(pipelineDescription.name, L"FFX_BRIXELIZER_GI_PASS_REPROJECT_SCREEN_PROBES");
+    strcpy(pipelineDescription.name, "FFX_BRIXELIZER_GI_PASS_REPROJECT_SCREEN_PROBES");
     FFX_VALIDATE(pContext->contextDescription.backendInterface.fpCreatePipeline(&pContext->contextDescription.backendInterface,
                                                                                 FFX_EFFECT_BRIXELIZER_GI,
                                                                                 FFX_BRIXELIZER_GI_PASS_REPROJECT_SCREEN_PROBES,
@@ -529,7 +532,7 @@ static FfxErrorCode createPipelineStates(FfxBrixelizerGIContext_Private* pContex
                                                                                 &pipelineDescription,
                                                                                 pContext->effectContextId,
                                                                                 &pContext->pipelineReprojectScreenProbes));
-    wcscpy_s(pipelineDescription.name, L"FFX_BRIXELIZER_GI_PASS_FILL_SCREEN_PROBES");
+    strcpy(pipelineDescription.name, "FFX_BRIXELIZER_GI_PASS_FILL_SCREEN_PROBES");
     FFX_VALIDATE(pContext->contextDescription.backendInterface.fpCreatePipeline(&pContext->contextDescription.backendInterface,
                                                                                 FFX_EFFECT_BRIXELIZER_GI,
                                                                                 FFX_BRIXELIZER_GI_PASS_FILL_SCREEN_PROBES,
@@ -537,7 +540,7 @@ static FfxErrorCode createPipelineStates(FfxBrixelizerGIContext_Private* pContex
                                                                                 &pipelineDescription,
                                                                                 pContext->effectContextId,
                                                                                 &pContext->pipelineFillScreenProbes));
-    wcscpy_s(pipelineDescription.name, L"FFX_BRIXELIZER_GI_PASS_SPECULAR_PRE_TRACE");
+    strcpy(pipelineDescription.name, "FFX_BRIXELIZER_GI_PASS_SPECULAR_PRE_TRACE");
     FFX_VALIDATE(pContext->contextDescription.backendInterface.fpCreatePipeline(&pContext->contextDescription.backendInterface,
                                                                                 FFX_EFFECT_BRIXELIZER_GI,
                                                                                 FFX_BRIXELIZER_GI_PASS_SPECULAR_PRE_TRACE,
@@ -545,7 +548,7 @@ static FfxErrorCode createPipelineStates(FfxBrixelizerGIContext_Private* pContex
                                                                                 &pipelineDescription,
                                                                                 pContext->effectContextId,
                                                                                 &pContext->pipelineSpecularPreTrace));
-    wcscpy_s(pipelineDescription.name, L"FFX_BRIXELIZER_GI_PASS_SPECULAR_TRACE");
+    strcpy(pipelineDescription.name, "FFX_BRIXELIZER_GI_PASS_SPECULAR_TRACE");
     FFX_VALIDATE(pContext->contextDescription.backendInterface.fpCreatePipeline(&pContext->contextDescription.backendInterface,
                                                                                 FFX_EFFECT_BRIXELIZER_GI,
                                                                                 FFX_BRIXELIZER_GI_PASS_SPECULAR_TRACE,
@@ -553,7 +556,7 @@ static FfxErrorCode createPipelineStates(FfxBrixelizerGIContext_Private* pContex
                                                                                 &pipelineDescription,
                                                                                 pContext->effectContextId,
                                                                                 &pContext->pipelineSpecularTrace));
-    wcscpy_s(pipelineDescription.name, L"FFX_BRIXELIZER_GI_PASS_REPROJECT_GI");
+    strcpy(pipelineDescription.name, "FFX_BRIXELIZER_GI_PASS_REPROJECT_GI");
     FFX_VALIDATE(pContext->contextDescription.backendInterface.fpCreatePipeline(&pContext->contextDescription.backendInterface,
                                                                                 FFX_EFFECT_BRIXELIZER_GI,
                                                                                 FFX_BRIXELIZER_GI_PASS_REPROJECT_GI,
@@ -561,7 +564,7 @@ static FfxErrorCode createPipelineStates(FfxBrixelizerGIContext_Private* pContex
                                                                                 &pipelineDescription,
                                                                                 pContext->effectContextId,
                                                                                 &pContext->pipelineReprojectGI));
-    wcscpy_s(pipelineDescription.name, L"FFX_BRIXELIZER_GI_PASS_PROJECT_SCREEN_PROBES");
+    strcpy(pipelineDescription.name, "FFX_BRIXELIZER_GI_PASS_PROJECT_SCREEN_PROBES");
     FFX_VALIDATE(pContext->contextDescription.backendInterface.fpCreatePipeline(&pContext->contextDescription.backendInterface,
                                                                                 FFX_EFFECT_BRIXELIZER_GI,
                                                                                 FFX_BRIXELIZER_GI_PASS_PROJECT_SCREEN_PROBES,
@@ -569,7 +572,7 @@ static FfxErrorCode createPipelineStates(FfxBrixelizerGIContext_Private* pContex
                                                                                 &pipelineDescription,
                                                                                 pContext->effectContextId,
                                                                                 &pContext->pipelineProjectScreenProbes));
-    wcscpy_s(pipelineDescription.name, L"FFX_BRIXELIZER_GI_PASS_EMIT_IRRADIANCE_CACHE");
+    strcpy(pipelineDescription.name, "FFX_BRIXELIZER_GI_PASS_EMIT_IRRADIANCE_CACHE");
     FFX_VALIDATE(pContext->contextDescription.backendInterface.fpCreatePipeline(&pContext->contextDescription.backendInterface,
                                                                                 FFX_EFFECT_BRIXELIZER_GI,
                                                                                 FFX_BRIXELIZER_GI_PASS_EMIT_IRRADIANCE_CACHE,
@@ -577,7 +580,7 @@ static FfxErrorCode createPipelineStates(FfxBrixelizerGIContext_Private* pContex
                                                                                 &pipelineDescription,
                                                                                 pContext->effectContextId,
                                                                                 &pContext->pipelineEmitIrradianceCache));
-    wcscpy_s(pipelineDescription.name, L"FFX_BRIXELIZER_GI_PASS_INTERPOLATE_SCREEN_PROBES");
+    strcpy(pipelineDescription.name, "FFX_BRIXELIZER_GI_PASS_INTERPOLATE_SCREEN_PROBES");
     FFX_VALIDATE(pContext->contextDescription.backendInterface.fpCreatePipeline(&pContext->contextDescription.backendInterface,
                                                                                 FFX_EFFECT_BRIXELIZER_GI,
                                                                                 FFX_BRIXELIZER_GI_PASS_INTERPOLATE_SCREEN_PROBES,
@@ -585,7 +588,7 @@ static FfxErrorCode createPipelineStates(FfxBrixelizerGIContext_Private* pContex
                                                                                 &pipelineDescription,
                                                                                 pContext->effectContextId,
                                                                                 &pContext->pipelineInterpolateScreenProbes));
-    wcscpy_s(pipelineDescription.name, L"FFX_BRIXELIZER_GI_PASS_BLUR_X");
+    strcpy(pipelineDescription.name, "FFX_BRIXELIZER_GI_PASS_BLUR_X");
     FFX_VALIDATE(pContext->contextDescription.backendInterface.fpCreatePipeline(&pContext->contextDescription.backendInterface,
                                                                                 FFX_EFFECT_BRIXELIZER_GI,
                                                                                 FFX_BRIXELIZER_GI_PASS_BLUR_X,
@@ -593,7 +596,7 @@ static FfxErrorCode createPipelineStates(FfxBrixelizerGIContext_Private* pContex
                                                                                 &pipelineDescription,
                                                                                 pContext->effectContextId,
                                                                                 &pContext->pipelineBlurX));
-    wcscpy_s(pipelineDescription.name, L"FFX_BRIXELIZER_GI_PASS_BLUR_Y");
+    strcpy(pipelineDescription.name, "FFX_BRIXELIZER_GI_PASS_BLUR_Y");
     FFX_VALIDATE(pContext->contextDescription.backendInterface.fpCreatePipeline(&pContext->contextDescription.backendInterface,
                                                                                 FFX_EFFECT_BRIXELIZER_GI,
                                                                                 FFX_BRIXELIZER_GI_PASS_BLUR_Y,
@@ -601,7 +604,7 @@ static FfxErrorCode createPipelineStates(FfxBrixelizerGIContext_Private* pContex
                                                                                 &pipelineDescription,
                                                                                 pContext->effectContextId,
                                                                                 &pContext->pipelineBlurY));
-    wcscpy_s(pipelineDescription.name, L"FFX_BRIXELIZER_GI_PASS_DEBUG_VISUALIZATION");
+    strcpy(pipelineDescription.name, "FFX_BRIXELIZER_GI_PASS_DEBUG_VISUALIZATION");
     FFX_VALIDATE(pContext->contextDescription.backendInterface.fpCreatePipeline(&pContext->contextDescription.backendInterface,
                                                                                 FFX_EFFECT_BRIXELIZER_GI,
                                                                                 FFX_BRIXELIZER_GI_PASS_DEBUG_VISUALIZATION,
@@ -609,7 +612,7 @@ static FfxErrorCode createPipelineStates(FfxBrixelizerGIContext_Private* pContex
                                                                                 &pipelineDescription,
                                                                                 pContext->effectContextId,
                                                                                 &pContext->pipelineDebugVisualization));
-    wcscpy_s(pipelineDescription.name, L"FFX_BRIXELIZER_GI_PASS_GENERATE_DISOCCLUSION_MASK");
+    strcpy(pipelineDescription.name, "FFX_BRIXELIZER_GI_PASS_GENERATE_DISOCCLUSION_MASK");
     FFX_VALIDATE(pContext->contextDescription.backendInterface.fpCreatePipeline(&pContext->contextDescription.backendInterface,
                                                                                 FFX_EFFECT_BRIXELIZER_GI,
                                                                                 FFX_BRIXELIZER_GI_PASS_GENERATE_DISOCCLUSION_MASK,
@@ -617,7 +620,7 @@ static FfxErrorCode createPipelineStates(FfxBrixelizerGIContext_Private* pContex
                                                                                 &pipelineDescription,
                                                                                 pContext->effectContextId,
                                                                                 &pContext->pipelineGenerateDisocclusionMask));
-    wcscpy_s(pipelineDescription.name, L"FFX_BRIXELIZER_GI_PASS_DOWNSAMPLE");
+    strcpy(pipelineDescription.name, "FFX_BRIXELIZER_GI_PASS_DOWNSAMPLE");
     FFX_VALIDATE(pContext->contextDescription.backendInterface.fpCreatePipeline(&pContext->contextDescription.backendInterface,
                                                                                 FFX_EFFECT_BRIXELIZER_GI,
                                                                                 FFX_BRIXELIZER_GI_PASS_DOWNSAMPLE,
@@ -625,7 +628,7 @@ static FfxErrorCode createPipelineStates(FfxBrixelizerGIContext_Private* pContex
                                                                                 &pipelineDescription,
                                                                                 pContext->effectContextId,
                                                                                 &pContext->pipelineDownsample));
-    wcscpy_s(pipelineDescription.name, L"FFX_BRIXELIZER_GI_PASS_UPSAMPLE");
+    strcpy(pipelineDescription.name, "FFX_BRIXELIZER_GI_PASS_UPSAMPLE");
     FFX_VALIDATE(pContext->contextDescription.backendInterface.fpCreatePipeline(&pContext->contextDescription.backendInterface,
                                                                                 FFX_EFFECT_BRIXELIZER_GI,
                                                                                 FFX_BRIXELIZER_GI_PASS_UPSAMPLE,
@@ -666,7 +669,7 @@ static void scheduleDispatchInternal(FfxBrixelizerGIContext_Private* pContext,
 {
     pContext->gpuJobDescription = {FFX_GPU_JOB_COMPUTE};
 
-    wcscpy_s(pContext->gpuJobDescription.jobLabel, pipeline->name);
+    strcpy(pContext->gpuJobDescription.jobLabel, pipeline->name);
 
     FFX_ASSERT(pipeline->srvTextureCount < FFX_MAX_NUM_SRVS);
 
@@ -678,7 +681,7 @@ static void scheduleDispatchInternal(FfxBrixelizerGIContext_Private* pContext,
 
         pContext->gpuJobDescription.computeJobDescriptor.srvTextures[currentShaderResourceViewIndex].resource = currentResource;
 #ifdef FFX_DEBUG
-        wcscpy_s(pContext->gpuJobDescription.computeJobDescriptor.srvTextures[currentShaderResourceViewIndex].name,
+        strcpy(pContext->gpuJobDescription.computeJobDescriptor.srvTextures[currentShaderResourceViewIndex].name,
                  pipeline->srvTextureBindings[currentShaderResourceViewIndex].name);
 #endif
     }
@@ -696,7 +699,7 @@ static void scheduleDispatchInternal(FfxBrixelizerGIContext_Private* pContext,
         pContext->gpuJobDescription.computeJobDescriptor.srvBuffers[currentShaderResourceViewIndex].size     = 0;
         pContext->gpuJobDescription.computeJobDescriptor.srvBuffers[currentShaderResourceViewIndex].stride   = 0;
 #ifdef FFX_DEBUG
-        wcscpy_s(pContext->gpuJobDescription.computeJobDescriptor.srvBuffers[currentShaderResourceViewIndex].name, pipeline->srvBufferBindings[currentShaderResourceViewIndex].name);
+        strcpy(pContext->gpuJobDescription.computeJobDescriptor.srvBuffers[currentShaderResourceViewIndex].name, pipeline->srvBufferBindings[currentShaderResourceViewIndex].name);
 #endif
     }
 
@@ -711,7 +714,7 @@ static void scheduleDispatchInternal(FfxBrixelizerGIContext_Private* pContext,
         pContext->gpuJobDescription.computeJobDescriptor.uavTextures[currentUnorderedAccessViewIndex].resource = currentResource;
         pContext->gpuJobDescription.computeJobDescriptor.uavTextures[currentUnorderedAccessViewIndex].mip      = 0;
 #ifdef FFX_DEBUG
-        wcscpy_s(pContext->gpuJobDescription.computeJobDescriptor.uavTextures[currentUnorderedAccessViewIndex].name, pipeline->uavTextureBindings[currentUnorderedAccessViewIndex].name);
+        strcpy(pContext->gpuJobDescription.computeJobDescriptor.uavTextures[currentUnorderedAccessViewIndex].name, pipeline->uavTextureBindings[currentUnorderedAccessViewIndex].name);
 #endif
     }
 
@@ -728,7 +731,7 @@ static void scheduleDispatchInternal(FfxBrixelizerGIContext_Private* pContext,
         pContext->gpuJobDescription.computeJobDescriptor.uavBuffers[currentUnorderedAccessViewIndex].size     = 0;
         pContext->gpuJobDescription.computeJobDescriptor.uavBuffers[currentUnorderedAccessViewIndex].stride   = 0;
 #ifdef FFX_DEBUG
-        wcscpy_s(pContext->gpuJobDescription.computeJobDescriptor.uavBuffers[currentUnorderedAccessViewIndex].name, pipeline->uavBufferBindings[currentUnorderedAccessViewIndex].name);
+        strcpy(pContext->gpuJobDescription.computeJobDescriptor.uavBuffers[currentUnorderedAccessViewIndex].name, pipeline->uavBufferBindings[currentUnorderedAccessViewIndex].name);
 #endif
     }
 
@@ -748,7 +751,7 @@ static void scheduleDispatchInternal(FfxBrixelizerGIContext_Private* pContext,
 
         pContext->gpuJobDescription.computeJobDescriptor.cbs[currentConstantBufferViewIndex] = pContext->constantBuffers[cbvInfoIdx];
 #ifdef FFX_DEBUG
-        wcscpy_s(pContext->gpuJobDescription.computeJobDescriptor.cbNames[currentConstantBufferViewIndex], pipeline->constantBufferBindings[currentConstantBufferViewIndex].name);
+        strcpy(pContext->gpuJobDescription.computeJobDescriptor.cbNames[currentConstantBufferViewIndex], pipeline->constantBufferBindings[currentConstantBufferViewIndex].name);
 #endif
     }
 
@@ -768,11 +771,11 @@ static void scheduleCopy(FfxBrixelizerGIContext_Private* pContext,
                          FfxResourceInternal             dst,
                          uint32_t                        dstOffset,
                          uint32_t                        size,
-                         const wchar_t*                  name)
+                         const char*                     name)
 {
     pContext->gpuJobDescription = {FFX_GPU_JOB_COPY};
 
-    wcscpy_s(pContext->gpuJobDescription.jobLabel, name);
+    strcpy(pContext->gpuJobDescription.jobLabel, name);
 
     pContext->gpuJobDescription.copyJobDescriptor.src       = src;
     pContext->gpuJobDescription.copyJobDescriptor.srcOffset = srcOffset;
@@ -861,7 +864,7 @@ static FfxErrorCode brixelizerGICreate(FfxBrixelizerGIContext_Private* pContext,
     {
         const FfxInternalResourceDescription internalSurfaceDesc[] = {
             {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_RADIANCE_CACHE,
-             L"BrixelizerGI_RadianceCache",
+             "BrixelizerGI_RadianceCache",
              FFX_RESOURCE_TYPE_TEXTURE3D,
              FFX_RESOURCE_USAGE_UAV,
              FFX_SURFACE_FORMAT_R11G11B10_FLOAT,
@@ -870,7 +873,7 @@ static FfxErrorCode brixelizerGICreate(FfxBrixelizerGIContext_Private* pContext,
              FFX_BRIXELIZER_STATIC_CONFIG_SDF_ATLAS_SIZE / 2,
              FFX_RESOURCE_FLAGS_NONE},
             {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_STATIC_GI_TARGET_0,
-             L"BrixelizerGI_StaticGITarget0",
+             "BrixelizerGI_StaticGITarget0",
              FFX_RESOURCE_TYPE_TEXTURE2D,
              FFX_RESOURCE_USAGE_UAV,
              FFX_SURFACE_FORMAT_R16G16B16A16_FLOAT,
@@ -879,7 +882,7 @@ static FfxErrorCode brixelizerGICreate(FfxBrixelizerGIContext_Private* pContext,
              1,
              FFX_RESOURCE_FLAGS_NONE},
             {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_STATIC_GI_TARGET_1,
-             L"BrixelizerGI_StaticGITarget1",
+             "BrixelizerGI_StaticGITarget1",
              FFX_RESOURCE_TYPE_TEXTURE2D,
              FFX_RESOURCE_USAGE_UAV,
              FFX_SURFACE_FORMAT_R16G16B16A16_FLOAT,
@@ -888,7 +891,7 @@ static FfxErrorCode brixelizerGICreate(FfxBrixelizerGIContext_Private* pContext,
              1,
              FFX_RESOURCE_FLAGS_NONE},
             {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_STATIC_SCREEN_PROBES_0,
-             L"BrixelizerGI_StaticScreenProbes0",
+             "BrixelizerGI_StaticScreenProbes0",
              FFX_RESOURCE_TYPE_TEXTURE2D,
              FFX_RESOURCE_USAGE_UAV,
              FFX_SURFACE_FORMAT_R16G16B16A16_FLOAT,
@@ -897,7 +900,7 @@ static FfxErrorCode brixelizerGICreate(FfxBrixelizerGIContext_Private* pContext,
              1,
              FFX_RESOURCE_FLAGS_NONE},
             {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_STATIC_SCREEN_PROBES_1,
-             L"BrixelizerGI_StaticScreenProbes1",
+             "BrixelizerGI_StaticScreenProbes1",
              FFX_RESOURCE_TYPE_TEXTURE2D,
              FFX_RESOURCE_USAGE_UAV,
              FFX_SURFACE_FORMAT_R16G16B16A16_FLOAT,
@@ -906,7 +909,7 @@ static FfxErrorCode brixelizerGICreate(FfxBrixelizerGIContext_Private* pContext,
              1,
              FFX_RESOURCE_FLAGS_NONE},
             {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_SPECULAR_TARGET_0,
-             L"BrixelizerGI_SpecularTarget0",
+             "BrixelizerGI_SpecularTarget0",
              FFX_RESOURCE_TYPE_TEXTURE2D,
              FFX_RESOURCE_USAGE_UAV,
              FFX_SURFACE_FORMAT_R16G16B16A16_FLOAT,
@@ -915,7 +918,7 @@ static FfxErrorCode brixelizerGICreate(FfxBrixelizerGIContext_Private* pContext,
              1,
              FFX_RESOURCE_FLAGS_NONE},
             {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_SPECULAR_TARGET_1,
-             L"BrixelizerGI_SpecularTarget1",
+             "BrixelizerGI_SpecularTarget1",
              FFX_RESOURCE_TYPE_TEXTURE2D,
              FFX_RESOURCE_USAGE_UAV,
              FFX_SURFACE_FORMAT_R16G16B16A16_FLOAT,
@@ -924,7 +927,7 @@ static FfxErrorCode brixelizerGICreate(FfxBrixelizerGIContext_Private* pContext,
              1,
              FFX_RESOURCE_FLAGS_NONE},
             {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_DISOCCLUSION_MASK,
-             L"BrixelizerGI_DisocclusionMask",
+             "BrixelizerGI_DisocclusionMask",
              FFX_RESOURCE_TYPE_TEXTURE2D,
              FFX_RESOURCE_USAGE_UAV,
              FFX_SURFACE_FORMAT_R8_UNORM,
@@ -933,7 +936,7 @@ static FfxErrorCode brixelizerGICreate(FfxBrixelizerGIContext_Private* pContext,
              1,
              FFX_RESOURCE_FLAGS_NONE},
             {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_DEBUG_TARGET,
-             L"BrixelizerGI_DebugTarget",
+             "BrixelizerGI_DebugTarget",
              FFX_RESOURCE_TYPE_TEXTURE2D,
              FFX_RESOURCE_USAGE_UAV,
              FFX_SURFACE_FORMAT_R16G16B16A16_FLOAT,
@@ -942,7 +945,7 @@ static FfxErrorCode brixelizerGICreate(FfxBrixelizerGIContext_Private* pContext,
              1,
              FFX_RESOURCE_FLAGS_NONE},
             {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_STATIC_SCREEN_PROBES_STAT,
-             L"BrixelizerGI_StaticScreenProbesStat",
+             "BrixelizerGI_StaticScreenProbesStat",
              FFX_RESOURCE_TYPE_TEXTURE2D,
              FFX_RESOURCE_USAGE_UAV,
              FFX_SURFACE_FORMAT_R16G16B16A16_FLOAT,
@@ -951,7 +954,7 @@ static FfxErrorCode brixelizerGICreate(FfxBrixelizerGIContext_Private* pContext,
              1,
              FFX_RESOURCE_FLAGS_NONE},
             {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_TEMP_SPAWN_MASK,
-             L"BrixelizerGI_TempSpawnMask",
+             "BrixelizerGI_TempSpawnMask",
              FFX_RESOURCE_TYPE_TEXTURE2D,
              FFX_RESOURCE_USAGE_UAV,
              FFX_SURFACE_FORMAT_R32_UINT,
@@ -960,7 +963,7 @@ static FfxErrorCode brixelizerGICreate(FfxBrixelizerGIContext_Private* pContext,
              1,
              FFX_RESOURCE_FLAGS_NONE},
             {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_TEMP_SPECULAR_PRETRACE_TARGET,
-             L"BrixelizerGI_TempSpecularPretraceTarget",
+             "BrixelizerGI_TempSpecularPretraceTarget",
              FFX_RESOURCE_TYPE_TEXTURE2D,
              FFX_RESOURCE_USAGE_UAV,
              FFX_SURFACE_FORMAT_R32G32B32A32_UINT,
@@ -969,7 +972,7 @@ static FfxErrorCode brixelizerGICreate(FfxBrixelizerGIContext_Private* pContext,
              1,
              FFX_RESOURCE_FLAGS_NONE},
             {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_TEMP_BLUR_MASK,
-             L"BrixelizerGI_TempBlurMask",
+             "BrixelizerGI_TempBlurMask",
              FFX_RESOURCE_TYPE_TEXTURE2D,
              FFX_RESOURCE_USAGE_UAV,
              FFX_SURFACE_FORMAT_R8_UNORM,
@@ -978,7 +981,7 @@ static FfxErrorCode brixelizerGICreate(FfxBrixelizerGIContext_Private* pContext,
              1,
              FFX_RESOURCE_FLAGS_NONE},
             {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_TEMP_RAND_SEED,
-             L"BrixelizerGI_TempRandSeed",
+             "BrixelizerGI_TempRandSeed",
              FFX_RESOURCE_TYPE_TEXTURE2D,
              FFX_RESOURCE_USAGE_UAV,
              FFX_SURFACE_FORMAT_R8_UINT,
@@ -987,7 +990,7 @@ static FfxErrorCode brixelizerGICreate(FfxBrixelizerGIContext_Private* pContext,
              1,
              FFX_RESOURCE_FLAGS_NONE},
             {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_BRICKS_SH,
-             L"BrixelizerGI_BrickSH",
+             "BrixelizerGI_BrickSH",
              FFX_RESOURCE_TYPE_BUFFER,
              FFX_RESOURCE_USAGE_UAV,
              FFX_SURFACE_FORMAT_R32_FLOAT,
@@ -996,7 +999,7 @@ static FfxErrorCode brixelizerGICreate(FfxBrixelizerGIContext_Private* pContext,
              1,
              FFX_RESOURCE_FLAGS_NONE},
             {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_BRICKS_DIRECT_SH,
-             L"BrixelizerGI_BrickDirectSH",
+             "BrixelizerGI_BrickDirectSH",
              FFX_RESOURCE_TYPE_BUFFER,
              FFX_RESOURCE_USAGE_UAV,
              FFX_SURFACE_FORMAT_R32_FLOAT,
@@ -1005,7 +1008,7 @@ static FfxErrorCode brixelizerGICreate(FfxBrixelizerGIContext_Private* pContext,
              1,
              FFX_RESOURCE_FLAGS_NONE},
             {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_BRICKS_SH_STATE,
-             L"BrixelizerGI_BrickSHState",
+             "BrixelizerGI_BrickSHState",
              FFX_RESOURCE_TYPE_BUFFER,
              FFX_RESOURCE_USAGE_UAV,
              FFX_SURFACE_FORMAT_R32_FLOAT,
@@ -1014,7 +1017,7 @@ static FfxErrorCode brixelizerGICreate(FfxBrixelizerGIContext_Private* pContext,
              1,
              FFX_RESOURCE_FLAGS_NONE},
             {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_STATIC_PROBE_SH,
-             L"BrixelizerGI_StaticProbeSH",
+             "BrixelizerGI_StaticProbeSH",
              FFX_RESOURCE_TYPE_BUFFER,
              FFX_RESOURCE_USAGE_UAV,
              FFX_SURFACE_FORMAT_R32_FLOAT,
@@ -1023,7 +1026,7 @@ static FfxErrorCode brixelizerGICreate(FfxBrixelizerGIContext_Private* pContext,
              1,
              FFX_RESOURCE_FLAGS_NONE},
             {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_STATIC_PROBE_INFO,
-             L"BrixelizerGI_StaticProbeInfo",
+             "BrixelizerGI_StaticProbeInfo",
              FFX_RESOURCE_TYPE_BUFFER,
              FFX_RESOURCE_USAGE_UAV,
              FFX_SURFACE_FORMAT_R32_FLOAT,
@@ -1032,7 +1035,7 @@ static FfxErrorCode brixelizerGICreate(FfxBrixelizerGIContext_Private* pContext,
              1,
              FFX_RESOURCE_FLAGS_NONE},
             {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_TEMP_PROBE_INFO,
-             L"BrixelizerGI_TempProbeInfo",
+             "BrixelizerGI_TempProbeInfo",
              FFX_RESOURCE_TYPE_BUFFER,
              FFX_RESOURCE_USAGE_UAV,
              FFX_SURFACE_FORMAT_R32_FLOAT,
@@ -1041,7 +1044,7 @@ static FfxErrorCode brixelizerGICreate(FfxBrixelizerGIContext_Private* pContext,
              1,
              FFX_RESOURCE_FLAGS_NONE},
             {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_TEMP_SPECULAR_RAY_SWAP,
-             L"BrixelizerGI_TempSpecularRaySwap",
+             "BrixelizerGI_TempSpecularRaySwap",
              FFX_RESOURCE_TYPE_BUFFER,
              FFX_RESOURCE_USAGE_UAV,
              FFX_SURFACE_FORMAT_R32_FLOAT,
@@ -1050,7 +1053,7 @@ static FfxErrorCode brixelizerGICreate(FfxBrixelizerGIContext_Private* pContext,
              1,
              FFX_RESOURCE_FLAGS_NONE},
             {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_TEMP_PROBE_SH,
-             L"BrixelizerGI_TempProbeSH",
+             "BrixelizerGI_TempProbeSH",
              FFX_RESOURCE_TYPE_BUFFER,
              FFX_RESOURCE_USAGE_UAV,
              FFX_SURFACE_FORMAT_R32_FLOAT,
@@ -1059,7 +1062,7 @@ static FfxErrorCode brixelizerGICreate(FfxBrixelizerGIContext_Private* pContext,
              1,
              FFX_RESOURCE_FLAGS_NONE},
             {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_RAY_SWAP_INDIRECT_ARGS,
-             L"BrixelizerGI_RaySwapIndirectArgs",
+             "BrixelizerGI_RaySwapIndirectArgs",
              FFX_RESOURCE_TYPE_BUFFER,
              FfxResourceUsage(FFX_RESOURCE_USAGE_UAV | FFX_RESOURCE_USAGE_INDIRECT),
              FFX_SURFACE_FORMAT_R32_FLOAT,
@@ -1099,7 +1102,7 @@ static FfxErrorCode brixelizerGICreate(FfxBrixelizerGIContext_Private* pContext,
     {
         const FfxInternalResourceDescription internalSurfaceDesc[] = {
             {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_DOWNSAMPLED_DEPTH,
-             L"BrixelizerGI_DownsampledDepth",
+             "BrixelizerGI_DownsampledDepth",
              FFX_RESOURCE_TYPE_TEXTURE2D,
              FFX_RESOURCE_USAGE_UAV,
              FFX_SURFACE_FORMAT_R32_FLOAT,
@@ -1108,7 +1111,7 @@ static FfxErrorCode brixelizerGICreate(FfxBrixelizerGIContext_Private* pContext,
              1,
              FFX_RESOURCE_FLAGS_NONE},
             {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_DOWNSAMPLED_HISTORY_DEPTH,
-             L"BrixelizerGI_DownsampledHistoryDepth",
+             "BrixelizerGI_DownsampledHistoryDepth",
              FFX_RESOURCE_TYPE_TEXTURE2D,
              FFX_RESOURCE_USAGE_UAV,
              FFX_SURFACE_FORMAT_R32_FLOAT,
@@ -1117,7 +1120,7 @@ static FfxErrorCode brixelizerGICreate(FfxBrixelizerGIContext_Private* pContext,
              1,
              FFX_RESOURCE_FLAGS_NONE},
             {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_DOWNSAMPLED_NORMAL,
-             L"BrixelizerGI_DownsampledNormals",
+             "BrixelizerGI_DownsampledNormals",
              FFX_RESOURCE_TYPE_TEXTURE2D,
              FFX_RESOURCE_USAGE_UAV,
              FFX_SURFACE_FORMAT_R16G16B16A16_FLOAT,
@@ -1126,7 +1129,7 @@ static FfxErrorCode brixelizerGICreate(FfxBrixelizerGIContext_Private* pContext,
              1,
              FFX_RESOURCE_FLAGS_NONE},
             {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_DOWNSAMPLED_HISTORY_NORMAL,
-             L"BrixelizerGI_DownsampledHistoryNormals",
+             "BrixelizerGI_DownsampledHistoryNormals",
              FFX_RESOURCE_TYPE_TEXTURE2D,
              FFX_RESOURCE_USAGE_UAV,
              FFX_SURFACE_FORMAT_R16G16B16A16_FLOAT,
@@ -1135,7 +1138,7 @@ static FfxErrorCode brixelizerGICreate(FfxBrixelizerGIContext_Private* pContext,
              1,
              FFX_RESOURCE_FLAGS_NONE},
             {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_DOWNSAMPLED_ROUGHNESS,
-             L"BrixelizerGI_DownsampledRoughness",
+             "BrixelizerGI_DownsampledRoughness",
              FFX_RESOURCE_TYPE_TEXTURE2D,
              FFX_RESOURCE_USAGE_UAV,
              FFX_SURFACE_FORMAT_R8_UNORM,
@@ -1144,7 +1147,7 @@ static FfxErrorCode brixelizerGICreate(FfxBrixelizerGIContext_Private* pContext,
              1,
              FFX_RESOURCE_FLAGS_NONE},
             {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_DOWNSAMPLED_MOTION_VECTORS,
-             L"BrixelizerGI_DownsampledMotionVectors",
+             "BrixelizerGI_DownsampledMotionVectors",
              FFX_RESOURCE_TYPE_TEXTURE2D,
              FFX_RESOURCE_USAGE_UAV,
              FFX_SURFACE_FORMAT_R16G16_FLOAT,
@@ -1153,7 +1156,7 @@ static FfxErrorCode brixelizerGICreate(FfxBrixelizerGIContext_Private* pContext,
              1,
              FFX_RESOURCE_FLAGS_NONE},
             {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_DOWNSAMPLED_LIT_OUTPUT,
-             L"BrixelizerGI_DownsampledLitOutput",
+             "BrixelizerGI_DownsampledLitOutput",
              FFX_RESOURCE_TYPE_TEXTURE2D,
              FFX_RESOURCE_USAGE_UAV,
              FFX_SURFACE_FORMAT_R16G16B16A16_FLOAT,
@@ -1162,7 +1165,7 @@ static FfxErrorCode brixelizerGICreate(FfxBrixelizerGIContext_Private* pContext,
              1,
              FFX_RESOURCE_FLAGS_NONE},
             {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_DOWNSAMPLED_DIFFUSE_GI,
-             L"BrixelizerGI_DownsampledDiffuseGI",
+             "BrixelizerGI_DownsampledDiffuseGI",
              FFX_RESOURCE_TYPE_TEXTURE2D,
              FFX_RESOURCE_USAGE_UAV,
              FFX_SURFACE_FORMAT_R16G16B16A16_FLOAT,
@@ -1171,7 +1174,7 @@ static FfxErrorCode brixelizerGICreate(FfxBrixelizerGIContext_Private* pContext,
              1,
              FFX_RESOURCE_FLAGS_NONE},
             {FFX_BRIXELIZER_GI_RESOURCE_IDENTIFIER_DOWNSAMPLED_SPECULAR_GI,
-             L"BrixelizerGI_DownsampledSpecularGI",
+             "BrixelizerGI_DownsampledSpecularGI",
              FFX_RESOURCE_TYPE_TEXTURE2D,
              FFX_RESOURCE_USAGE_UAV,
              FFX_SURFACE_FORMAT_R16G16B16A16_FLOAT,
@@ -1521,7 +1524,7 @@ static FfxErrorCode brixelizerGIDispatch(FfxBrixelizerGIContext_Private*
     if (pContext->frameIndex == 0) {
         FfxGpuJobDescription job        = {};
         job.jobType                     = FFX_GPU_JOB_CLEAR_FLOAT;
-        wcscpy_s(job.jobLabel, L"Clear Brixelizer GI Resource");
+        strcpy(job.jobLabel, "Clear Brixelizer GI Resource");
         job.clearJobDescriptor.color[0] = 0.0f;
         job.clearJobDescriptor.color[1] = 0.0f;
         job.clearJobDescriptor.color[2] = 0.0f;
diff --git a/sdk/src/components/cacao/CMakeLists.txt b/sdk/src/components/cacao/CMakeLists.txt
index 0b02ad7..258581e 100644
--- a/sdk/src/components/cacao/CMakeLists.txt
+++ b/sdk/src/components/cacao/CMakeLists.txt
@@ -38,9 +38,9 @@ if (FFX_CACAO OR FFX_ALL)
 	list(APPEND PUBLIC_SOURCES ${FFX_PUBLIC_SOURCES})
 
 	if (FFX_BUILD_AS_DLL)
-		add_library(ffx_cacao_${FFX_PLATFORM_NAME} SHARED ${SHARED_SOURCES} ${PRIVATE_SOURCES} ${PUBLIC_SOURCES})
+		add_library(cacao SHARED ${SHARED_SOURCES} ${PRIVATE_SOURCES} ${PUBLIC_SOURCES})
 	else()
-		add_library(ffx_cacao_${FFX_PLATFORM_NAME} STATIC ${SHARED_SOURCES} ${PRIVATE_SOURCES} ${PUBLIC_SOURCES})
+		add_library(cacao STATIC ${SHARED_SOURCES} ${PRIVATE_SOURCES} ${PUBLIC_SOURCES})
 	endif()
 
 	# API
@@ -48,10 +48,17 @@ if (FFX_CACAO OR FFX_ALL)
 	source_group("private_source" FILES ${PRIVATE_SOURCES})
 	source_group("public_source"  FILES ${PUBLIC_SOURCES})
 
-	target_include_directories(ffx_cacao_${FFX_PLATFORM_NAME} PUBLIC ${FFX_INCLUDE_PATH})
-	target_include_directories(ffx_cacao_${FFX_PLATFORM_NAME} PUBLIC ${FFX_SHARED_PATH})
+	target_include_directories(cacao PUBLIC
+		$<BUILD_INTERFACE:${FFX_INCLUDE_PATH}>
+		$<INSTALL_INTERFACE:include>)
+	target_include_directories(cacao PRIVATE ${FFX_SHARED_PATH})
 
 	set_source_files_properties(${SHADERS} PROPERTIES HEADER_FILE_ONLY TRUE)
-	set_target_properties(ffx_cacao_${FFX_PLATFORM_NAME} PROPERTIES FOLDER Components)
+	set_target_properties(cacao PROPERTIES FOLDER Components)
+	
+	install(TARGETS cacao EXPORT cacao-targets)
+	install(EXPORT cacao-targets 
+		DESTINATION "${CMAKE_INSTALL_DATADIR}/cmake/${PROJECT_NAME}"
+		NAMESPACE fidelityfx::)
 	
 endif()
diff --git a/sdk/src/components/cacao/ffx_cacao.cpp b/sdk/src/components/cacao/ffx_cacao.cpp
index 537df62..2fcd3db 100644
--- a/sdk/src/components/cacao/ffx_cacao.cpp
+++ b/sdk/src/components/cacao/ffx_cacao.cpp
@@ -65,35 +65,35 @@ inline static uint32_t dispatchSize(uint32_t tileSize, uint32_t totalSize)
 typedef struct ResourceBinding
 {
     uint32_t index;
-    wchar_t  name[64];
+    char     name[64];
 } ResourceBinding;
 
 static const ResourceBinding constantBufferBindingTable[] = {
-    {FFX_CACAO_CONSTANTBUFFER_IDENTIFIER_CACAO, L"SSAOConstantsBuffer"},
+    {FFX_CACAO_CONSTANTBUFFER_IDENTIFIER_CACAO, "SSAOConstantsBuffer"},
 };
 
 static const ResourceBinding srvTextureBindingTable[] = {
-    {FFX_CACAO_RESOURCE_IDENTIFIER_DEPTH_IN, L"g_DepthIn"},
-    {FFX_CACAO_RESOURCE_IDENTIFIER_NORMAL_IN, L"g_NormalIn"},
-    {FFX_CACAO_RESOURCE_IDENTIFIER_LOAD_COUNTER_BUFFER, L"g_LoadCounter"},
-    {FFX_CACAO_RESOURCE_IDENTIFIER_DEINTERLEAVED_DEPTHS, L"g_DeinterleavedDepth"},
-    {FFX_CACAO_RESOURCE_IDENTIFIER_DEINTERLEAVED_NORMALS, L"g_DeinterleavedNormals"},
-    {FFX_CACAO_RESOURCE_IDENTIFIER_SSAO_BUFFER_PING, L"g_SsaoBufferPing"},
-    {FFX_CACAO_RESOURCE_IDENTIFIER_SSAO_BUFFER_PONG, L"g_SsaoBufferPong"},
-    {FFX_CACAO_RESOURCE_IDENTIFIER_IMPORTANCE_MAP, L"g_ImportanceMap"},
-    {FFX_CACAO_RESOURCE_IDENTIFIER_IMPORTANCE_MAP_PONG, L"g_ImportanceMapPong"},
+    {FFX_CACAO_RESOURCE_IDENTIFIER_DEPTH_IN, "g_DepthIn"},
+    {FFX_CACAO_RESOURCE_IDENTIFIER_NORMAL_IN, "g_NormalIn"},
+    {FFX_CACAO_RESOURCE_IDENTIFIER_LOAD_COUNTER_BUFFER, "g_LoadCounter"},
+    {FFX_CACAO_RESOURCE_IDENTIFIER_DEINTERLEAVED_DEPTHS, "g_DeinterleavedDepth"},
+    {FFX_CACAO_RESOURCE_IDENTIFIER_DEINTERLEAVED_NORMALS, "g_DeinterleavedNormals"},
+    {FFX_CACAO_RESOURCE_IDENTIFIER_SSAO_BUFFER_PING, "g_SsaoBufferPing"},
+    {FFX_CACAO_RESOURCE_IDENTIFIER_SSAO_BUFFER_PONG, "g_SsaoBufferPong"},
+    {FFX_CACAO_RESOURCE_IDENTIFIER_IMPORTANCE_MAP, "g_ImportanceMap"},
+    {FFX_CACAO_RESOURCE_IDENTIFIER_IMPORTANCE_MAP_PONG, "g_ImportanceMapPong"},
 };
 
 static const ResourceBinding uavTextureBindingTable[] = {
-    {FFX_CACAO_RESOURCE_IDENTIFIER_LOAD_COUNTER_BUFFER, L"g_RwLoadCounter"},
-    {FFX_CACAO_RESOURCE_IDENTIFIER_DEINTERLEAVED_DEPTHS, L"g_RwDeinterleavedDepth"},
-    {FFX_CACAO_RESOURCE_IDENTIFIER_DEINTERLEAVED_NORMALS, L"g_RwDeinterleavedNormals"},
-    {FFX_CACAO_RESOURCE_IDENTIFIER_SSAO_BUFFER_PING, L"g_RwSsaoBufferPing"},
-    {FFX_CACAO_RESOURCE_IDENTIFIER_SSAO_BUFFER_PONG, L"g_RwSsaoBufferPong"},
-    {FFX_CACAO_RESOURCE_IDENTIFIER_IMPORTANCE_MAP, L"g_RwImportanceMap"},
-    {FFX_CACAO_RESOURCE_IDENTIFIER_IMPORTANCE_MAP_PONG, L"g_RwImportanceMapPong"},
-    {FFX_CACAO_RESOURCE_IDENTIFIER_OUTPUT, L"g_RwOutput"},
-    {FFX_CACAO_RESOURCE_IDENTIFIER_DOWNSAMPLED_DEPTH_MIPMAP_0, L"g_RwDepthMips"},
+    {FFX_CACAO_RESOURCE_IDENTIFIER_LOAD_COUNTER_BUFFER, "g_RwLoadCounter"},
+    {FFX_CACAO_RESOURCE_IDENTIFIER_DEINTERLEAVED_DEPTHS, "g_RwDeinterleavedDepth"},
+    {FFX_CACAO_RESOURCE_IDENTIFIER_DEINTERLEAVED_NORMALS, "g_RwDeinterleavedNormals"},
+    {FFX_CACAO_RESOURCE_IDENTIFIER_SSAO_BUFFER_PING, "g_RwSsaoBufferPing"},
+    {FFX_CACAO_RESOURCE_IDENTIFIER_SSAO_BUFFER_PONG, "g_RwSsaoBufferPong"},
+    {FFX_CACAO_RESOURCE_IDENTIFIER_IMPORTANCE_MAP, "g_RwImportanceMap"},
+    {FFX_CACAO_RESOURCE_IDENTIFIER_IMPORTANCE_MAP_PONG, "g_RwImportanceMapPong"},
+    {FFX_CACAO_RESOURCE_IDENTIFIER_OUTPUT, "g_RwOutput"},
+    {FFX_CACAO_RESOURCE_IDENTIFIER_DOWNSAMPLED_DEPTH_MIPMAP_0, "g_RwDepthMips"},
 };
 
 void ffxCacaoUpdateBufferSizeInfo(const uint32_t width, const uint32_t height, const bool useDownsampledSsao, FfxCacaoBufferSizeInfo* bsi)
@@ -335,7 +335,7 @@ static FfxErrorCode patchResourceBindings(FfxPipelineState* inoutPipeline)
         int32_t mapIndex = 0;
         for (mapIndex = 0; mapIndex < FFX_CACAO_ARRAY_SIZE(srvTextureBindingTable); ++mapIndex)
         {
-            if (0 == wcscmp(srvTextureBindingTable[mapIndex].name, inoutPipeline->srvTextureBindings[srvIndex].name))
+            if (0 == strcmp(srvTextureBindingTable[mapIndex].name, inoutPipeline->srvTextureBindings[srvIndex].name))
                 break;
         }
         if (mapIndex == FFX_CACAO_ARRAY_SIZE(srvTextureBindingTable))
@@ -349,7 +349,7 @@ static FfxErrorCode patchResourceBindings(FfxPipelineState* inoutPipeline)
         int32_t mapIndex = 0;
         for (mapIndex = 0; mapIndex < FFX_CACAO_ARRAY_SIZE(uavTextureBindingTable); ++mapIndex)
         {
-            if (0 == wcscmp(uavTextureBindingTable[mapIndex].name, inoutPipeline->uavTextureBindings[uavIndex].name))
+            if (0 == strcmp(uavTextureBindingTable[mapIndex].name, inoutPipeline->uavTextureBindings[uavIndex].name))
                 break;
         }
         if (mapIndex == FFX_CACAO_ARRAY_SIZE(uavTextureBindingTable))
@@ -363,7 +363,7 @@ static FfxErrorCode patchResourceBindings(FfxPipelineState* inoutPipeline)
         int32_t mapIndex = 0;
         for (mapIndex = 0; mapIndex < FFX_CACAO_ARRAY_SIZE(constantBufferBindingTable); ++mapIndex)
         {
-            if (0 == wcscmp(constantBufferBindingTable[mapIndex].name, inoutPipeline->constantBufferBindings[cbIndex].name))
+            if (0 == strcmp(constantBufferBindingTable[mapIndex].name, inoutPipeline->constantBufferBindings[cbIndex].name))
                 break;
         }
         if (mapIndex == FFX_CACAO_ARRAY_SIZE(constantBufferBindingTable))
@@ -482,103 +482,103 @@ static FfxErrorCode createPipelineStates(FfxCacaoContext_Private* context)
     }
 
     // Set up pipeline descriptors (basically RootSignature and binding)
-    wcscpy_s(pipelineDescription.name, L"CACAO-CLEAR_LOAD_COUNTER");
+    strcpy(pipelineDescription.name, "CACAO-CLEAR_LOAD_COUNTER");
     createCacaoPipeline(context, pipelineDescription, &context->pipelineClearLoadCounter, FFX_CACAO_PASS_CLEAR_LOAD_COUNTER, false, canForceWave64);
 
-    wcscpy_s(pipelineDescription.name, L"CACAO-PREPARE_DOWNSAMPLED_DEPTHS");
+    strcpy(pipelineDescription.name, "CACAO-PREPARE_DOWNSAMPLED_DEPTHS");
     createCacaoPipeline(context, pipelineDescription, &context->pipelinePrepareDownsampledDepths, FFX_CACAO_PASS_PREPARE_DOWNSAMPLED_DEPTHS, false, canForceWave64);
 
-    wcscpy_s(pipelineDescription.name, L"CACAO-PREPARE_NATIVE_DEPTHS");
+    strcpy(pipelineDescription.name, "CACAO-PREPARE_NATIVE_DEPTHS");
     createCacaoPipeline(context, pipelineDescription, &context->pipelinePrepareNativeDepths, FFX_CACAO_PASS_PREPARE_NATIVE_DEPTHS, false, canForceWave64);
 
-    wcscpy_s(pipelineDescription.name, L"CACAO-PREPARE_DOWNSAMPLED_DEPTHS_AND_MIPS");
+    strcpy(pipelineDescription.name, "CACAO-PREPARE_DOWNSAMPLED_DEPTHS_AND_MIPS");
     createCacaoPipeline(context, pipelineDescription, &context->pipelinePrepareDownsampledDepthsAndMips, FFX_CACAO_PASS_PREPARE_DOWNSAMPLED_DEPTHS_AND_MIPS, false, canForceWave64);
 
     createCacaoPipeline(context, pipelineDescription, &context->pipelinePrepareNativeDepthsAndMips, FFX_CACAO_PASS_PREPARE_NATIVE_DEPTHS_AND_MIPS, false, canForceWave64);
-    wcscpy_s(pipelineDescription.name, L"CACAO-PREPARE_NATIVE_DEPTHS_AND_MIPS");
+    strcpy(pipelineDescription.name, "CACAO-PREPARE_NATIVE_DEPTHS_AND_MIPS");
 
-    wcscpy_s(pipelineDescription.name, L"CACAO-PREPARE_DOWNSAMPLED_DEPTHS_HALF");
+    strcpy(pipelineDescription.name, "CACAO-PREPARE_DOWNSAMPLED_DEPTHS_HALF");
     createCacaoPipeline(context, pipelineDescription, &context->pipelinePrepareDownsampledDepthsHalf, FFX_CACAO_PASS_PREPARE_DOWNSAMPLED_DEPTHS_HALF, supportedFP16, canForceWave64);
 
-    wcscpy_s(pipelineDescription.name, L"CACAO-PREPARE_NATIVE_DEPTHS_HALF");
+    strcpy(pipelineDescription.name, "CACAO-PREPARE_NATIVE_DEPTHS_HALF");
     createCacaoPipeline(context, pipelineDescription,  &context->pipelinePrepareNativeDepthsHalf, FFX_CACAO_PASS_PREPARE_NATIVE_DEPTHS_HALF, supportedFP16, canForceWave64);
 
-    wcscpy_s(pipelineDescription.name, L"CACAO-PREPARE_DOWNSAMPLED_NORMALS");
+    strcpy(pipelineDescription.name, "CACAO-PREPARE_DOWNSAMPLED_NORMALS");
     createCacaoPipeline(context, pipelineDescription, &context->pipelinePrepareDownsampledNormals, FFX_CACAO_PASS_PREPARE_DOWNSAMPLED_NORMALS, false, canForceWave64);
 
-    wcscpy_s(pipelineDescription.name, L"CACAO-PREPARE_NATIVE_NORMALS");
+    strcpy(pipelineDescription.name, "CACAO-PREPARE_NATIVE_NORMALS");
     createCacaoPipeline(context, pipelineDescription, &context->pipelinePrepareNativeNormals, FFX_CACAO_PASS_PREPARE_NATIVE_NORMALS, false, canForceWave64);
 
-    wcscpy_s(pipelineDescription.name, L"CACAO-PREPARE_DOWNSAMPLED_NORMALS_FROM_INPUT_NORMALS");
+    strcpy(pipelineDescription.name, "CACAO-PREPARE_DOWNSAMPLED_NORMALS_FROM_INPUT_NORMALS");
     createCacaoPipeline(context, pipelineDescription, &context->pipelinePrepareDownsampledNormalsFromInputNormals, FFX_CACAO_PASS_PREPARE_DOWNSAMPLED_NORMALS_FROM_INPUT_NORMALS, false, canForceWave64);
 
-    wcscpy_s(pipelineDescription.name, L"CACAO-PREPARE_NATIVE_NORMALS_FROM_INPUT_NORMALS");
+    strcpy(pipelineDescription.name, "CACAO-PREPARE_NATIVE_NORMALS_FROM_INPUT_NORMALS");
     createCacaoPipeline(context, pipelineDescription, &context->pipelinePrepareNativeNormalsFromInputNormals, FFX_CACAO_PASS_PREPARE_NATIVE_NORMALS_FROM_INPUT_NORMALS, false, canForceWave64);
 
-    wcscpy_s(pipelineDescription.name, L"CACAO-GENERATE_Q0");
+    strcpy(pipelineDescription.name, "CACAO-GENERATE_Q0");
     createCacaoPipeline(context, pipelineDescription, &context->pipelineGenerateQ[0], FFX_CACAO_PASS_GENERATE_Q0, false, canForceWave64);
     
-    wcscpy_s(pipelineDescription.name, L"CACAO-GENERATE_Q1");
+    strcpy(pipelineDescription.name, "CACAO-GENERATE_Q1");
     createCacaoPipeline(context, pipelineDescription, &context->pipelineGenerateQ[1], FFX_CACAO_PASS_GENERATE_Q1, false, canForceWave64);
 
-    wcscpy_s(pipelineDescription.name, L"CACAO-GENERATE_Q2");
+    strcpy(pipelineDescription.name, "CACAO-GENERATE_Q2");
     createCacaoPipeline(context, pipelineDescription, &context->pipelineGenerateQ[2], FFX_CACAO_PASS_GENERATE_Q2, false, canForceWave64);
 
-    wcscpy_s(pipelineDescription.name, L"CACAO-GENERATE_Q3");
+    strcpy(pipelineDescription.name, "CACAO-GENERATE_Q3");
     createCacaoPipeline(context, pipelineDescription, &context->pipelineGenerateQ[3], FFX_CACAO_PASS_GENERATE_Q3, false, canForceWave64);
 
-    wcscpy_s(pipelineDescription.name, L"CACAO-GENERATE_Q3_BASE");
+    strcpy(pipelineDescription.name, "CACAO-GENERATE_Q3_BASE");
     createCacaoPipeline(context, pipelineDescription, &context->pipelineGenerateQ[4], FFX_CACAO_PASS_GENERATE_Q3_BASE, false, canForceWave64);
     
-    wcscpy_s(pipelineDescription.name, L"CACAO-GENERATE_IMPORTANCE_MAP");
+    strcpy(pipelineDescription.name, "CACAO-GENERATE_IMPORTANCE_MAP");
     createCacaoPipeline(context, pipelineDescription, &context->pipelineGenerateImportanceMap, FFX_CACAO_PASS_GENERATE_IMPORTANCE_MAP, false, canForceWave64);
 
-    wcscpy_s(pipelineDescription.name, L"CACAO-POST_PROCESS_IMPORTANCE_MAP_A");
+    strcpy(pipelineDescription.name, "CACAO-POST_PROCESS_IMPORTANCE_MAP_A");
     createCacaoPipeline(context, pipelineDescription, &context->pipelineProcessImportanceMapA, FFX_CACAO_PASS_POST_PROCESS_IMPORTANCE_MAP_A, false, canForceWave64);
 
-    wcscpy_s(pipelineDescription.name, L"CACAO-POST_PROCESS_IMPORTANCE_MAP_B");
+    strcpy(pipelineDescription.name, "CACAO-POST_PROCESS_IMPORTANCE_MAP_B");
     createCacaoPipeline(context, pipelineDescription, &context->pipelineProcessImportanceMapB, FFX_CACAO_PASS_POST_PROCESS_IMPORTANCE_MAP_B, false, canForceWave64);
 
-    wcscpy_s(pipelineDescription.name, L"CACAO-EDGE_SENSITIVE_BLUR_1");
+    strcpy(pipelineDescription.name, "CACAO-EDGE_SENSITIVE_BLUR_1");
     createCacaoPipeline(context, pipelineDescription, &context->pipelineEdgeSensitiveBlur[0], FFX_CACAO_PASS_EDGE_SENSITIVE_BLUR_1, false, canForceWave64);
 
-    wcscpy_s(pipelineDescription.name, L"CACAO-EDGE_SENSITIVE_BLUR_2");
+    strcpy(pipelineDescription.name, "CACAO-EDGE_SENSITIVE_BLUR_2");
     createCacaoPipeline(context, pipelineDescription, &context->pipelineEdgeSensitiveBlur[1], FFX_CACAO_PASS_EDGE_SENSITIVE_BLUR_2, false, canForceWave64);
 
-    wcscpy_s(pipelineDescription.name, L"CACAO-EDGE_SENSITIVE_BLUR_3");
+    strcpy(pipelineDescription.name, "CACAO-EDGE_SENSITIVE_BLUR_3");
     createCacaoPipeline(context, pipelineDescription, &context->pipelineEdgeSensitiveBlur[2], FFX_CACAO_PASS_EDGE_SENSITIVE_BLUR_3, false, canForceWave64);
 
-    wcscpy_s(pipelineDescription.name, L"CACAO-EDGE_SENSITIVE_BLUR_4");
+    strcpy(pipelineDescription.name, "CACAO-EDGE_SENSITIVE_BLUR_4");
     createCacaoPipeline(context, pipelineDescription, &context->pipelineEdgeSensitiveBlur[3], FFX_CACAO_PASS_EDGE_SENSITIVE_BLUR_4, false, canForceWave64);
 
-    wcscpy_s(pipelineDescription.name, L"CACAO-EDGE_SENSITIVE_BLUR_5");
+    strcpy(pipelineDescription.name, "CACAO-EDGE_SENSITIVE_BLUR_5");
     createCacaoPipeline(context, pipelineDescription, &context->pipelineEdgeSensitiveBlur[4], FFX_CACAO_PASS_EDGE_SENSITIVE_BLUR_5, false, canForceWave64);
 
-    wcscpy_s(pipelineDescription.name, L"CACAO-EDGE_SENSITIVE_BLUR_6");
+    strcpy(pipelineDescription.name, "CACAO-EDGE_SENSITIVE_BLUR_6");
     createCacaoPipeline(context, pipelineDescription, &context->pipelineEdgeSensitiveBlur[5], FFX_CACAO_PASS_EDGE_SENSITIVE_BLUR_6, false, canForceWave64);
 
-    wcscpy_s(pipelineDescription.name, L"CACAO-EDGE_SENSITIVE_BLUR_7");
+    strcpy(pipelineDescription.name, "CACAO-EDGE_SENSITIVE_BLUR_7");
     createCacaoPipeline(context, pipelineDescription, &context->pipelineEdgeSensitiveBlur[6], FFX_CACAO_PASS_EDGE_SENSITIVE_BLUR_7, false, canForceWave64);
 
-    wcscpy_s(pipelineDescription.name, L"CACAO-EDGE_SENSITIVE_BLUR_8");
+    strcpy(pipelineDescription.name, "CACAO-EDGE_SENSITIVE_BLUR_8");
     createCacaoPipeline(context, pipelineDescription, &context->pipelineEdgeSensitiveBlur[7], FFX_CACAO_PASS_EDGE_SENSITIVE_BLUR_8, false, canForceWave64);
 
-    wcscpy_s(pipelineDescription.name, L"CACAO-APPLY_NON_SMART_HALF");
+    strcpy(pipelineDescription.name, "CACAO-APPLY_NON_SMART_HALF");
     createCacaoPipeline(context, pipelineDescription, &context->pipelineApplyNonSmartHalf, FFX_CACAO_PASS_APPLY_NON_SMART_HALF, supportedFP16, canForceWave64);
 
-    wcscpy_s(pipelineDescription.name, L"CACAO-APPLY_NON_SMART");
+    strcpy(pipelineDescription.name, "CACAO-APPLY_NON_SMART");
     createCacaoPipeline(context, pipelineDescription, &context->pipelineApplyNonSmart, FFX_CACAO_PASS_APPLY_NON_SMART, false, canForceWave64);
 
-    wcscpy_s(pipelineDescription.name, L"CACAO-APPLY");
+    strcpy(pipelineDescription.name, "CACAO-APPLY");
     createCacaoPipeline(context, pipelineDescription, &context->pipelineApply, FFX_CACAO_PASS_APPLY, false, canForceWave64);
 
-    wcscpy_s(pipelineDescription.name, L"CACAO-UPSCALE_BILATERAL_5X5_HALF");
+    strcpy(pipelineDescription.name, "CACAO-UPSCALE_BILATERAL_5X5_HALF");
     createCacaoPipeline(context, pipelineDescription, &context->pipelineUpscaleBilateral5x5Half, FFX_CACAO_PASS_UPSCALE_BILATERAL_5X5, supportedFP16, canForceWave64);
 
-    wcscpy_s(pipelineDescription.name, L"CACAO-UPSCALE_BILATERAL_5X5_NON_SMART");
+    strcpy(pipelineDescription.name, "CACAO-UPSCALE_BILATERAL_5X5_NON_SMART");
     createCacaoPipeline(context, pipelineDescription, &context->pipelineUpscaleBilateral5x5NonSmart, FFX_CACAO_PASS_UPSCALE_BILATERAL_5X5, false, canForceWave64);
 
-    wcscpy_s(pipelineDescription.name, L"CACAO-UPSCALE_BILATERAL_5X5_SMART");
+    strcpy(pipelineDescription.name, "CACAO-UPSCALE_BILATERAL_5X5_SMART");
     createCacaoPipeline(context, pipelineDescription, &context->pipelineUpscaleBilateral5x5Smart, FFX_CACAO_PASS_UPSCALE_BILATERAL_5X5, false, canForceWave64, true);
 
     return FFX_OK;
@@ -632,7 +632,7 @@ static FfxErrorCode cacaoCreate(FfxCacaoContext_Private* context, const FfxCacao
     const FfxInternalResourceDescription internalSurfaceDesc[] = {
 
         {FFX_CACAO_RESOURCE_IDENTIFIER_DEINTERLEAVED_DEPTHS,
-         context->useDownsampledSsao ? L"CACAO_Deinterleaved_Depths_Downsampled" : L"CACAO_DeInterleaved_Depths",
+         context->useDownsampledSsao ? "CACAO_Deinterleaved_Depths_Downsampled" : "CACAO_DeInterleaved_Depths",
          FFX_RESOURCE_TYPE_TEXTURE2D,
          FFX_RESOURCE_USAGE_UAV,
          FFX_SURFACE_FORMAT_R16_FLOAT,
@@ -643,7 +643,7 @@ static FfxErrorCode cacaoCreate(FfxCacaoContext_Private* context, const FfxCacao
          {FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED}},
 
         {FFX_CACAO_RESOURCE_IDENTIFIER_DEINTERLEAVED_NORMALS,
-         context->useDownsampledSsao ? L"CACAO_DeInterleaved_Normals_Downsampled" : L"CACAO_DeInterleaved_Normals",
+         context->useDownsampledSsao ? "CACAO_DeInterleaved_Normals_Downsampled" : "CACAO_DeInterleaved_Normals",
          FFX_RESOURCE_TYPE_TEXTURE2D,
          FFX_RESOURCE_USAGE_UAV,
          FFX_SURFACE_FORMAT_R8G8B8A8_SNORM,
@@ -654,7 +654,7 @@ static FfxErrorCode cacaoCreate(FfxCacaoContext_Private* context, const FfxCacao
          {FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED}},
 
         {FFX_CACAO_RESOURCE_IDENTIFIER_SSAO_BUFFER_PING,
-         context->useDownsampledSsao ? L"CACAO_Ssao_Buffer_Ping_Downsampled" : L"CACAO_Ssao_Buffer_Ping",
+         context->useDownsampledSsao ? "CACAO_Ssao_Buffer_Ping_Downsampled" : "CACAO_Ssao_Buffer_Ping",
          FFX_RESOURCE_TYPE_TEXTURE2D,
          FFX_RESOURCE_USAGE_UAV,
          FFX_SURFACE_FORMAT_R8G8_UNORM,
@@ -665,7 +665,7 @@ static FfxErrorCode cacaoCreate(FfxCacaoContext_Private* context, const FfxCacao
          {FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED}},
 
         {FFX_CACAO_RESOURCE_IDENTIFIER_SSAO_BUFFER_PONG,
-         context->useDownsampledSsao ? L"CACAO_Ssao_Buffer_Pong_Downsampled" : L"CACAO_Ssao_Buffer_Pong",
+         context->useDownsampledSsao ? "CACAO_Ssao_Buffer_Pong_Downsampled" : "CACAO_Ssao_Buffer_Pong",
          FFX_RESOURCE_TYPE_TEXTURE2D,
          FFX_RESOURCE_USAGE_UAV,
          FFX_SURFACE_FORMAT_R8G8_UNORM,
@@ -676,7 +676,7 @@ static FfxErrorCode cacaoCreate(FfxCacaoContext_Private* context, const FfxCacao
          {FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED}},
 
         {FFX_CACAO_RESOURCE_IDENTIFIER_IMPORTANCE_MAP,
-         context->useDownsampledSsao ? L"CACAO_Importance_Map_Downsampled" : L"CACAO_Importance_Map",
+         context->useDownsampledSsao ? "CACAO_Importance_Map_Downsampled" : "CACAO_Importance_Map",
          FFX_RESOURCE_TYPE_TEXTURE2D,
          FFX_RESOURCE_USAGE_UAV,
          FFX_SURFACE_FORMAT_R8_UNORM,
@@ -687,7 +687,7 @@ static FfxErrorCode cacaoCreate(FfxCacaoContext_Private* context, const FfxCacao
          {FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED}},
 
         {FFX_CACAO_RESOURCE_IDENTIFIER_IMPORTANCE_MAP_PONG,
-         context->useDownsampledSsao ? L"CACAO_Importance_Map_Pong_Downsampled" : L"CACAO_Importance_Map_Pong",
+         context->useDownsampledSsao ? "CACAO_Importance_Map_Pong_Downsampled" : "CACAO_Importance_Map_Pong",
          FFX_RESOURCE_TYPE_TEXTURE2D,
          FFX_RESOURCE_USAGE_UAV,
          FFX_SURFACE_FORMAT_R8_UNORM,
@@ -713,7 +713,7 @@ static FfxErrorCode cacaoCreate(FfxCacaoContext_Private* context, const FfxCacao
     // Create load counter
     {
         const FfxInternalResourceDescription internalSurfaceDesc = {FFX_CACAO_RESOURCE_IDENTIFIER_LOAD_COUNTER_BUFFER,
-                                                                    context->useDownsampledSsao ? L"CACAO::m_loadCounterDownsampled" : L"CACAO::m_loadCounter",
+                                                                    context->useDownsampledSsao ? "CACAO::m_loadCounterDownsampled" : "CACAO::m_loadCounter",
                                                                     FFX_RESOURCE_TYPE_TEXTURE1D,
                                                                     FFX_RESOURCE_USAGE_UAV,
                                                                     FFX_SURFACE_FORMAT_UNKNOWN,
@@ -834,7 +834,7 @@ static void scheduleDispatch(
     FfxCacaoContext_Private* context, const FfxPipelineState* pipeline, const uint32_t dispatchX, const uint32_t dispatchY, const uint32_t dispatchZ, const uint32_t flags = 0)
 {
     FfxGpuJobDescription dispatchJob = {FFX_GPU_JOB_COMPUTE};
-    wcscpy_s(dispatchJob.jobLabel, pipeline->name);
+    strcpy(dispatchJob.jobLabel, pipeline->name);
     const size_t size                      = sizeof(dispatchJob);
 
     for (uint32_t currentShaderResourceViewIndex = 0; currentShaderResourceViewIndex < pipeline->srvTextureCount; ++currentShaderResourceViewIndex)
@@ -849,7 +849,7 @@ static void scheduleDispatch(
 
         dispatchJob.computeJobDescriptor.srvTextures[currentShaderResourceViewIndex].resource = currentResource;
 #ifdef FFX_DEBUG
-        wcscpy_s(dispatchJob.computeJobDescriptor.srvTextures[currentShaderResourceViewIndex].name,
+        strcpy(dispatchJob.computeJobDescriptor.srvTextures[currentShaderResourceViewIndex].name,
                  pipeline->srvTextureBindings[currentShaderResourceViewIndex].name);
 #endif
     }
@@ -860,7 +860,7 @@ static void scheduleDispatch(
         uint32_t       bindEntry         = pipeline->uavTextureBindings[currentUnorderedAccessViewIndex].arrayIndex;
         const uint32_t currentResourceId = pipeline->uavTextureBindings[currentUnorderedAccessViewIndex].resourceIdentifier;
 #ifdef FFX_DEBUG
-        wcscpy_s(dispatchJob.computeJobDescriptor.uavTextures[currentUnorderedAccessViewIndex].name,
+        strcpy(dispatchJob.computeJobDescriptor.uavTextures[currentUnorderedAccessViewIndex].name,
                  pipeline->uavTextureBindings[currentUnorderedAccessViewIndex].name);
 #endif
         if (currentResourceId == FFX_CACAO_RESOURCE_IDENTIFIER_DOWNSAMPLED_DEPTH_MIPMAP_0)
@@ -891,7 +891,7 @@ static void scheduleDispatch(
     dispatchJob.computeJobDescriptor.pipeline      = *pipeline;
 
 #ifdef FFX_DEBUG
-    wcscpy_s(dispatchJob.computeJobDescriptor.cbNames[0], pipeline->constantBufferBindings[0].name);
+    strcpy(dispatchJob.computeJobDescriptor.cbNames[0], pipeline->constantBufferBindings[0].name);
 #endif
     dispatchJob.computeJobDescriptor.cbs[0] = context->constantBuffer;
 
@@ -938,7 +938,7 @@ static FfxErrorCode cacaoDispatch(FfxCacaoContext_Private* context,
     // clear load counter
     {
         FfxGpuJobDescription clearJob      = {FFX_GPU_JOB_CLEAR_FLOAT};
-        wcscpy_s(clearJob.jobLabel, L"Clear Load Counter");
+        strcpy(clearJob.jobLabel, "Clear Load Counter");
         uint32_t             clearValues[] = {0, 0, 0, 0};
         memcpy(clearJob.clearJobDescriptor.color, clearValues, sizeof(uint32_t) * FFX_CACAO_ARRAY_SIZE(clearJob.clearJobDescriptor.color));
         clearJob.clearJobDescriptor.target = context->textures[FFX_CACAO_RESOURCE_IDENTIFIER_LOAD_COUNTER_BUFFER];
diff --git a/sdk/src/components/cas/CMakeLists.txt b/sdk/src/components/cas/CMakeLists.txt
index b189b78..8abb6a0 100644
--- a/sdk/src/components/cas/CMakeLists.txt
+++ b/sdk/src/components/cas/CMakeLists.txt
@@ -38,9 +38,9 @@ if (FFX_CAS OR FFX_ALL)
 	list(APPEND PUBLIC_SOURCES ${FFX_PUBLIC_SOURCES})
 
 	if (FFX_BUILD_AS_DLL)
-		add_library(ffx_cas_${FFX_PLATFORM_NAME} SHARED ${SHARED_SOURCES} ${PRIVATE_SOURCES} ${PUBLIC_SOURCES})
+		add_library(cas SHARED ${SHARED_SOURCES} ${PRIVATE_SOURCES} ${PUBLIC_SOURCES})
 	else()
-		add_library(ffx_cas_${FFX_PLATFORM_NAME} STATIC ${SHARED_SOURCES} ${PRIVATE_SOURCES} ${PUBLIC_SOURCES})
+		add_library(cas STATIC ${SHARED_SOURCES} ${PRIVATE_SOURCES} ${PUBLIC_SOURCES})
 	endif()
 
 	# API
@@ -48,10 +48,17 @@ if (FFX_CAS OR FFX_ALL)
 	source_group("private_source" FILES ${PRIVATE_SOURCES})
 	source_group("public_source"  FILES ${PUBLIC_SOURCES})
 
-	target_include_directories(ffx_cas_${FFX_PLATFORM_NAME} PUBLIC ${FFX_INCLUDE_PATH})
-	target_include_directories(ffx_cas_${FFX_PLATFORM_NAME} PUBLIC ${FFX_SHARED_PATH})
+	target_include_directories(cas PUBLIC
+		$<BUILD_INTERFACE:${FFX_INCLUDE_PATH}>
+		$<INSTALL_INTERFACE:include>)
+	target_include_directories(cas PRIVATE ${FFX_SHARED_PATH})
 
 	set_source_files_properties(${SHADERS} PROPERTIES HEADER_FILE_ONLY TRUE)
-	set_target_properties(ffx_cas_${FFX_PLATFORM_NAME} PROPERTIES FOLDER Components)
+	set_target_properties(cas PROPERTIES FOLDER Components)
+	
+	install(TARGETS cas EXPORT cas-targets)
+	install(EXPORT cas-targets 
+		DESTINATION "${CMAKE_INSTALL_DATADIR}/cmake/${PROJECT_NAME}"
+		NAMESPACE fidelityfx::)
 	
 endif()
diff --git a/sdk/src/components/cas/ffx_cas.cpp b/sdk/src/components/cas/ffx_cas.cpp
index 0ad1b54..bf9e771 100644
--- a/sdk/src/components/cas/ffx_cas.cpp
+++ b/sdk/src/components/cas/ffx_cas.cpp
@@ -20,8 +20,9 @@
 // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 // THE SOFTWARE.
 
+#include <array>     // for std::size
 #include <string.h>  // for memset
-#include <stdlib.h>  // for _countof
+#include <stdlib.h>  // 
 #include <cmath>     // for fabs, abs, sinf, sqrt, etc.
 
 #ifdef __clang__
@@ -40,19 +41,19 @@
 typedef struct ResourceBinding
 {
     uint32_t index;
-    wchar_t  name[64];
+    char     name[64];
 } ResourceBinding;
 
 static const ResourceBinding s_SrvResourceBindingTable[] = {
-    {FFX_CAS_RESOURCE_IDENTIFIER_INPUT_COLOR, L"r_input_color"},
+    {FFX_CAS_RESOURCE_IDENTIFIER_INPUT_COLOR, "r_input_color"},
 };
 
 static const ResourceBinding s_UavResourceBindingTable[] = {
-    {FFX_CAS_RESOURCE_IDENTIFIER_OUTPUT_COLOR, L"rw_output_color"},
+    {FFX_CAS_RESOURCE_IDENTIFIER_OUTPUT_COLOR, "rw_output_color"},
 };
 
 static const ResourceBinding s_CbResourceBindingTable[] = {
-    {FFX_CAS_CONSTANTBUFFER_IDENTIFIER_CAS, L"cbCAS"},
+    {FFX_CAS_CONSTANTBUFFER_IDENTIFIER_CAS, "cbCAS"},
 };
 
 static FfxErrorCode patchResourceBindings(FfxPipelineState* inoutPipeline)
@@ -60,12 +61,12 @@ static FfxErrorCode patchResourceBindings(FfxPipelineState* inoutPipeline)
     for (uint32_t srvIndex = 0; srvIndex < inoutPipeline->srvTextureCount; ++srvIndex)
     {
         int32_t mapIndex = 0;
-        for (mapIndex = 0; mapIndex < _countof(s_SrvResourceBindingTable); ++mapIndex)
+        for (mapIndex = 0; mapIndex < std::size(s_SrvResourceBindingTable); ++mapIndex)
         {
-            if (0 == wcscmp(s_SrvResourceBindingTable[mapIndex].name, inoutPipeline->srvTextureBindings[srvIndex].name))
+            if (0 == strcmp(s_SrvResourceBindingTable[mapIndex].name, inoutPipeline->srvTextureBindings[srvIndex].name))
                 break;
         }
-        if (mapIndex == _countof(s_SrvResourceBindingTable))
+        if (mapIndex == std::size(s_SrvResourceBindingTable))
             return FFX_ERROR_INVALID_ARGUMENT;
 
         inoutPipeline->srvTextureBindings[srvIndex].resourceIdentifier = s_SrvResourceBindingTable[mapIndex].index;
@@ -74,12 +75,12 @@ static FfxErrorCode patchResourceBindings(FfxPipelineState* inoutPipeline)
     for (uint32_t uavIndex = 0; uavIndex < inoutPipeline->uavTextureCount; ++uavIndex)
     {
         int32_t mapIndex = 0;
-        for (mapIndex = 0; mapIndex < _countof(s_UavResourceBindingTable); ++mapIndex)
+        for (mapIndex = 0; mapIndex < std::size(s_UavResourceBindingTable); ++mapIndex)
         {
-            if (0 == wcscmp(s_UavResourceBindingTable[mapIndex].name, inoutPipeline->uavTextureBindings[uavIndex].name))
+            if (0 == strcmp(s_UavResourceBindingTable[mapIndex].name, inoutPipeline->uavTextureBindings[uavIndex].name))
                 break;
         }
-        if (mapIndex == _countof(s_UavResourceBindingTable))
+        if (mapIndex == std::size(s_UavResourceBindingTable))
             return FFX_ERROR_INVALID_ARGUMENT;
 
         inoutPipeline->uavTextureBindings[uavIndex].resourceIdentifier = s_UavResourceBindingTable[mapIndex].index;
@@ -88,12 +89,12 @@ static FfxErrorCode patchResourceBindings(FfxPipelineState* inoutPipeline)
     for (uint32_t cbIndex = 0; cbIndex < inoutPipeline->constCount; ++cbIndex)
     {
         int32_t mapIndex = 0;
-        for (mapIndex = 0; mapIndex < _countof(s_CbResourceBindingTable); ++mapIndex)
+        for (mapIndex = 0; mapIndex < std::size(s_CbResourceBindingTable); ++mapIndex)
         {
-            if (0 == wcscmp(s_CbResourceBindingTable[mapIndex].name, inoutPipeline->constantBufferBindings[cbIndex].name))
+            if (0 == strcmp(s_CbResourceBindingTable[mapIndex].name, inoutPipeline->constantBufferBindings[cbIndex].name))
                 break;
         }
-        if (mapIndex == _countof(s_CbResourceBindingTable))
+        if (mapIndex == std::size(s_CbResourceBindingTable))
             return FFX_ERROR_INVALID_ARGUMENT;
 
         inoutPipeline->constantBufferBindings[cbIndex].resourceIdentifier = s_CbResourceBindingTable[mapIndex].index;
@@ -169,7 +170,7 @@ static FfxErrorCode createPipelineStates(FfxCasContext_Private* context)
     FfxCasColorSpaceConversion colorSpaceConversion = context->contextDescription.colorSpaceConversion;
 
     // Set up pipeline descriptors (basically RootSignature and binding)
-    wcscpy_s(pipelineDescription.name, L"CAS_SHARPEN");
+    strcpy(pipelineDescription.name, "CAS_SHARPEN");
     FFX_VALIDATE(context->contextDescription.backendInterface.fpCreatePipeline(
         &context->contextDescription.backendInterface,
         FFX_EFFECT_CAS,
@@ -188,7 +189,7 @@ static void scheduleDispatch(
     FfxCasContext_Private* context, const FfxCasDispatchDescription*, const FfxPipelineState* pipeline, uint32_t dispatchX, uint32_t dispatchY)
 {
     FfxGpuJobDescription dispatchJob = {FFX_GPU_JOB_COMPUTE};
-    wcscpy_s(dispatchJob.jobLabel, pipeline->name);
+    strcpy(dispatchJob.jobLabel, pipeline->name);
 
     for (uint32_t currentShaderResourceViewIndex = 0; currentShaderResourceViewIndex < pipeline->srvTextureCount; ++currentShaderResourceViewIndex)
     {
@@ -196,7 +197,7 @@ static void scheduleDispatch(
         const FfxResourceInternal currentResource                 = context->srvResources[currentResourceId];
         dispatchJob.computeJobDescriptor.srvTextures[currentShaderResourceViewIndex].resource = currentResource;
 #ifdef FFX_DEBUG
-        wcscpy_s(dispatchJob.computeJobDescriptor.srvTextures[currentShaderResourceViewIndex].name,
+        strcpy(dispatchJob.computeJobDescriptor.srvTextures[currentShaderResourceViewIndex].name,
                  pipeline->srvTextureBindings[currentShaderResourceViewIndex].name);
 #endif
     }
@@ -205,7 +206,7 @@ static void scheduleDispatch(
     {
         const uint32_t currentResourceId = pipeline->uavTextureBindings[currentUnorderedAccessViewIndex].resourceIdentifier;
 #ifdef FFX_DEBUG
-        wcscpy_s(dispatchJob.computeJobDescriptor.uavTextures[currentUnorderedAccessViewIndex].name,
+        strcpy(dispatchJob.computeJobDescriptor.uavTextures[currentUnorderedAccessViewIndex].name,
                  pipeline->uavTextureBindings[currentUnorderedAccessViewIndex].name);
 #endif
         const FfxResourceInternal currentResource                     = context->uavResources[currentResourceId];
@@ -218,7 +219,7 @@ static void scheduleDispatch(
     dispatchJob.computeJobDescriptor.dimensions[2] = 1;
     dispatchJob.computeJobDescriptor.pipeline      = *pipeline;
 #ifdef FFX_DEBUG
-    wcscpy_s(dispatchJob.computeJobDescriptor.cbNames[0], pipeline->constantBufferBindings[0].name);
+    strcpy(dispatchJob.computeJobDescriptor.cbNames[0], pipeline->constantBufferBindings[0].name);
 #endif
     dispatchJob.computeJobDescriptor.cbs[0] = context->constantBuffer;
 
diff --git a/sdk/src/components/classifier/CMakeLists.txt b/sdk/src/components/classifier/CMakeLists.txt
index b38e350..6b58fd0 100644
--- a/sdk/src/components/classifier/CMakeLists.txt
+++ b/sdk/src/components/classifier/CMakeLists.txt
@@ -38,9 +38,9 @@ if (FFX_CLASSIFIER OR FFX_ALL)
 	list(APPEND PUBLIC_SOURCES ${FFX_PUBLIC_SOURCES})
 
 	if (FFX_BUILD_AS_DLL)
-		add_library(ffx_classifier_${FFX_PLATFORM_NAME} SHARED ${SHARED_SOURCES} ${PRIVATE_SOURCES} ${PUBLIC_SOURCES})
+		add_library(classifier SHARED ${SHARED_SOURCES} ${PRIVATE_SOURCES} ${PUBLIC_SOURCES})
 	else()
-		add_library(ffx_classifier_${FFX_PLATFORM_NAME} STATIC ${SHARED_SOURCES} ${PRIVATE_SOURCES} ${PUBLIC_SOURCES})
+		add_library(classifier STATIC ${SHARED_SOURCES} ${PRIVATE_SOURCES} ${PUBLIC_SOURCES})
 	endif()
 
 	# API
@@ -48,10 +48,17 @@ if (FFX_CLASSIFIER OR FFX_ALL)
 	source_group("private_source" FILES ${PRIVATE_SOURCES})
 	source_group("public_source"  FILES ${PUBLIC_SOURCES})
 
-	target_include_directories(ffx_classifier_${FFX_PLATFORM_NAME} PUBLIC ${FFX_INCLUDE_PATH})
-	target_include_directories(ffx_classifier_${FFX_PLATFORM_NAME} PUBLIC ${FFX_SHARED_PATH})
+	target_include_directories(classifier PUBLIC
+		$<BUILD_INTERFACE:${FFX_INCLUDE_PATH}>
+		$<INSTALL_INTERFACE:include>)
+	target_include_directories(classifier PRIVATE ${FFX_SHARED_PATH})
 
 	set_source_files_properties(${SHADERS} PROPERTIES HEADER_FILE_ONLY TRUE)
-	set_target_properties(ffx_classifier_${FFX_PLATFORM_NAME} PROPERTIES FOLDER Components)
+	set_target_properties(classifier PROPERTIES FOLDER Components)
 
+	install(TARGETS classifier EXPORT classifier-targets)
+	install(EXPORT classifier-targets 
+		DESTINATION "${CMAKE_INSTALL_DATADIR}/cmake/${PROJECT_NAME}"
+		NAMESPACE fidelityfx::)
+	
 endif()
diff --git a/sdk/src/components/classifier/ffx_classifier.cpp b/sdk/src/components/classifier/ffx_classifier.cpp
index d6180ce..ffee656 100644
--- a/sdk/src/components/classifier/ffx_classifier.cpp
+++ b/sdk/src/components/classifier/ffx_classifier.cpp
@@ -20,8 +20,9 @@
 // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 // THE SOFTWARE.
 
+#include <array>        // for std::size
 #include <string.h>     // for memset
-#include <stdlib.h>     // for _countof
+#include <stdlib.h>     // for std::size
 #include <cmath>        // for fabs, abs, sinf, sqrt, etc.
 
 #define FFX_CPU
@@ -39,48 +40,48 @@ static constexpr uint32_t k_tileSizeY = 4;
 typedef struct ResourceBinding
 {
     uint32_t    index;
-    wchar_t     name[64];
+    char        name[64];
 }ResourceBinding;
 
 static const ResourceBinding srvTextureBindingTable[] =
 {
-    {FFX_CLASSIFIER_RESOURCE_IDENTIFIER_INPUT_DEPTH,                  L"r_input_depth"},
-    {FFX_CLASSIFIER_RESOURCE_IDENTIFIER_INPUT_NORMAL,                 L"r_input_normal"},
-    {FFX_CLASSIFIER_RESOURCE_IDENTIFIER_INPUT_MOTION_VECTORS,         L"r_input_motion_vectors"},
-    {FFX_CLASSIFIER_RESOURCE_IDENTIFIER_INPUT_SPECULAR_ROUGHNESS,     L"r_input_material_parameters"},
-    {FFX_CLASSIFIER_RESOURCE_IDENTIFIER_INPUT_ENVIRONMENT_MAP,        L"r_input_environment_map"},
-    {FFX_CLASSIFIER_RESOURCE_IDENTIFIER_HIT_COUNTER_HISTORY ,         L"r_hit_counter_history"},
-    {FFX_CLASSIFIER_RESOURCE_IDENTIFIER_VARIANCE_HISTORY,             L"r_variance_history"},
-    {FFX_CLASSIFIER_RESOURCE_IDENTIFIER_INPUT_SHADOW_MAPS,            L"r_input_shadowMap"},
+    {FFX_CLASSIFIER_RESOURCE_IDENTIFIER_INPUT_DEPTH,                  "r_input_depth"},
+    {FFX_CLASSIFIER_RESOURCE_IDENTIFIER_INPUT_NORMAL,                 "r_input_normal"},
+    {FFX_CLASSIFIER_RESOURCE_IDENTIFIER_INPUT_MOTION_VECTORS,         "r_input_motion_vectors"},
+    {FFX_CLASSIFIER_RESOURCE_IDENTIFIER_INPUT_SPECULAR_ROUGHNESS,     "r_input_material_parameters"},
+    {FFX_CLASSIFIER_RESOURCE_IDENTIFIER_INPUT_ENVIRONMENT_MAP,        "r_input_environment_map"},
+    {FFX_CLASSIFIER_RESOURCE_IDENTIFIER_HIT_COUNTER_HISTORY ,         "r_hit_counter_history"},
+    {FFX_CLASSIFIER_RESOURCE_IDENTIFIER_VARIANCE_HISTORY,             "r_variance_history"},
+    {FFX_CLASSIFIER_RESOURCE_IDENTIFIER_INPUT_SHADOW_MAPS,            "r_input_shadowMap"},
 };
 
 static const ResourceBinding srvBufferBindingTable[] =
 {
-    {FFX_CLASSIFIER_RESOURCE_IDENTIFIER_WORK_QUEUE,                   L"rsb_tiles"},
+    {FFX_CLASSIFIER_RESOURCE_IDENTIFIER_WORK_QUEUE,                   "rsb_tiles"},
 };
 
 static const ResourceBinding uavBufferBindingTable[] =
 {
-    {FFX_CLASSIFIER_RESOURCE_IDENTIFIER_WORK_QUEUE,                   L"rwsb_tiles"},
-    {FFX_CLASSIFIER_RESOURCE_IDENTIFIER_OUTPUT_WORK_QUEUE_COUNTER,    L"rwb_tileCount"},
-    {FFX_CLASSIFIER_RESOURCE_IDENTIFIER_RAY_LIST,                     L"rw_ray_list"},
-    {FFX_CLASSIFIER_RESOURCE_IDENTIFIER_HW_RAY_LIST,                  L"rw_hw_ray_list"},
-    {FFX_CLASSIFIER_RESOURCE_IDENTIFIER_DENOISER_TILE_LIST,           L"rw_denoiser_tile_list"},
-    {FFX_CLASSIFIER_RESOURCE_IDENTIFIER_RAY_COUNTER,                  L"rw_ray_counter"},
+    {FFX_CLASSIFIER_RESOURCE_IDENTIFIER_WORK_QUEUE,                   "rwsb_tiles"},
+    {FFX_CLASSIFIER_RESOURCE_IDENTIFIER_OUTPUT_WORK_QUEUE_COUNTER,    "rwb_tileCount"},
+    {FFX_CLASSIFIER_RESOURCE_IDENTIFIER_RAY_LIST,                     "rw_ray_list"},
+    {FFX_CLASSIFIER_RESOURCE_IDENTIFIER_HW_RAY_LIST,                  "rw_hw_ray_list"},
+    {FFX_CLASSIFIER_RESOURCE_IDENTIFIER_DENOISER_TILE_LIST,           "rw_denoiser_tile_list"},
+    {FFX_CLASSIFIER_RESOURCE_IDENTIFIER_RAY_COUNTER,                  "rw_ray_counter"},
 };
 
 static const ResourceBinding uavTextureBindingTable[] =
 {
-    {FFX_CLASSIFIER_RESOURCE_IDENTIFIER_OUTPUT_RAY_HIT,               L"rwt2d_rayHitResults"},
-    {FFX_CLASSIFIER_RESOURCE_IDENTIFIER_RADIANCE,                     L"rw_radiance"},
-    {FFX_CLASSIFIER_RESOURCE_IDENTIFIER_EXTRACTED_ROUGHNESS,          L"rw_extracted_roughness"},
-    {FFX_CLASSIFIER_RESOURCE_IDENTIFIER_HIT_COUNTER,                  L"rw_hit_counter"},
+    {FFX_CLASSIFIER_RESOURCE_IDENTIFIER_OUTPUT_RAY_HIT,               "rwt2d_rayHitResults"},
+    {FFX_CLASSIFIER_RESOURCE_IDENTIFIER_RADIANCE,                     "rw_radiance"},
+    {FFX_CLASSIFIER_RESOURCE_IDENTIFIER_EXTRACTED_ROUGHNESS,          "rw_extracted_roughness"},
+    {FFX_CLASSIFIER_RESOURCE_IDENTIFIER_HIT_COUNTER,                  "rw_hit_counter"},
 };
 
 static const ResourceBinding cbResourceBindingTable[] =
 {
-    {FFX_CLASSIFIER_CONSTANTBUFFER_IDENTIFIER_CLASSIFIER,             L"cbClassifier"},
-    {FFX_CLASSIFIER_CONSTANTBUFFER_IDENTIFIER_REFLECTION ,            L"cbClassifierReflection"},
+    {FFX_CLASSIFIER_CONSTANTBUFFER_IDENTIFIER_CLASSIFIER,             "cbClassifier"},
+    {FFX_CLASSIFIER_CONSTANTBUFFER_IDENTIFIER_REFLECTION ,            "cbClassifierReflection"},
 };
 
 static FfxErrorCode patchResourceBindings(FfxPipelineState* inoutPipeline)
@@ -88,12 +89,12 @@ static FfxErrorCode patchResourceBindings(FfxPipelineState* inoutPipeline)
     for (uint32_t srvIndex = 0; srvIndex < inoutPipeline->srvTextureCount; ++srvIndex)
     {
         int32_t mapIndex = 0;
-        for (mapIndex = 0; mapIndex < _countof(srvTextureBindingTable); ++mapIndex)
+        for (mapIndex = 0; mapIndex < std::size(srvTextureBindingTable); ++mapIndex)
         {
-            if (0 == wcscmp(srvTextureBindingTable[mapIndex].name, inoutPipeline->srvTextureBindings[srvIndex].name))
+            if (0 == strcmp(srvTextureBindingTable[mapIndex].name, inoutPipeline->srvTextureBindings[srvIndex].name))
                 break;
         }
-        if (mapIndex == _countof(srvTextureBindingTable))
+        if (mapIndex == std::size(srvTextureBindingTable))
             return FFX_ERROR_INVALID_ARGUMENT;
 
         inoutPipeline->srvTextureBindings[srvIndex].resourceIdentifier = srvTextureBindingTable[mapIndex].index;
@@ -102,12 +103,12 @@ static FfxErrorCode patchResourceBindings(FfxPipelineState* inoutPipeline)
     for (uint32_t srvIndex = 0; srvIndex < inoutPipeline->srvBufferCount; ++srvIndex)
     {
         int32_t mapIndex = 0;
-        for (mapIndex = 0; mapIndex < _countof(srvBufferBindingTable); ++mapIndex)
+        for (mapIndex = 0; mapIndex < std::size(srvBufferBindingTable); ++mapIndex)
         {
-            if (0 == wcscmp(srvBufferBindingTable[mapIndex].name, inoutPipeline->srvBufferBindings[srvIndex].name))
+            if (0 == strcmp(srvBufferBindingTable[mapIndex].name, inoutPipeline->srvBufferBindings[srvIndex].name))
                 break;
         }
-        if (mapIndex == _countof(srvBufferBindingTable))
+        if (mapIndex == std::size(srvBufferBindingTable))
             return FFX_ERROR_INVALID_ARGUMENT;
 
         inoutPipeline->srvBufferBindings[srvIndex].resourceIdentifier = srvBufferBindingTable[mapIndex].index;
@@ -116,12 +117,12 @@ static FfxErrorCode patchResourceBindings(FfxPipelineState* inoutPipeline)
     for (uint32_t uavIndex = 0; uavIndex < inoutPipeline->uavTextureCount; ++uavIndex)
     {
         int32_t mapIndex = 0;
-        for (mapIndex = 0; mapIndex < _countof(uavTextureBindingTable); ++mapIndex)
+        for (mapIndex = 0; mapIndex < std::size(uavTextureBindingTable); ++mapIndex)
         {
-            if (0 == wcscmp(uavTextureBindingTable[mapIndex].name, inoutPipeline->uavTextureBindings[uavIndex].name))
+            if (0 == strcmp(uavTextureBindingTable[mapIndex].name, inoutPipeline->uavTextureBindings[uavIndex].name))
                 break;
         }
-        if (mapIndex == _countof(uavTextureBindingTable))
+        if (mapIndex == std::size(uavTextureBindingTable))
             return FFX_ERROR_INVALID_ARGUMENT;
 
         inoutPipeline->uavTextureBindings[uavIndex].resourceIdentifier = uavTextureBindingTable[mapIndex].index;
@@ -130,12 +131,12 @@ static FfxErrorCode patchResourceBindings(FfxPipelineState* inoutPipeline)
     for (uint32_t uavIndex = 0; uavIndex < inoutPipeline->uavBufferCount; ++uavIndex)
     {
         int32_t mapIndex = 0;
-        for (mapIndex = 0; mapIndex < _countof(uavBufferBindingTable); ++mapIndex)
+        for (mapIndex = 0; mapIndex < std::size(uavBufferBindingTable); ++mapIndex)
         {
-            if (0 == wcscmp(uavBufferBindingTable[mapIndex].name, inoutPipeline->uavBufferBindings[uavIndex].name))
+            if (0 == strcmp(uavBufferBindingTable[mapIndex].name, inoutPipeline->uavBufferBindings[uavIndex].name))
                 break;
         }
-        if (mapIndex == _countof(uavBufferBindingTable))
+        if (mapIndex == std::size(uavBufferBindingTable))
             return FFX_ERROR_INVALID_ARGUMENT;
 
         inoutPipeline->uavBufferBindings[uavIndex].resourceIdentifier = uavBufferBindingTable[mapIndex].index;
@@ -144,12 +145,12 @@ static FfxErrorCode patchResourceBindings(FfxPipelineState* inoutPipeline)
     for (uint32_t cbIndex = 0; cbIndex < inoutPipeline->constCount; ++cbIndex)
     {
         int32_t mapIndex = 0;
-        for (mapIndex = 0; mapIndex < _countof(cbResourceBindingTable); ++mapIndex)
+        for (mapIndex = 0; mapIndex < std::size(cbResourceBindingTable); ++mapIndex)
         {
-            if (0 == wcscmp(cbResourceBindingTable[mapIndex].name, inoutPipeline->constantBufferBindings[cbIndex].name))
+            if (0 == strcmp(cbResourceBindingTable[mapIndex].name, inoutPipeline->constantBufferBindings[cbIndex].name))
                 break;
         }
-        if (mapIndex == _countof(cbResourceBindingTable))
+        if (mapIndex == std::size(cbResourceBindingTable))
             return FFX_ERROR_INVALID_ARGUMENT;
 
         inoutPipeline->constantBufferBindings[cbIndex].resourceIdentifier = cbResourceBindingTable[mapIndex].index;
@@ -208,7 +209,7 @@ static FfxErrorCode createShadowsPipelineStates(FfxClassifierContext_Private* co
     uint32_t contextFlags = context->contextDescription.flags;
 
     // Set up pipeline descriptors (basically RootSignature and binding)
-    wcscpy_s(pipelineDescription.name, L"CLASSIFIER-CLASSIFY");
+    strcpy(pipelineDescription.name, "CLASSIFIER-CLASSIFY");
     FFX_VALIDATE(
         context->contextDescription.backendInterface.fpCreatePipeline(
             &context->contextDescription.backendInterface,
@@ -245,7 +246,7 @@ static void scheduleDispatchShadow(FfxClassifierContext_Private* context, const
             break;
         jobDescriptor.srvTextures[currentShaderResourceViewIndex].resource = currentResource;
 #ifdef FFX_DEBUG
-        wcscpy_s(jobDescriptor.srvTextures[currentShaderResourceViewIndex].name, pipeline->srvTextureBindings[currentShaderResourceViewIndex].name);
+        strcpy(jobDescriptor.srvTextures[currentShaderResourceViewIndex].name, pipeline->srvTextureBindings[currentShaderResourceViewIndex].name);
 #endif
     }
 
@@ -254,7 +255,7 @@ static void scheduleDispatchShadow(FfxClassifierContext_Private* context, const
     {
         const uint32_t currentResourceId = pipeline->uavTextureBindings[currentUnorderedAccessViewIndex].resourceIdentifier;
 #ifdef FFX_DEBUG
-        wcscpy_s(jobDescriptor.uavTextures[currentUnorderedAccessViewIndex].name, pipeline->uavTextureBindings[currentUnorderedAccessViewIndex].name);
+        strcpy(jobDescriptor.uavTextures[currentUnorderedAccessViewIndex].name, pipeline->uavTextureBindings[currentUnorderedAccessViewIndex].name);
 #endif
         const FfxResourceInternal currentResource = context->uavResources[currentResourceId];
         jobDescriptor.uavTextures[uavEntry].resource = currentResource;
@@ -265,7 +266,7 @@ static void scheduleDispatchShadow(FfxClassifierContext_Private* context, const
     {
         const uint32_t currentResourceId = pipeline->uavBufferBindings[currentUnorderedAccessViewIndex].resourceIdentifier;
 #ifdef FFX_DEBUG
-        wcscpy_s(jobDescriptor.uavBuffers[currentUnorderedAccessViewIndex].name, pipeline->uavBufferBindings[currentUnorderedAccessViewIndex].name);
+        strcpy(jobDescriptor.uavBuffers[currentUnorderedAccessViewIndex].name, pipeline->uavBufferBindings[currentUnorderedAccessViewIndex].name);
 #endif
         const FfxResourceInternal currentResource                          = context->uavResources[currentResourceId];
         jobDescriptor.uavBuffers[currentUnorderedAccessViewIndex].resource = currentResource;
@@ -278,12 +279,12 @@ static void scheduleDispatchShadow(FfxClassifierContext_Private* context, const
 
     // Only one constant buffer
 #ifdef FFX_DEBUG
-    wcscpy_s(jobDescriptor.cbNames[0], pipeline->constantBufferBindings[0].name);
+    strcpy(jobDescriptor.cbNames[0], pipeline->constantBufferBindings[0].name);
 #endif
     jobDescriptor.cbs[0] = context->classifierConstants;
 
     FfxGpuJobDescription dispatchJob = {FFX_GPU_JOB_COMPUTE};
-    wcscpy_s(dispatchJob.jobLabel, pipeline->name);
+    strcpy(dispatchJob.jobLabel, pipeline->name);
     dispatchJob.computeJobDescriptor = jobDescriptor;
 
     context->contextDescription.backendInterface.fpScheduleGpuJob(&context->contextDescription.backendInterface, &dispatchJob);
@@ -405,7 +406,7 @@ static FfxErrorCode createReflectionsPipelineStates(FfxClassifierContext_Private
     uint32_t contextFlags = context->contextDescription.flags;
 
     // Set up pipeline descriptor (basically RootSignature and binding)
-    wcscpy_s(pipelineDescription.name, L"CLASSIFIER-REFLECTIONS");
+    strcpy(pipelineDescription.name, "CLASSIFIER-REFLECTIONS");
     FFX_VALIDATE(context->contextDescription.backendInterface.fpCreatePipeline(&context->contextDescription.backendInterface, FFX_EFFECT_CLASSIFIER, FFX_CLASSIFIER_REFLECTION_PASS_TILE_CLASSIFIER,
         getPipelinePermutationFlags(contextFlags, canForceWave64, supportedFP16), &pipelineDescription, context->effectContextId, &context->reflectionsClassifierPipeline));
 
@@ -547,7 +548,7 @@ static void populateComputeJobResources(FfxClassifierContext_Private* context, c
         const FfxResourceInternal currentResource = context->srvResources[currentResourceId];
         jobDescriptor->srvTextures[currentShaderResourceViewIndex].resource = currentResource;
 #ifdef FFX_DEBUG
-        wcscpy_s(jobDescriptor->srvTextures[currentShaderResourceViewIndex].name, pipeline->srvTextureBindings[currentShaderResourceViewIndex].name);
+        strcpy(jobDescriptor->srvTextures[currentShaderResourceViewIndex].name, pipeline->srvTextureBindings[currentShaderResourceViewIndex].name);
 #endif
     }
 
@@ -556,7 +557,7 @@ static void populateComputeJobResources(FfxClassifierContext_Private* context, c
 
         const FfxResourceBinding binding = pipeline->uavTextureBindings[currentUnorderedAccessViewIndex];
 #ifdef FFX_DEBUG
-        wcscpy_s(jobDescriptor->uavTextures[currentUnorderedAccessViewIndex].name, binding.name);
+        strcpy(jobDescriptor->uavTextures[currentUnorderedAccessViewIndex].name, binding.name);
 #endif
         const uint32_t            bindEntry         = binding.arrayIndex;
         const uint32_t            currentResourceId = binding.resourceIdentifier;
@@ -575,13 +576,13 @@ static void populateComputeJobResources(FfxClassifierContext_Private* context, c
         const FfxResourceInternal currentResource = context->uavResources[currentResourceId];
         jobDescriptor->uavBuffers[currentUnorderedAccessViewIndex].resource = currentResource;
 #ifdef FFX_DEBUG
-        wcscpy_s(jobDescriptor->uavBuffers[currentUnorderedAccessViewIndex].name, pipeline->uavBufferBindings[currentUnorderedAccessViewIndex].name);
+        strcpy(jobDescriptor->uavBuffers[currentUnorderedAccessViewIndex].name, pipeline->uavBufferBindings[currentUnorderedAccessViewIndex].name);
 #endif
     }
 
     // Only one constant buffer
 #ifdef FFX_DEBUG
-    wcscpy_s(jobDescriptor->cbNames[0], pipeline->constantBufferBindings[0].name);
+    strcpy(jobDescriptor->cbNames[0], pipeline->constantBufferBindings[0].name);
 #endif
     jobDescriptor->cbs[0] = context->reflectionsConstants;
 }
@@ -596,7 +597,7 @@ static void scheduleDispatch(FfxClassifierContext_Private* context, const FfxPip
     populateComputeJobResources(context, pipeline, &jobDescriptor);
 
     FfxGpuJobDescription dispatchJob = { FFX_GPU_JOB_COMPUTE };
-    wcscpy_s(dispatchJob.jobLabel, pipeline->name);
+    strcpy(dispatchJob.jobLabel, pipeline->name);
     dispatchJob.computeJobDescriptor = jobDescriptor;
     context->contextDescription.backendInterface.fpScheduleGpuJob(&context->contextDescription.backendInterface, &dispatchJob);
 }
diff --git a/sdk/src/components/denoiser/CMakeLists.txt b/sdk/src/components/denoiser/CMakeLists.txt
index 864efbd..b389576 100644
--- a/sdk/src/components/denoiser/CMakeLists.txt
+++ b/sdk/src/components/denoiser/CMakeLists.txt
@@ -39,9 +39,9 @@ if (FFX_DENOISER OR FFX_ALL)
 	list(APPEND PUBLIC_SOURCES ${FFX_PUBLIC_SOURCES})
 
 	if (FFX_BUILD_AS_DLL)
-		add_library(ffx_denoiser_${FFX_PLATFORM_NAME} SHARED ${SHARED_SOURCES} ${PRIVATE_SOURCES} ${PUBLIC_SOURCES})
+		add_library(denoiser SHARED ${SHARED_SOURCES} ${PRIVATE_SOURCES} ${PUBLIC_SOURCES})
 	else()
-		add_library(ffx_denoiser_${FFX_PLATFORM_NAME} STATIC ${SHARED_SOURCES} ${PRIVATE_SOURCES} ${PUBLIC_SOURCES})
+		add_library(denoiser STATIC ${SHARED_SOURCES} ${PRIVATE_SOURCES} ${PUBLIC_SOURCES})
 	endif()
 
 	# API
@@ -49,10 +49,17 @@ if (FFX_DENOISER OR FFX_ALL)
 	source_group("private_source" FILES ${PRIVATE_SOURCES})
 	source_group("public_source"  FILES ${PUBLIC_SOURCES})
 
-	target_include_directories(ffx_denoiser_${FFX_PLATFORM_NAME} PUBLIC ${FFX_INCLUDE_PATH})
-	target_include_directories(ffx_denoiser_${FFX_PLATFORM_NAME} PUBLIC ${FFX_SHARED_PATH})
+	target_include_directories(denoiser PUBLIC
+		$<BUILD_INTERFACE:${FFX_INCLUDE_PATH}>
+		$<INSTALL_INTERFACE:include>)
+	target_include_directories(denoiser PRIVATE ${FFX_SHARED_PATH})
 
 	set_source_files_properties(${SHADERS} PROPERTIES HEADER_FILE_ONLY TRUE)
-	set_target_properties(ffx_denoiser_${FFX_PLATFORM_NAME} PROPERTIES FOLDER Components)
+	set_target_properties(denoiser PROPERTIES FOLDER Components)
+	
+	install(TARGETS denoiser EXPORT denoiser-targets)
+	install(EXPORT denoiser-targets 
+		DESTINATION "${CMAKE_INSTALL_DATADIR}/cmake/${PROJECT_NAME}"
+		NAMESPACE fidelityfx::)
 	
 endif()
diff --git a/sdk/src/components/denoiser/ffx_denoiser.cpp b/sdk/src/components/denoiser/ffx_denoiser.cpp
index c0d9fe9..97c6356 100644
--- a/sdk/src/components/denoiser/ffx_denoiser.cpp
+++ b/sdk/src/components/denoiser/ffx_denoiser.cpp
@@ -20,8 +20,9 @@
 // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 // THE SOFTWARE.
 
+#include <array>        // for std::size
 #include <string.h>     // for memset
-#include <stdlib.h>     // for _countof
+#include <stdlib.h>     // 
 #include <cmath>        // for fabs, abs, sinf, sqrt, etc.
 
 #include <FidelityFX/host/ffx_denoiser.h>
@@ -38,68 +39,68 @@ constexpr uint32_t k_tileSizeY = 4;
 typedef struct ResourceBinding
 {
     uint32_t    index;
-    wchar_t     name[64];
+    char        name[64];
 }ResourceBinding;
 
 static const ResourceBinding srvTextureBindingTable[] =
 {
-    {FFX_DENOISER_RESOURCE_IDENTIFIER_HIT_MASK_RESULTS,         L"r_hit_mask_results"},
-    {FFX_DENOISER_RESOURCE_IDENTIFIER_DEPTH,                    L"r_depth"},
-    {FFX_DENOISER_RESOURCE_IDENTIFIER_VELOCITY,                 L"r_velocity"},
-    {FFX_DENOISER_RESOURCE_IDENTIFIER_NORMAL,                   L"r_normal"},
-    {FFX_DENOISER_RESOURCE_IDENTIFIER_HISTORY,                  L"r_history"},
-    {FFX_DENOISER_RESOURCE_IDENTIFIER_PREVIOUS_DEPTH,           L"r_previous_depth"},
-    {FFX_DENOISER_RESOURCE_IDENTIFIER_PREVIOUS_MOMENTS,         L"r_previous_moments"},
-    {FFX_DENOISER_RESOURCE_IDENTIFIER_NORMAL_FP16,              L"r_fp16_normal"},
-    {FFX_DENOISER_RESOURCE_IDENTIFIER_FILTER_INPUT,             L"r_filter_input"},
-    {FFX_DENOISER_RESOURCE_IDENTIFIER_INPUT_DEPTH_HIERARCHY,    L"r_input_depth_hierarchy"},
-    {FFX_DENOISER_RESOURCE_IDENTIFIER_INPUT_MOTION_VECTORS,     L"r_input_motion_vectors"},
-    {FFX_DENOISER_RESOURCE_IDENTIFIER_INPUT_NORMAL,             L"r_input_normal"},
-    {FFX_DENOISER_RESOURCE_IDENTIFIER_RADIANCE,                 L"r_radiance"},
-    {FFX_DENOISER_RESOURCE_IDENTIFIER_RADIANCE_HISTORY,         L"r_radiance_history"},
-    {FFX_DENOISER_RESOURCE_IDENTIFIER_VARIANCE,                 L"r_variance"},
-    {FFX_DENOISER_RESOURCE_IDENTIFIER_SAMPLE_COUNT,             L"r_sample_count"},
-    {FFX_DENOISER_RESOURCE_IDENTIFIER_AVERAGE_RADIANCE,         L"r_average_radiance"},
-    {FFX_DENOISER_RESOURCE_IDENTIFIER_EXTRACTED_ROUGHNESS,      L"r_extracted_roughness"},
-    {FFX_DENOISER_RESOURCE_IDENTIFIER_DEPTH_HISTORY,            L"r_depth_history"},
-    {FFX_DENOISER_RESOURCE_IDENTIFIER_NORMAL_HISTORY,           L"r_normal_history"},
-    {FFX_DENOISER_RESOURCE_IDENTIFIER_ROUGHNESS_HISTORY,        L"r_roughness_history"},
-    {FFX_DENOISER_RESOURCE_IDENTIFIER_REPROJECTED_RADIANCE,     L"r_reprojected_radiance"},
+    {FFX_DENOISER_RESOURCE_IDENTIFIER_HIT_MASK_RESULTS,         "r_hit_mask_results"},
+    {FFX_DENOISER_RESOURCE_IDENTIFIER_DEPTH,                    "r_depth"},
+    {FFX_DENOISER_RESOURCE_IDENTIFIER_VELOCITY,                 "r_velocity"},
+    {FFX_DENOISER_RESOURCE_IDENTIFIER_NORMAL,                   "r_normal"},
+    {FFX_DENOISER_RESOURCE_IDENTIFIER_HISTORY,                  "r_history"},
+    {FFX_DENOISER_RESOURCE_IDENTIFIER_PREVIOUS_DEPTH,           "r_previous_depth"},
+    {FFX_DENOISER_RESOURCE_IDENTIFIER_PREVIOUS_MOMENTS,         "r_previous_moments"},
+    {FFX_DENOISER_RESOURCE_IDENTIFIER_NORMAL_FP16,              "r_fp16_normal"},
+    {FFX_DENOISER_RESOURCE_IDENTIFIER_FILTER_INPUT,             "r_filter_input"},
+    {FFX_DENOISER_RESOURCE_IDENTIFIER_INPUT_DEPTH_HIERARCHY,    "r_input_depth_hierarchy"},
+    {FFX_DENOISER_RESOURCE_IDENTIFIER_INPUT_MOTION_VECTORS,     "r_input_motion_vectors"},
+    {FFX_DENOISER_RESOURCE_IDENTIFIER_INPUT_NORMAL,             "r_input_normal"},
+    {FFX_DENOISER_RESOURCE_IDENTIFIER_RADIANCE,                 "r_radiance"},
+    {FFX_DENOISER_RESOURCE_IDENTIFIER_RADIANCE_HISTORY,         "r_radiance_history"},
+    {FFX_DENOISER_RESOURCE_IDENTIFIER_VARIANCE,                 "r_variance"},
+    {FFX_DENOISER_RESOURCE_IDENTIFIER_SAMPLE_COUNT,             "r_sample_count"},
+    {FFX_DENOISER_RESOURCE_IDENTIFIER_AVERAGE_RADIANCE,         "r_average_radiance"},
+    {FFX_DENOISER_RESOURCE_IDENTIFIER_EXTRACTED_ROUGHNESS,      "r_extracted_roughness"},
+    {FFX_DENOISER_RESOURCE_IDENTIFIER_DEPTH_HISTORY,            "r_depth_history"},
+    {FFX_DENOISER_RESOURCE_IDENTIFIER_NORMAL_HISTORY,           "r_normal_history"},
+    {FFX_DENOISER_RESOURCE_IDENTIFIER_ROUGHNESS_HISTORY,        "r_roughness_history"},
+    {FFX_DENOISER_RESOURCE_IDENTIFIER_REPROJECTED_RADIANCE,     "r_reprojected_radiance"},
 };
 
 static const ResourceBinding srvBufferBindingTable[] = {
-    {FFX_DENOISER_RESOURCE_IDENTIFIER_RAYTRACER_RESULT, L"sb_raytracer_result"},
+    {FFX_DENOISER_RESOURCE_IDENTIFIER_RAYTRACER_RESULT, "sb_raytracer_result"},
 };
 
 static const ResourceBinding uavBufferBindingTable[] =
 {
-    {FFX_DENOISER_RESOURCE_IDENTIFIER_SHADOW_MASK,          L"rw_shadow_mask"},
-    {FFX_DENOISER_RESOURCE_IDENTIFIER_RAYTRACER_RESULT,     L"rw_raytracer_result"},
-    {FFX_DENOISER_RESOURCE_IDENTIFIER_TILE_META_DATA,       L"rw_tile_metadata"},
-    {FFX_DENOISER_RESOURCE_IDENTIFIER_DENOISER_TILE_LIST,   L"rw_denoiser_tile_list"},
-    {FFX_DENOISER_RESOURCE_IDENTIFIER_INDIRECT_ARGS,        L"rw_indirect_args"},
+    {FFX_DENOISER_RESOURCE_IDENTIFIER_SHADOW_MASK,          "rw_shadow_mask"},
+    {FFX_DENOISER_RESOURCE_IDENTIFIER_RAYTRACER_RESULT,     "rw_raytracer_result"},
+    {FFX_DENOISER_RESOURCE_IDENTIFIER_TILE_META_DATA,       "rw_tile_metadata"},
+    {FFX_DENOISER_RESOURCE_IDENTIFIER_DENOISER_TILE_LIST,   "rw_denoiser_tile_list"},
+    {FFX_DENOISER_RESOURCE_IDENTIFIER_INDIRECT_ARGS,        "rw_indirect_args"},
 
 };
 
 static const ResourceBinding uavTextureBindingTable[] =
 {
-    {FFX_DENOISER_RESOURCE_IDENTIFIER_FILTER_OUTPUT,            L"rw_filter_output"},
-    {FFX_DENOISER_RESOURCE_IDENTIFIER_REPROJECTION_RESULTS,     L"rw_reprojection_results"},
-    {FFX_DENOISER_RESOURCE_IDENTIFIER_CURRENT_MOMENTS,          L"rw_current_moments"},
-    {FFX_DENOISER_RESOURCE_IDENTIFIER_HISTORY,                  L"rw_history"},
-    {FFX_DENOISER_RESOURCE_IDENTIFIER_RADIANCE,                 L"rw_radiance"},
-    {FFX_DENOISER_RESOURCE_IDENTIFIER_VARIANCE,                 L"rw_variance"},
-    {FFX_DENOISER_RESOURCE_IDENTIFIER_SAMPLE_COUNT,             L"rw_sample_count"},
-    {FFX_DENOISER_RESOURCE_IDENTIFIER_AVERAGE_RADIANCE,         L"rw_average_radiance"},
-    {FFX_DENOISER_RESOURCE_IDENTIFIER_REPROJECTED_RADIANCE,     L"rw_reprojected_radiance"},
+    {FFX_DENOISER_RESOURCE_IDENTIFIER_FILTER_OUTPUT,            "rw_filter_output"},
+    {FFX_DENOISER_RESOURCE_IDENTIFIER_REPROJECTION_RESULTS,     "rw_reprojection_results"},
+    {FFX_DENOISER_RESOURCE_IDENTIFIER_CURRENT_MOMENTS,          "rw_current_moments"},
+    {FFX_DENOISER_RESOURCE_IDENTIFIER_HISTORY,                  "rw_history"},
+    {FFX_DENOISER_RESOURCE_IDENTIFIER_RADIANCE,                 "rw_radiance"},
+    {FFX_DENOISER_RESOURCE_IDENTIFIER_VARIANCE,                 "rw_variance"},
+    {FFX_DENOISER_RESOURCE_IDENTIFIER_SAMPLE_COUNT,             "rw_sample_count"},
+    {FFX_DENOISER_RESOURCE_IDENTIFIER_AVERAGE_RADIANCE,         "rw_average_radiance"},
+    {FFX_DENOISER_RESOURCE_IDENTIFIER_REPROJECTED_RADIANCE,     "rw_reprojected_radiance"},
 };
 
 static const ResourceBinding cbResourceBindingTable[] =
 {
-    {FFX_DENOISER_SHADOWS_CONSTANTBUFFER_IDENTIFIER_DENOISER_SHADOWS0,  L"cb0DenoiserShadows"},
-    {FFX_DENOISER_SHADOWS_CONSTANTBUFFER_IDENTIFIER_DENOISER_SHADOWS1,  L"cb1DenoiserShadows"},
-    {FFX_DENOISER_SHADOWS_CONSTANTBUFFER_IDENTIFIER_DENOISER_SHADOWS2,  L"cb2DenoiserShadows"},
-    {FFX_DENOISER_REFLECTIONS_CONSTANTBUFFER_IDENTIFIER,                L"cbDenoiserReflections"},
+    {FFX_DENOISER_SHADOWS_CONSTANTBUFFER_IDENTIFIER_DENOISER_SHADOWS0,  "cb0DenoiserShadows"},
+    {FFX_DENOISER_SHADOWS_CONSTANTBUFFER_IDENTIFIER_DENOISER_SHADOWS1,  "cb1DenoiserShadows"},
+    {FFX_DENOISER_SHADOWS_CONSTANTBUFFER_IDENTIFIER_DENOISER_SHADOWS2,  "cb2DenoiserShadows"},
+    {FFX_DENOISER_REFLECTIONS_CONSTANTBUFFER_IDENTIFIER,                "cbDenoiserReflections"},
 
 };
 
@@ -147,12 +148,12 @@ static FfxErrorCode patchResourceBindings(FfxPipelineState* inoutPipeline)
     for (uint32_t srvIndex = 0; srvIndex < inoutPipeline->srvTextureCount; ++srvIndex)
     {
         int32_t mapIndex = 0;
-        for (mapIndex = 0; mapIndex < _countof(srvTextureBindingTable); ++mapIndex)
+        for (mapIndex = 0; mapIndex < std::size(srvTextureBindingTable); ++mapIndex)
         {
-            if (0 == wcscmp(srvTextureBindingTable[mapIndex].name, inoutPipeline->srvTextureBindings[srvIndex].name))
+            if (0 == strcmp(srvTextureBindingTable[mapIndex].name, inoutPipeline->srvTextureBindings[srvIndex].name))
                 break;
         }
-        if (mapIndex == _countof(srvTextureBindingTable))
+        if (mapIndex == std::size(srvTextureBindingTable))
             return FFX_ERROR_INVALID_ARGUMENT;
 
         inoutPipeline->srvTextureBindings[srvIndex].resourceIdentifier = srvTextureBindingTable[mapIndex].index;
@@ -162,12 +163,12 @@ static FfxErrorCode patchResourceBindings(FfxPipelineState* inoutPipeline)
     for (uint32_t srvIndex = 0; srvIndex < inoutPipeline->srvBufferCount; ++srvIndex)
     {
         int32_t mapIndex = 0;
-        for (mapIndex = 0; mapIndex < _countof(srvBufferBindingTable); ++mapIndex)
+        for (mapIndex = 0; mapIndex < std::size(srvBufferBindingTable); ++mapIndex)
         {
-            if (0 == wcscmp(srvBufferBindingTable[mapIndex].name, inoutPipeline->srvBufferBindings[srvIndex].name))
+            if (0 == strcmp(srvBufferBindingTable[mapIndex].name, inoutPipeline->srvBufferBindings[srvIndex].name))
                 break;
         }
-        if (mapIndex == _countof(srvBufferBindingTable))
+        if (mapIndex == std::size(srvBufferBindingTable))
             return FFX_ERROR_INVALID_ARGUMENT;
 
         inoutPipeline->srvBufferBindings[srvIndex].resourceIdentifier = srvBufferBindingTable[mapIndex].index;
@@ -177,12 +178,12 @@ static FfxErrorCode patchResourceBindings(FfxPipelineState* inoutPipeline)
     for (uint32_t uavIndex = 0; uavIndex < inoutPipeline->uavBufferCount; ++uavIndex)
     {
         int32_t mapIndex = 0;
-        for (mapIndex = 0; mapIndex < _countof(uavBufferBindingTable); ++mapIndex)
+        for (mapIndex = 0; mapIndex < std::size(uavBufferBindingTable); ++mapIndex)
         {
-            if (0 == wcscmp(uavBufferBindingTable[mapIndex].name, inoutPipeline->uavBufferBindings[uavIndex].name))
+            if (0 == strcmp(uavBufferBindingTable[mapIndex].name, inoutPipeline->uavBufferBindings[uavIndex].name))
                 break;
         }
-        if (mapIndex == _countof(uavBufferBindingTable))
+        if (mapIndex == std::size(uavBufferBindingTable))
             return FFX_ERROR_INVALID_ARGUMENT;
 
         inoutPipeline->uavBufferBindings[uavIndex].resourceIdentifier = uavBufferBindingTable[mapIndex].index;
@@ -193,12 +194,12 @@ static FfxErrorCode patchResourceBindings(FfxPipelineState* inoutPipeline)
     for (uint32_t uavIndex = 0; uavIndex < inoutPipeline->uavTextureCount; ++uavIndex)
     {
         int32_t mapIndex = 0;
-        for (mapIndex = 0; mapIndex < _countof(uavTextureBindingTable); ++mapIndex)
+        for (mapIndex = 0; mapIndex < std::size(uavTextureBindingTable); ++mapIndex)
         {
-            if (0 == wcscmp(uavTextureBindingTable[mapIndex].name, inoutPipeline->uavTextureBindings[uavIndex].name))
+            if (0 == strcmp(uavTextureBindingTable[mapIndex].name, inoutPipeline->uavTextureBindings[uavIndex].name))
                 break;
         }
-        if (mapIndex == _countof(uavTextureBindingTable))
+        if (mapIndex == std::size(uavTextureBindingTable))
             return FFX_ERROR_INVALID_ARGUMENT;
 
         inoutPipeline->uavTextureBindings[uavIndex].resourceIdentifier = uavTextureBindingTable[mapIndex].index;
@@ -208,12 +209,12 @@ static FfxErrorCode patchResourceBindings(FfxPipelineState* inoutPipeline)
     for (uint32_t cbIndex = 0; cbIndex < inoutPipeline->constCount; ++cbIndex)
     {
         int32_t mapIndex = 0;
-        for (mapIndex = 0; mapIndex < _countof(cbResourceBindingTable); ++mapIndex)
+        for (mapIndex = 0; mapIndex < std::size(cbResourceBindingTable); ++mapIndex)
         {
-            if (0 == wcscmp(cbResourceBindingTable[mapIndex].name, inoutPipeline->constantBufferBindings[cbIndex].name))
+            if (0 == strcmp(cbResourceBindingTable[mapIndex].name, inoutPipeline->constantBufferBindings[cbIndex].name))
                 break;
         }
-        if (mapIndex == _countof(cbResourceBindingTable))
+        if (mapIndex == std::size(cbResourceBindingTable))
             return FFX_ERROR_INVALID_ARGUMENT;
 
         inoutPipeline->constantBufferBindings[cbIndex].resourceIdentifier = cbResourceBindingTable[mapIndex].index;
@@ -345,13 +346,13 @@ static FfxErrorCode createReflectionsPipelineStates(FfxDenoiserContext_Private*
     }
 
     // Indirect workloads
-    wcscpy_s(pipelineDescription.name, L"DENOISER-REFLECTIONS_REPROJECT");
+    strcpy(pipelineDescription.name, "DENOISER-REFLECTIONS_REPROJECT");
     FFX_VALIDATE(context->contextDescription.backendInterface.fpCreatePipeline(&context->contextDescription.backendInterface, FFX_EFFECT_DENOISER, FFX_DENOISER_PASS_REPROJECT_REFLECTIONS,
         getPipelinePermutationFlags(FFX_DENOISER_PASS_REPROJECT_REFLECTIONS, supportedFP16, canForceWave64), &pipelineDescription, context->effectContextId, &context->pipelineReprojectReflections));
-    wcscpy_s(pipelineDescription.name, L"DENOISER-REFLECTIONS_PREFILTER");
+    strcpy(pipelineDescription.name, "DENOISER-REFLECTIONS_PREFILTER");
     FFX_VALIDATE(context->contextDescription.backendInterface.fpCreatePipeline(&context->contextDescription.backendInterface, FFX_EFFECT_DENOISER, FFX_DENOISER_PASS_PREFILTER_REFLECTIONS,
         getPipelinePermutationFlags(FFX_DENOISER_PASS_PREFILTER_REFLECTIONS, supportedFP16, canForceWave64), &pipelineDescription, context->effectContextId, &context->pipelinePrefilterReflections));
-    wcscpy_s(pipelineDescription.name, L"DENOISER-REFLECTIONS_RESOLVE_TEMPORAL");
+    strcpy(pipelineDescription.name, "DENOISER-REFLECTIONS_RESOLVE_TEMPORAL");
     FFX_VALIDATE(context->contextDescription.backendInterface.fpCreatePipeline(&context->contextDescription.backendInterface, FFX_EFFECT_DENOISER, FFX_DENOISER_PASS_RESOLVE_TEMPORAL_REFLECTIONS,
         getPipelinePermutationFlags(FFX_DENOISER_PASS_RESOLVE_TEMPORAL_REFLECTIONS, supportedFP16, canForceWave64), &pipelineDescription, context->effectContextId, &context->pipelineResolveTemporalReflections));
 
@@ -371,7 +372,7 @@ static void populateReflectionsJobResources(FfxDenoiserContext_Private* context,
         const FfxResourceInternal currentResource = context->srvResources[currentResourceId];
         jobDescriptor->srvTextures[currentShaderResourceViewIndex].resource = currentResource;
 #ifdef FFX_DEBUG
-        wcscpy_s(jobDescriptor->srvTextures[currentShaderResourceViewIndex].name, pipeline->srvTextureBindings[currentShaderResourceViewIndex].name);
+        strcpy(jobDescriptor->srvTextures[currentShaderResourceViewIndex].name, pipeline->srvTextureBindings[currentShaderResourceViewIndex].name);
 #endif
     }
 
@@ -380,7 +381,7 @@ static void populateReflectionsJobResources(FfxDenoiserContext_Private* context,
 
         const FfxResourceBinding binding = pipeline->uavTextureBindings[currentUnorderedAccessViewIndex];
 #ifdef FFX_DEBUG
-        wcscpy_s(jobDescriptor->uavTextures[currentUnorderedAccessViewIndex].name, binding.name);
+        strcpy(jobDescriptor->uavTextures[currentUnorderedAccessViewIndex].name, binding.name);
 #endif
         const uint32_t            bindEntry         = binding.arrayIndex;
         const uint32_t            currentResourceId = binding.resourceIdentifier;
@@ -399,14 +400,14 @@ static void populateReflectionsJobResources(FfxDenoiserContext_Private* context,
         const FfxResourceInternal currentResource = context->uavResources[currentResourceId];
         jobDescriptor->uavBuffers[currentUnorderedAccessViewIndex].resource = currentResource;
 #ifdef FFX_DEBUG
-        wcscpy_s(jobDescriptor->uavBuffers[currentUnorderedAccessViewIndex].name, pipeline->uavBufferBindings[currentUnorderedAccessViewIndex].name);
+        strcpy(jobDescriptor->uavBuffers[currentUnorderedAccessViewIndex].name, pipeline->uavBufferBindings[currentUnorderedAccessViewIndex].name);
 #endif
     }
 
     // Constant buffers
     for (uint32_t currentRootConstantIndex = 0; currentRootConstantIndex < pipeline->constCount; ++currentRootConstantIndex) {
 #ifdef FFX_DEBUG
-        wcscpy_s(jobDescriptor->cbNames[currentRootConstantIndex], pipeline->constantBufferBindings[currentRootConstantIndex].name);
+        strcpy(jobDescriptor->cbNames[currentRootConstantIndex], pipeline->constantBufferBindings[currentRootConstantIndex].name);
 #endif
         jobDescriptor->cbs[currentRootConstantIndex] = context->reflectionsConstants[pipeline->constantBufferBindings[currentRootConstantIndex].resourceIdentifier];
     }
@@ -421,7 +422,7 @@ static void scheduleIndirectReflectionsDispatch(FfxDenoiserContext_Private* cont
     populateReflectionsJobResources(context, pipeline, &jobDescriptor);
 
     FfxGpuJobDescription dispatchJob = { FFX_GPU_JOB_COMPUTE };
-    wcscpy_s(dispatchJob.jobLabel, pipeline->name);
+    strcpy(dispatchJob.jobLabel, pipeline->name);
     dispatchJob.computeJobDescriptor = jobDescriptor;
     context->contextDescription.backendInterface.fpScheduleGpuJob(&context->contextDescription.backendInterface, &dispatchJob);
 }
@@ -436,7 +437,7 @@ static void scheduleDispatch(FfxDenoiserContext_Private* context, const FfxDenoi
         const FfxResourceInternal currentResource = context->srvResources[currentResourceId];
         jobDescriptor.srvTextures[currentShaderResourceViewIndex].resource = currentResource;
 #ifdef FFX_DEBUG
-        wcscpy_s(jobDescriptor.srvTextures[currentShaderResourceViewIndex].name, pipeline->srvTextureBindings[currentShaderResourceViewIndex].name);
+        strcpy(jobDescriptor.srvTextures[currentShaderResourceViewIndex].name, pipeline->srvTextureBindings[currentShaderResourceViewIndex].name);
 #endif
     }
 
@@ -444,7 +445,7 @@ static void scheduleDispatch(FfxDenoiserContext_Private* context, const FfxDenoi
 
         const uint32_t currentResourceId = pipeline->uavTextureBindings[currentUnorderedAccessViewIndex].resourceIdentifier;
 #ifdef FFX_DEBUG
-        wcscpy_s(jobDescriptor.uavTextures[currentUnorderedAccessViewIndex].name, pipeline->uavTextureBindings[currentUnorderedAccessViewIndex].name);
+        strcpy(jobDescriptor.uavTextures[currentUnorderedAccessViewIndex].name, pipeline->uavTextureBindings[currentUnorderedAccessViewIndex].name);
 #endif
 
         const FfxResourceInternal currentResource                           = context->uavResources[currentResourceId];
@@ -458,7 +459,7 @@ static void scheduleDispatch(FfxDenoiserContext_Private* context, const FfxDenoi
         const FfxResourceInternal currentResource = context->uavResources[currentResourceId];
         jobDescriptor.uavBuffers[currentUnorderedAccessViewIndex].resource = currentResource;
 #ifdef FFX_DEBUG
-        wcscpy_s(jobDescriptor.uavBuffers[currentUnorderedAccessViewIndex].name, pipeline->uavBufferBindings[currentUnorderedAccessViewIndex].name);
+        strcpy(jobDescriptor.uavBuffers[currentUnorderedAccessViewIndex].name, pipeline->uavBufferBindings[currentUnorderedAccessViewIndex].name);
 #endif
     }
 
@@ -468,7 +469,7 @@ static void scheduleDispatch(FfxDenoiserContext_Private* context, const FfxDenoi
         const FfxResourceInternal currentResource = context->srvResources[currentResourceId];
         jobDescriptor.srvBuffers[currentShaderResourceViewIndex].resource = currentResource;
 #ifdef FFX_DEBUG
-        wcscpy_s(jobDescriptor.srvBuffers[currentShaderResourceViewIndex].name, pipeline->srvBufferBindings[currentShaderResourceViewIndex].name);
+        strcpy(jobDescriptor.srvBuffers[currentShaderResourceViewIndex].name, pipeline->srvBufferBindings[currentShaderResourceViewIndex].name);
 #endif
     }
 
@@ -479,13 +480,13 @@ static void scheduleDispatch(FfxDenoiserContext_Private* context, const FfxDenoi
 
     for (uint32_t currentRootConstantIndex = 0; currentRootConstantIndex < pipeline->constCount; ++currentRootConstantIndex) {
 #ifdef FFX_DEBUG
-        wcscpy_s(jobDescriptor.cbNames[currentRootConstantIndex], pipeline->constantBufferBindings[currentRootConstantIndex].name);
+        strcpy(jobDescriptor.cbNames[currentRootConstantIndex], pipeline->constantBufferBindings[currentRootConstantIndex].name);
 #endif
         jobDescriptor.cbs[currentRootConstantIndex] = context->shadowsConstants[pipeline->constantBufferBindings[currentRootConstantIndex].resourceIdentifier];
     }
 
     FfxGpuJobDescription dispatchJob = {FFX_GPU_JOB_COMPUTE};
-    wcscpy_s(dispatchJob.jobLabel, pipeline->name);
+    strcpy(dispatchJob.jobLabel, pipeline->name);
     dispatchJob.computeJobDescriptor = jobDescriptor;
 
     context->contextDescription.backendInterface.fpScheduleGpuJob(&context->contextDescription.backendInterface, &dispatchJob);
@@ -520,7 +521,7 @@ static FfxErrorCode denoiserDispatchShadows(FfxDenoiserContext_Private* context,
     {
         FfxGpuJobDescription job        = {};
         job.jobType                     = FFX_GPU_JOB_CLEAR_FLOAT;
-        wcscpy_s(job.jobLabel, L"Clear shadow map");
+        strcpy(job.jobLabel, "Clear shadow map");
         job.clearJobDescriptor.color[0] = 0.0f;
         job.clearJobDescriptor.color[1] = 0.0f;
         job.clearJobDescriptor.color[2] = 0.0f;
@@ -592,7 +593,7 @@ static FfxErrorCode denoiserDispatchShadows(FfxDenoiserContext_Private* context,
 
     // Copy current depth to previous depth
     FfxGpuJobDescription copyJob = { FFX_GPU_JOB_COPY };
-    wcscpy_s(copyJob.jobLabel, L"Copy current depth -> previous depth");
+    strcpy(copyJob.jobLabel, "Copy current depth -> previous depth");
     copyJob.copyJobDescriptor.src       = context->srvResources[FFX_DENOISER_RESOURCE_IDENTIFIER_DEPTH];
     copyJob.copyJobDescriptor.dst       = context->srvResources[FFX_DENOISER_RESOURCE_IDENTIFIER_PREVIOUS_DEPTH];
     copyJob.copyJobDescriptor.srcOffset = 0; 
@@ -656,7 +657,7 @@ static FfxErrorCode denoiserDispatchReflections(FfxDenoiserContext_Private* cont
     if (context->isFirstReflectionsFrame) {
         FfxGpuJobDescription job = {};
         job.jobType = FFX_GPU_JOB_CLEAR_FLOAT;
-        wcscpy_s(job.jobLabel, L"Zero initialize resource");
+        strcpy(job.jobLabel, "Zero initialize resource");
         job.clearJobDescriptor.color[0] = 0.0f;
         job.clearJobDescriptor.color[1] = 0.0f;
         job.clearJobDescriptor.color[2] = 0.0f;
@@ -714,7 +715,7 @@ static FfxErrorCode denoiserDispatchReflections(FfxDenoiserContext_Private* cont
     {
         FfxGpuJobDescription job = {};
         job.jobType = FFX_GPU_JOB_CLEAR_FLOAT;
-        wcscpy_s(job.jobLabel, L"Zero initialize resource");
+        strcpy(job.jobLabel, "Zero initialize resource");
         job.clearJobDescriptor.color[0] = 0.0f;
         job.clearJobDescriptor.color[1] = 0.0f;
         job.clearJobDescriptor.color[2] = 0.0f;
@@ -770,7 +771,7 @@ static FfxErrorCode denoiserDispatchReflections(FfxDenoiserContext_Private* cont
 
     // Copy Final result to output target
     FfxGpuJobDescription dispatchCopyJobDescriptor = { FFX_GPU_JOB_COPY };
-    wcscpy_s(dispatchCopyJobDescriptor.jobLabel, L"Copy to output");
+    strcpy(dispatchCopyJobDescriptor.jobLabel, "Copy to output");
     dispatchCopyJobDescriptor.copyJobDescriptor.src = context->srvResources[radianceAResourceIndex];
     dispatchCopyJobDescriptor.copyJobDescriptor.dst = context->srvResources[FFX_DENOISER_RESOURCE_IDENTIFIER_OUTPUT];
     dispatchCopyJobDescriptor.copyJobDescriptor.srcOffset = 0;
@@ -819,7 +820,7 @@ static FfxErrorCode denoiserShadowsCreateResources(FfxDenoiserContext_Private* c
 
     // Declare internal resources needed
     const FfxInternalResourceDescription internalSurfaceDesc[] = {{FFX_DENOISER_RESOURCE_IDENTIFIER_PREVIOUS_DEPTH,
-                                                                   L"DenoiserShadows_PreviousDepth",
+                                                                   "DenoiserShadows_PreviousDepth",
                                                                    FFX_RESOURCE_TYPE_TEXTURE2D,
                                                                    FFX_RESOURCE_USAGE_READ_ONLY,
                                                                    FFX_SURFACE_FORMAT_R32_FLOAT,
@@ -830,7 +831,7 @@ static FfxErrorCode denoiserShadowsCreateResources(FfxDenoiserContext_Private* c
                                                                    {FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED}},
 
                                                                   {FFX_DENOISER_RESOURCE_IDENTIFIER_MOMENTS0,
-                                                                   L"DenoiserShadows_Moments0",
+                                                                   "DenoiserShadows_Moments0",
                                                                    FFX_RESOURCE_TYPE_TEXTURE2D,
                                                                    FFX_RESOURCE_USAGE_UAV,
                                                                    FFX_SURFACE_FORMAT_R11G11B10_FLOAT,
@@ -841,7 +842,7 @@ static FfxErrorCode denoiserShadowsCreateResources(FfxDenoiserContext_Private* c
                                                                    {FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED}},
 
                                                                   {FFX_DENOISER_RESOURCE_IDENTIFIER_MOMENTS1,
-                                                                   L"DenoiserShadows_Moments1",
+                                                                   "DenoiserShadows_Moments1",
                                                                    FFX_RESOURCE_TYPE_TEXTURE2D,
                                                                    FFX_RESOURCE_USAGE_UAV,
                                                                    FFX_SURFACE_FORMAT_R11G11B10_FLOAT,
@@ -852,7 +853,7 @@ static FfxErrorCode denoiserShadowsCreateResources(FfxDenoiserContext_Private* c
                                                                    {FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED}},
 
                                                                   {FFX_DENOISER_RESOURCE_IDENTIFIER_SCRATCH0,
-                                                                   L"DenoiserShadows_Scratch0",
+                                                                   "DenoiserShadows_Scratch0",
                                                                    FFX_RESOURCE_TYPE_TEXTURE2D,
                                                                    FFX_RESOURCE_USAGE_UAV,
                                                                    FFX_SURFACE_FORMAT_R16G16_FLOAT,
@@ -863,7 +864,7 @@ static FfxErrorCode denoiserShadowsCreateResources(FfxDenoiserContext_Private* c
                                                                    {FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED}},
 
                                                                   {FFX_DENOISER_RESOURCE_IDENTIFIER_SCRATCH1,
-                                                                   L"DenoiserShadows_Scratch1",
+                                                                   "DenoiserShadows_Scratch1",
                                                                    FFX_RESOURCE_TYPE_TEXTURE2D,
                                                                    FFX_RESOURCE_USAGE_UAV,
                                                                    FFX_SURFACE_FORMAT_R16G16_FLOAT,
@@ -874,7 +875,7 @@ static FfxErrorCode denoiserShadowsCreateResources(FfxDenoiserContext_Private* c
                                                                    {FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED}},
 
                                                                   {FFX_DENOISER_RESOURCE_IDENTIFIER_TILE_BUFFER,
-                                                                   L"DenoiserShadows_TileBuffer",
+                                                                   "DenoiserShadows_TileBuffer",
                                                                    FFX_RESOURCE_TYPE_BUFFER,
                                                                    FFX_RESOURCE_USAGE_UAV,
                                                                    FFX_SURFACE_FORMAT_UNKNOWN,
@@ -885,7 +886,7 @@ static FfxErrorCode denoiserShadowsCreateResources(FfxDenoiserContext_Private* c
                                                                    {FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED}},
 
                                                                   {FFX_DENOISER_RESOURCE_IDENTIFIER_TILE_META_DATA,
-                                                                   L"DenoiserShadows_TileMetadata",
+                                                                   "DenoiserShadows_TileMetadata",
                                                                    FFX_RESOURCE_TYPE_BUFFER,
                                                                    FFX_RESOURCE_USAGE_UAV,
                                                                    FFX_SURFACE_FORMAT_UNKNOWN,
@@ -918,7 +919,7 @@ static FfxErrorCode denoiserReflectionsCreateResources(FfxDenoiserContext_Privat
 
     // Declare internal resources needed
     const FfxInternalResourceDescription internalSurfaceDesc[] = {{FFX_DENOISER_RESOURCE_IDENTIFIER_DEPTH_HISTORY,
-                                                                   L"DENOISER_DepthHistory",
+                                                                   "DENOISER_DepthHistory",
                                                                    FFX_RESOURCE_TYPE_TEXTURE2D,
                                                                    FFX_RESOURCE_USAGE_READ_ONLY,
                                                                    FFX_SURFACE_FORMAT_R32_FLOAT,
@@ -929,7 +930,7 @@ static FfxErrorCode denoiserReflectionsCreateResources(FfxDenoiserContext_Privat
                                                                    {FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED}},
 
                                                                   {FFX_DENOISER_RESOURCE_IDENTIFIER_NORMAL_HISTORY,
-                                                                   L"DENOISER_NormalHistory",
+                                                                   "DENOISER_NormalHistory",
                                                                    FFX_RESOURCE_TYPE_TEXTURE2D,
                                                                    FFX_RESOURCE_USAGE_READ_ONLY,
                                                                    contextDescription->normalsHistoryBufferFormat,
@@ -940,7 +941,7 @@ static FfxErrorCode denoiserReflectionsCreateResources(FfxDenoiserContext_Privat
                                                                    {FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED}},
 
                                                                   {FFX_DENOISER_RESOURCE_IDENTIFIER_ROUGHNESS_HISTORY,
-                                                                   L"DENOISER_RoughnessHistory",
+                                                                   "DENOISER_RoughnessHistory",
                                                                    FFX_RESOURCE_TYPE_TEXTURE2D,
                                                                    FFX_RESOURCE_USAGE_READ_ONLY,
                                                                    FFX_SURFACE_FORMAT_R8_UNORM,
@@ -951,7 +952,7 @@ static FfxErrorCode denoiserReflectionsCreateResources(FfxDenoiserContext_Privat
                                                                    {FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED}},
 
                                                                   {FFX_DENOISER_RESOURCE_IDENTIFIER_SAMPLE_COUNT_0,
-                                                                   L"DENOISER_SampleCount0",
+                                                                   "DENOISER_SampleCount0",
                                                                    FFX_RESOURCE_TYPE_TEXTURE2D,
                                                                    FFX_RESOURCE_USAGE_UAV,
                                                                    FFX_SURFACE_FORMAT_R16_FLOAT,
@@ -962,7 +963,7 @@ static FfxErrorCode denoiserReflectionsCreateResources(FfxDenoiserContext_Privat
                                                                    {FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED}},
 
                                                                   {FFX_DENOISER_RESOURCE_IDENTIFIER_SAMPLE_COUNT_1,
-                                                                   L"DENOISER_SampleCount1",
+                                                                   "DENOISER_SampleCount1",
                                                                    FFX_RESOURCE_TYPE_TEXTURE2D,
                                                                    FFX_RESOURCE_USAGE_UAV,
                                                                    FFX_SURFACE_FORMAT_R16_FLOAT,
@@ -973,7 +974,7 @@ static FfxErrorCode denoiserReflectionsCreateResources(FfxDenoiserContext_Privat
                                                                    {FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED}},
 
                                                                   {FFX_DENOISER_RESOURCE_IDENTIFIER_AVERAGE_RADIANCE_0,
-                                                                   L"DENOISER_AverageRadiance0",
+                                                                   "DENOISER_AverageRadiance0",
                                                                    FFX_RESOURCE_TYPE_TEXTURE2D,
                                                                    FFX_RESOURCE_USAGE_UAV,
                                                                    FFX_SURFACE_FORMAT_R11G11B10_FLOAT,
@@ -984,7 +985,7 @@ static FfxErrorCode denoiserReflectionsCreateResources(FfxDenoiserContext_Privat
                                                                    {FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED}},
 
                                                                   {FFX_DENOISER_RESOURCE_IDENTIFIER_AVERAGE_RADIANCE_1,
-                                                                   L"DENOISER_AverageRadiance1",
+                                                                   "DENOISER_AverageRadiance1",
                                                                    FFX_RESOURCE_TYPE_TEXTURE2D,
                                                                    FFX_RESOURCE_USAGE_UAV,
                                                                    FFX_SURFACE_FORMAT_R11G11B10_FLOAT,
@@ -995,7 +996,7 @@ static FfxErrorCode denoiserReflectionsCreateResources(FfxDenoiserContext_Privat
                                                                    {FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED}},
 
                                                                   {FFX_DENOISER_RESOURCE_IDENTIFIER_REPROJECTED_RADIANCE,
-                                                                   L"DENOISER_ReprojectedRadiance",
+                                                                   "DENOISER_ReprojectedRadiance",
                                                                    FFX_RESOURCE_TYPE_TEXTURE2D,
                                                                    FFX_RESOURCE_USAGE_UAV,
                                                                    FFX_SURFACE_FORMAT_R16G16B16A16_FLOAT,
diff --git a/sdk/src/components/dof/CMakeLists.txt b/sdk/src/components/dof/CMakeLists.txt
index d5318f9..6f18536 100644
--- a/sdk/src/components/dof/CMakeLists.txt
+++ b/sdk/src/components/dof/CMakeLists.txt
@@ -38,9 +38,9 @@ if (FFX_DOF OR FFX_ALL)
 	list(APPEND PUBLIC_SOURCES ${FFX_PUBLIC_SOURCES})
 
 	if (FFX_BUILD_AS_DLL)
-		add_library(ffx_dof_${FFX_PLATFORM_NAME} SHARED ${SHARED_SOURCES} ${PRIVATE_SOURCES} ${PUBLIC_SOURCES})
+		add_library(dof SHARED ${SHARED_SOURCES} ${PRIVATE_SOURCES} ${PUBLIC_SOURCES})
 	else()
-		add_library(ffx_dof_${FFX_PLATFORM_NAME} STATIC ${SHARED_SOURCES} ${PRIVATE_SOURCES} ${PUBLIC_SOURCES})
+		add_library(dof STATIC ${SHARED_SOURCES} ${PRIVATE_SOURCES} ${PUBLIC_SOURCES})
 	endif()
 
 	# API
@@ -48,10 +48,17 @@ if (FFX_DOF OR FFX_ALL)
 	source_group("private_source" FILES ${PRIVATE_SOURCES})
 	source_group("public_source"  FILES ${PUBLIC_SOURCES})
 
-	target_include_directories(ffx_dof_${FFX_PLATFORM_NAME} PUBLIC ${FFX_INCLUDE_PATH})
-	target_include_directories(ffx_dof_${FFX_PLATFORM_NAME} PUBLIC ${FFX_SHARED_PATH})
+	target_include_directories(dof PUBLIC
+		$<BUILD_INTERFACE:${FFX_INCLUDE_PATH}>
+		$<INSTALL_INTERFACE:include>)
+	target_include_directories(dof PRIVATE ${FFX_SHARED_PATH})
 
 	set_source_files_properties(${SHADERS} PROPERTIES HEADER_FILE_ONLY TRUE)
-	set_target_properties(ffx_dof_${FFX_PLATFORM_NAME} PROPERTIES FOLDER Components)
+	set_target_properties(dof PROPERTIES FOLDER Components)
+	
+	install(TARGETS dof EXPORT dof-targets)
+	install(EXPORT dof-targets 
+		DESTINATION "${CMAKE_INSTALL_DATADIR}/cmake/${PROJECT_NAME}"
+		NAMESPACE fidelityfx::)
 	
 endif()
diff --git a/sdk/src/components/dof/ffx_dof.cpp b/sdk/src/components/dof/ffx_dof.cpp
index 70aab0e..993ef5a 100644
--- a/sdk/src/components/dof/ffx_dof.cpp
+++ b/sdk/src/components/dof/ffx_dof.cpp
@@ -21,9 +21,10 @@
 // THE SOFTWARE.
 
 #include <cstring>     // for memset
-#include <cstdlib>     // for _countof
+#include <cstdlib>     // for std::size
 #include <cmath>       // for fabs, abs, sinf, sqrt, etc.
 #include <array>
+#include <new>
 
 #define FFX_CPU
 #include <FidelityFX/host/ffx_dof.h>
@@ -36,31 +37,31 @@
 typedef struct ResourceBinding
 {
     uint32_t    index;
-    wchar_t     name[64];
+    char        name[64];
 }ResourceBinding;
 
 static const ResourceBinding srvTextureBindingTable[] =
 {
-    {FFX_DOF_RESOURCE_IDENTIFIER_INPUT_DEPTH,                  L"r_input_depth"},
-    {FFX_DOF_RESOURCE_IDENTIFIER_INPUT_COLOR,                  L"r_input_color"},
-    {FFX_DOF_RESOURCE_IDENTIFIER_INTERNAL_BILAT_COLOR,         L"r_internal_bilat_color"},
-    {FFX_DOF_RESOURCE_IDENTIFIER_INTERNAL_DILATED_RADIUS,      L"r_internal_dilated_radius"},
+    {FFX_DOF_RESOURCE_IDENTIFIER_INPUT_DEPTH,                  "r_input_depth"},
+    {FFX_DOF_RESOURCE_IDENTIFIER_INPUT_COLOR,                  "r_input_color"},
+    {FFX_DOF_RESOURCE_IDENTIFIER_INTERNAL_BILAT_COLOR,         "r_internal_bilat_color"},
+    {FFX_DOF_RESOURCE_IDENTIFIER_INTERNAL_DILATED_RADIUS,      "r_internal_dilated_radius"},
 };
 
 static const ResourceBinding uavTextureBindingTable[] =
 {
-    {FFX_DOF_RESOURCE_IDENTIFIER_INTERNAL_BILAT_COLOR_MIP0,    L"rw_internal_bilat_color"},
-    {FFX_DOF_RESOURCE_IDENTIFIER_INTERNAL_RADIUS,              L"rw_internal_radius"},
-    {FFX_DOF_RESOURCE_IDENTIFIER_INTERNAL_DILATED_RADIUS,      L"rw_internal_dilated_radius"},
-    {FFX_DOF_RESOURCE_IDENTIFIER_INTERNAL_NEAR,                L"rw_internal_near"},
-    {FFX_DOF_RESOURCE_IDENTIFIER_INTERNAL_FAR,                 L"rw_internal_far"},
-    {FFX_DOF_RESOURCE_IDENTIFIER_OUTPUT_COLOR,                 L"rw_output_color"},
-    {FFX_DOF_RESOURCE_IDENTIFIER_INTERNAL_GLOBALS,             L"rw_internal_globals"},
+    {FFX_DOF_RESOURCE_IDENTIFIER_INTERNAL_BILAT_COLOR_MIP0,    "rw_internal_bilat_color"},
+    {FFX_DOF_RESOURCE_IDENTIFIER_INTERNAL_RADIUS,              "rw_internal_radius"},
+    {FFX_DOF_RESOURCE_IDENTIFIER_INTERNAL_DILATED_RADIUS,      "rw_internal_dilated_radius"},
+    {FFX_DOF_RESOURCE_IDENTIFIER_INTERNAL_NEAR,                "rw_internal_near"},
+    {FFX_DOF_RESOURCE_IDENTIFIER_INTERNAL_FAR,                 "rw_internal_far"},
+    {FFX_DOF_RESOURCE_IDENTIFIER_OUTPUT_COLOR,                 "rw_output_color"},
+    {FFX_DOF_RESOURCE_IDENTIFIER_INTERNAL_GLOBALS,             "rw_internal_globals"},
 };
 
 static const ResourceBinding cbResourceBindingTable[] =
 {
-    {FFX_DOF_CONSTANTBUFFER_IDENTIFIER_DOF,                    L"cbDOF"},
+    {FFX_DOF_CONSTANTBUFFER_IDENTIFIER_DOF,                    "cbDOF"},
 };
 
 static FfxErrorCode patchResourceBindings(FfxPipelineState* inoutPipeline)
@@ -68,12 +69,12 @@ static FfxErrorCode patchResourceBindings(FfxPipelineState* inoutPipeline)
     for (uint32_t srvIndex = 0; srvIndex < inoutPipeline->srvTextureCount; ++srvIndex)
     {
         int32_t mapIndex = 0;
-        for (mapIndex = 0; mapIndex < _countof(srvTextureBindingTable); ++mapIndex)
+        for (mapIndex = 0; mapIndex < std::size(srvTextureBindingTable); ++mapIndex)
         {
-            if (0 == wcscmp(srvTextureBindingTable[mapIndex].name, inoutPipeline->srvTextureBindings[srvIndex].name))
+            if (0 == strcmp(srvTextureBindingTable[mapIndex].name, inoutPipeline->srvTextureBindings[srvIndex].name))
                 break;
         }
-        if (mapIndex == _countof(srvTextureBindingTable))
+        if (mapIndex == std::size(srvTextureBindingTable))
             return FFX_ERROR_INVALID_ARGUMENT;
 
         inoutPipeline->srvTextureBindings[srvIndex].resourceIdentifier = srvTextureBindingTable[mapIndex].index;
@@ -82,12 +83,12 @@ static FfxErrorCode patchResourceBindings(FfxPipelineState* inoutPipeline)
     for (uint32_t uavIndex = 0; uavIndex < inoutPipeline->uavTextureCount; ++uavIndex)
     {
         int32_t mapIndex = 0;
-        for (mapIndex = 0; mapIndex < _countof(uavTextureBindingTable); ++mapIndex)
+        for (mapIndex = 0; mapIndex < std::size(uavTextureBindingTable); ++mapIndex)
         {
-            if (0 == wcscmp(uavTextureBindingTable[mapIndex].name, inoutPipeline->uavTextureBindings[uavIndex].name))
+            if (0 == strcmp(uavTextureBindingTable[mapIndex].name, inoutPipeline->uavTextureBindings[uavIndex].name))
                 break;
         }
-        if (mapIndex == _countof(uavTextureBindingTable))
+        if (mapIndex == std::size(uavTextureBindingTable))
             return FFX_ERROR_INVALID_ARGUMENT;
 
         inoutPipeline->uavTextureBindings[uavIndex].resourceIdentifier = uavTextureBindingTable[mapIndex].index;
@@ -96,12 +97,12 @@ static FfxErrorCode patchResourceBindings(FfxPipelineState* inoutPipeline)
     for (uint32_t uavIndex = 0; uavIndex < inoutPipeline->uavBufferCount; ++uavIndex)
     {
         int32_t mapIndex = 0;
-        for (mapIndex = 0; mapIndex < _countof(uavTextureBindingTable); ++mapIndex)
+        for (mapIndex = 0; mapIndex < std::size(uavTextureBindingTable); ++mapIndex)
         {
-            if (0 == wcscmp(uavTextureBindingTable[mapIndex].name, inoutPipeline->uavBufferBindings[uavIndex].name))
+            if (0 == strcmp(uavTextureBindingTable[mapIndex].name, inoutPipeline->uavBufferBindings[uavIndex].name))
                 break;
         }
-        if (mapIndex == _countof(uavTextureBindingTable))
+        if (mapIndex == std::size(uavTextureBindingTable))
             return FFX_ERROR_INVALID_ARGUMENT;
 
         inoutPipeline->uavBufferBindings[uavIndex].resourceIdentifier = uavTextureBindingTable[mapIndex].index;
@@ -110,12 +111,12 @@ static FfxErrorCode patchResourceBindings(FfxPipelineState* inoutPipeline)
     for (uint32_t cbIndex = 0; cbIndex < inoutPipeline->constCount; ++cbIndex)
     {
         int32_t mapIndex = 0;
-        for (mapIndex = 0; mapIndex < _countof(cbResourceBindingTable); ++mapIndex)
+        for (mapIndex = 0; mapIndex < std::size(cbResourceBindingTable); ++mapIndex)
         {
-            if (0 == wcscmp(cbResourceBindingTable[mapIndex].name, inoutPipeline->constantBufferBindings[cbIndex].name))
+            if (0 == strcmp(cbResourceBindingTable[mapIndex].name, inoutPipeline->constantBufferBindings[cbIndex].name))
                 break;
         }
-        if (mapIndex == _countof(cbResourceBindingTable))
+        if (mapIndex == std::size(cbResourceBindingTable))
             return FFX_ERROR_INVALID_ARGUMENT;
 
         inoutPipeline->constantBufferBindings[cbIndex].resourceIdentifier = cbResourceBindingTable[mapIndex].index;
@@ -168,23 +169,23 @@ static FfxErrorCode createPipelineStates(FfxDofContext_Private* context)
     uint32_t contextFlags = context->contextDescription.flags;
 
     // Set up pipeline descriptors (basically RootSignature and binding)
-    wcscpy_s(pipelineDescription.name, L"DOF-DOWNSAMPLE-DEPTH");
+    strcpy(pipelineDescription.name, "DOF-DOWNSAMPLE-DEPTH");
     FFX_VALIDATE(context->contextDescription.backendInterface.fpCreatePipeline(&context->contextDescription.backendInterface, FFX_EFFECT_DOF, FFX_DOF_PASS_DOWNSAMPLE_DEPTH,
         getPipelinePermutationFlags(contextFlags, FFX_DOF_PASS_DOWNSAMPLE_DEPTH, supportedFP16, false),
         &pipelineDescription, context->effectContextId, &context->pipelineDsDepth));
-    wcscpy_s(pipelineDescription.name, L"DOF-DOWNSAMPLE-COLOR");
+    strcpy(pipelineDescription.name, "DOF-DOWNSAMPLE-COLOR");
     FFX_VALIDATE(context->contextDescription.backendInterface.fpCreatePipeline(&context->contextDescription.backendInterface, FFX_EFFECT_DOF, FFX_DOF_PASS_DOWNSAMPLE_COLOR,
         getPipelinePermutationFlags(contextFlags, FFX_DOF_PASS_DOWNSAMPLE_COLOR, supportedFP16, canForceWave64),
         &pipelineDescription, context->effectContextId, &context->pipelineDsColor));
-    wcscpy_s(pipelineDescription.name, L"DOF-DILATE");
+    strcpy(pipelineDescription.name, "DOF-DILATE");
     FFX_VALIDATE(context->contextDescription.backendInterface.fpCreatePipeline(&context->contextDescription.backendInterface, FFX_EFFECT_DOF, FFX_DOF_PASS_DILATE,
         getPipelinePermutationFlags(contextFlags, FFX_DOF_PASS_DILATE, supportedFP16, canForceWave64),
         &pipelineDescription, context->effectContextId, &context->pipelineDilate));
-    wcscpy_s(pipelineDescription.name, L"DOF-BLUR");
+    strcpy(pipelineDescription.name, "DOF-BLUR");
     FFX_VALIDATE(context->contextDescription.backendInterface.fpCreatePipeline(&context->contextDescription.backendInterface, FFX_EFFECT_DOF, FFX_DOF_PASS_BLUR,
         getPipelinePermutationFlags(contextFlags, FFX_DOF_PASS_BLUR, supportedFP16, canForceWave64),
         &pipelineDescription, context->effectContextId, &context->pipelineBlur));
-    wcscpy_s(pipelineDescription.name, L"DOF-COMPOSITE");
+    strcpy(pipelineDescription.name, "DOF-COMPOSITE");
     FFX_VALIDATE(context->contextDescription.backendInterface.fpCreatePipeline(&context->contextDescription.backendInterface, FFX_EFFECT_DOF, FFX_DOF_PASS_COMPOSITE,
         getPipelinePermutationFlags(contextFlags, FFX_DOF_PASS_COMPOSITE, supportedFP16, false),
         &pipelineDescription, context->effectContextId, &context->pipelineComposite));
@@ -202,7 +203,7 @@ static FfxErrorCode createPipelineStates(FfxDofContext_Private* context)
 static void scheduleDispatch(FfxDofContext_Private* context, const FfxDofDispatchDescription* params, const FfxPipelineState* pipeline, uint32_t dispatchX, uint32_t dispatchY)
 {
     FfxGpuJobDescription dispatchJob = {FFX_GPU_JOB_COMPUTE};
-    wcscpy_s(dispatchJob.jobLabel, pipeline->name);
+    strcpy(dispatchJob.jobLabel, pipeline->name);
 
     for (uint32_t currentShaderResourceViewIndex = 0; currentShaderResourceViewIndex < pipeline->srvTextureCount; ++currentShaderResourceViewIndex)
     {
@@ -210,7 +211,7 @@ static void scheduleDispatch(FfxDofContext_Private* context, const FfxDofDispatc
         const FfxResourceInternal currentResource = context->srvResources[currentResourceId];
         dispatchJob.computeJobDescriptor.srvTextures[currentShaderResourceViewIndex].resource = currentResource;
 #ifdef FFX_DEBUG
-        wcscpy_s(dispatchJob.computeJobDescriptor.srvTextures[currentShaderResourceViewIndex].name,
+        strcpy(dispatchJob.computeJobDescriptor.srvTextures[currentShaderResourceViewIndex].name,
                  pipeline->srvTextureBindings[currentShaderResourceViewIndex].name);
 #endif
     }
@@ -222,7 +223,7 @@ static void scheduleDispatch(FfxDofContext_Private* context, const FfxDofDispatc
 
         const uint32_t currentResourceId = binding.resourceIdentifier;
 #ifdef FFX_DEBUG
-        wcscpy_s(dispatchJob.computeJobDescriptor.uavTextures[currentUnorderedAccessViewIndex].name, binding.name);
+        strcpy(dispatchJob.computeJobDescriptor.uavTextures[currentUnorderedAccessViewIndex].name, binding.name);
 #endif
         if (currentResourceId == FFX_DOF_RESOURCE_IDENTIFIER_INTERNAL_BILAT_COLOR)
         {
@@ -246,7 +247,7 @@ static void scheduleDispatch(FfxDofContext_Private* context, const FfxDofDispatc
     {
         const uint32_t currentResourceId = pipeline->uavBufferBindings[currentUnorderedAccessViewIndex].resourceIdentifier;
 #ifdef FFX_DEBUG
-        wcscpy_s(dispatchJob.computeJobDescriptor.uavBuffers[currentUnorderedAccessViewIndex].name,
+        strcpy(dispatchJob.computeJobDescriptor.uavBuffers[currentUnorderedAccessViewIndex].name,
                  pipeline->uavBufferBindings[currentUnorderedAccessViewIndex].name);
 #endif
 
@@ -260,7 +261,7 @@ static void scheduleDispatch(FfxDofContext_Private* context, const FfxDofDispatc
     dispatchJob.computeJobDescriptor.pipeline      = *pipeline;
 
 #ifdef FFX_DEBUG
-    wcscpy_s(dispatchJob.computeJobDescriptor.cbNames[0], pipeline->constantBufferBindings[0].name);
+    strcpy(dispatchJob.computeJobDescriptor.cbNames[0], pipeline->constantBufferBindings[0].name);
 #endif
     dispatchJob.computeJobDescriptor.cbs[0] = context->constantBuffer;
 
@@ -360,7 +361,7 @@ static FfxErrorCode dofCreate(FfxDofContext_Private* context, const FfxDofContex
     bool is16bit = context->deviceCapabilities.fp16Supported;
     FfxInternalResourceDescription internalSurfaceDesc[] = {
         {FFX_DOF_RESOURCE_IDENTIFIER_INTERNAL_BILAT_COLOR,
-         L"DOF_InternalBilatColor",
+         "DOF_InternalBilatColor",
          FFX_RESOURCE_TYPE_TEXTURE2D,
          FFX_RESOURCE_USAGE_UAV,
          is16bit ? FFX_SURFACE_FORMAT_R16G16B16A16_FLOAT : FFX_SURFACE_FORMAT_R32G32B32A32_FLOAT,
@@ -370,7 +371,7 @@ static FfxErrorCode dofCreate(FfxDofContext_Private* context, const FfxDofContex
          FFX_RESOURCE_FLAGS_ALIASABLE,
          {FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED}},
         {FFX_DOF_RESOURCE_IDENTIFIER_INTERNAL_RADIUS,
-         L"DOF_InternalRadius",
+         "DOF_InternalRadius",
          FFX_RESOURCE_TYPE_TEXTURE2D,
          FFX_RESOURCE_USAGE_UAV,
          is16bit ? FFX_SURFACE_FORMAT_R16G16_FLOAT : FFX_SURFACE_FORMAT_R32G32_FLOAT,
@@ -380,7 +381,7 @@ static FfxErrorCode dofCreate(FfxDofContext_Private* context, const FfxDofContex
          FFX_RESOURCE_FLAGS_ALIASABLE,
          {FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED}},
         {FFX_DOF_RESOURCE_IDENTIFIER_INTERNAL_DILATED_RADIUS,
-         L"DOF_InternalDilatedRadius",
+         "DOF_InternalDilatedRadius",
          FFX_RESOURCE_TYPE_TEXTURE2D,
          FFX_RESOURCE_USAGE_UAV,
          is16bit ? FFX_SURFACE_FORMAT_R16G16_FLOAT : FFX_SURFACE_FORMAT_R32G32_FLOAT,
@@ -390,7 +391,7 @@ static FfxErrorCode dofCreate(FfxDofContext_Private* context, const FfxDofContex
          FFX_RESOURCE_FLAGS_ALIASABLE,
          {FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED}},
         {FFX_DOF_RESOURCE_IDENTIFIER_INTERNAL_NEAR,
-         L"DOF_InternalNear",
+         "DOF_InternalNear",
          FFX_RESOURCE_TYPE_TEXTURE2D,
          FFX_RESOURCE_USAGE_UAV,
          is16bit ? FFX_SURFACE_FORMAT_R16G16B16A16_FLOAT : FFX_SURFACE_FORMAT_R32G32B32A32_FLOAT,
@@ -400,7 +401,7 @@ static FfxErrorCode dofCreate(FfxDofContext_Private* context, const FfxDofContex
          FFX_RESOURCE_FLAGS_ALIASABLE,
          {FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED}},
         {FFX_DOF_RESOURCE_IDENTIFIER_INTERNAL_FAR,
-         L"DOF_InternalFar",
+         "DOF_InternalFar",
          FFX_RESOURCE_TYPE_TEXTURE2D,
          FFX_RESOURCE_USAGE_UAV,
          is16bit ? FFX_SURFACE_FORMAT_R16G16B16A16_FLOAT : FFX_SURFACE_FORMAT_R32G32B32A32_FLOAT,
@@ -435,7 +436,7 @@ static FfxErrorCode dofCreate(FfxDofContext_Private* context, const FfxDofContex
         const FfxCreateResourceDescription createResourceDescription = {FFX_HEAP_TYPE_DEFAULT,
                                                                         resourceDescription,
                                                                         FFX_RESOURCE_STATE_UNORDERED_ACCESS,
-                                                                        L"DOF_InternalGlobals",
+                                                                        "DOF_InternalGlobals",
                                                                         FFX_DOF_RESOURCE_IDENTIFIER_INTERNAL_GLOBALS,
                                                                         {FFX_RESOURCE_INIT_DATA_TYPE_VALUE, sizeof(uint32_t), 0}};
 
diff --git a/sdk/src/components/frameinterpolation/CMakeLists.txt b/sdk/src/components/frameinterpolation/CMakeLists.txt
index 9b92229..ab4529f 100644
--- a/sdk/src/components/frameinterpolation/CMakeLists.txt
+++ b/sdk/src/components/frameinterpolation/CMakeLists.txt
@@ -39,9 +39,9 @@ if (FFX_FI OR FFX_ALL)
 	list(APPEND PUBLIC_SOURCES ${FFX_PUBLIC_SOURCES})
 
 	if (FFX_BUILD_AS_DLL)
-		add_library(ffx_frameinterpolation_${FFX_PLATFORM_NAME} SHARED ${SHARED_SOURCES} ${PRIVATE_SOURCES} ${PUBLIC_SOURCES})
+		add_library(frameinterpolation SHARED ${SHARED_SOURCES} ${PRIVATE_SOURCES} ${PUBLIC_SOURCES})
 	else()
-		add_library(ffx_frameinterpolation_${FFX_PLATFORM_NAME} STATIC ${SHARED_SOURCES} ${PRIVATE_SOURCES} ${PUBLIC_SOURCES})
+		add_library(frameinterpolation STATIC ${SHARED_SOURCES} ${PRIVATE_SOURCES} ${PUBLIC_SOURCES})
 	endif()
 
 	# API
@@ -49,10 +49,17 @@ if (FFX_FI OR FFX_ALL)
 	source_group("private_source" FILES ${PRIVATE_SOURCES})
 	source_group("public_source"  FILES ${PUBLIC_SOURCES})
 
-	target_include_directories(ffx_frameinterpolation_${FFX_PLATFORM_NAME} PUBLIC ${FFX_INCLUDE_PATH})
-	target_include_directories(ffx_frameinterpolation_${FFX_PLATFORM_NAME} PUBLIC ${FFX_SHARED_PATH})
+	target_include_directories(frameinterpolation PUBLIC
+		$<BUILD_INTERFACE:${FFX_INCLUDE_PATH}>
+		$<INSTALL_INTERFACE:include>)
+	target_include_directories(frameinterpolation PRIVATE ${FFX_SHARED_PATH})
 
 	set_source_files_properties(${SHADERS} PROPERTIES HEADER_FILE_ONLY TRUE)
-	set_target_properties(ffx_frameinterpolation_${FFX_PLATFORM_NAME} PROPERTIES FOLDER Components)
+	set_target_properties(frameinterpolation PROPERTIES FOLDER Components)
+	
+	install(TARGETS frameinterpolation EXPORT frameinterpolation-targets)
+	install(EXPORT frameinterpolation-targets 
+		DESTINATION "${CMAKE_INSTALL_DATADIR}/cmake/${PROJECT_NAME}"
+		NAMESPACE fidelityfx::)
 	
 endif()
diff --git a/sdk/src/components/frameinterpolation/ffx_frameinterpolation.cpp b/sdk/src/components/frameinterpolation/ffx_frameinterpolation.cpp
index 66fb0a0..6d7cb42 100644
--- a/sdk/src/components/frameinterpolation/ffx_frameinterpolation.cpp
+++ b/sdk/src/components/frameinterpolation/ffx_frameinterpolation.cpp
@@ -23,6 +23,7 @@
 #include <algorithm>    // for max used inside SPD CPU code.
 #include <cmath>        // for fabs, abs, sinf, sqrt, etc.
 #include <string>       // for memset
+#include <cstring>      // for memset
 #include <cfloat>       // for FLT_EPSILON
 #include <FidelityFX/host/ffx_frameinterpolation.h>
 
@@ -43,74 +44,74 @@
 typedef struct ResourceBinding
 {
     uint32_t    index;
-    wchar_t     name[64];
+    char        name[64];
 }ResourceBinding;
 
 static const ResourceBinding srvResourceBindingTable[] =
 {
     // Frame Interpolation textures
-    {FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_DEPTH,                                      L"r_input_depth"},
-    {FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_MOTION_VECTORS,                             L"r_input_motion_vectors"},
-    {FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_DISTORTION_FIELD,                           L"r_input_distortion_field"},
-
-    {FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_DILATED_DEPTH,                              L"r_dilated_depth"},
-    {FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_DILATED_MOTION_VECTORS,                     L"r_dilated_motion_vectors"},
-    {FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_RECONSTRUCTED_DEPTH_PREVIOUS_FRAME,         L"r_reconstructed_depth_previous_frame"},
-    {FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_RECONSTRUCTED_DEPTH_INTERPOLATED_FRAME,     L"r_reconstructed_depth_interpolated_frame"},
-    {FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_PREVIOUS_INTERPOLATION_SOURCE,              L"r_previous_interpolation_source"},
-    {FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_CURRENT_INTERPOLATION_SOURCE,               L"r_current_interpolation_source"},
-    {FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_DISOCCLUSION_MASK,                          L"r_disocclusion_mask"},
-    {FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_GAME_MOTION_VECTOR_FIELD_X,                 L"r_game_motion_vector_field_x"},
-    {FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_GAME_MOTION_VECTOR_FIELD_Y,                 L"r_game_motion_vector_field_y"},
-    {FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_OPTICAL_FLOW_MOTION_VECTOR_FIELD_X,         L"r_optical_flow_motion_vector_field_x"},
-    {FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_OPTICAL_FLOW_MOTION_VECTOR_FIELD_Y,         L"r_optical_flow_motion_vector_field_y"},
-
-    {FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_OPTICAL_FLOW_VECTOR,                        L"r_optical_flow"},
-    {FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_OPTICAL_FLOW_CONFIDENCE,                    L"r_optical_flow_confidence"},
-    {FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_OPTICAL_FLOW_GLOBAL_MOTION,                 L"r_optical_flow_global_motion"},
-    {FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_OPTICAL_FLOW_SCENE_CHANGE_DETECTION,        L"r_optical_flow_scd"},
-    {FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_OUTPUT,                                     L"r_output"},
-    {FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_INPAINTING_MASK,                            L"r_inpainting_mask"},
-    {FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_INPAINTING_PYRAMID,                         L"r_inpainting_pyramid"},
-    {FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_PRESENT_BACKBUFFER,                         L"r_present_backbuffer"},
-    {FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_COUNTERS,                                   L"r_counters"},
+    {FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_DEPTH,                                      "r_input_depth"},
+    {FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_MOTION_VECTORS,                             "r_input_motion_vectors"},
+    {FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_DISTORTION_FIELD,                           "r_input_distortion_field"},
+
+    {FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_DILATED_DEPTH,                              "r_dilated_depth"},
+    {FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_DILATED_MOTION_VECTORS,                     "r_dilated_motion_vectors"},
+    {FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_RECONSTRUCTED_DEPTH_PREVIOUS_FRAME,         "r_reconstructed_depth_previous_frame"},
+    {FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_RECONSTRUCTED_DEPTH_INTERPOLATED_FRAME,     "r_reconstructed_depth_interpolated_frame"},
+    {FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_PREVIOUS_INTERPOLATION_SOURCE,              "r_previous_interpolation_source"},
+    {FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_CURRENT_INTERPOLATION_SOURCE,               "r_current_interpolation_source"},
+    {FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_DISOCCLUSION_MASK,                          "r_disocclusion_mask"},
+    {FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_GAME_MOTION_VECTOR_FIELD_X,                 "r_game_motion_vector_field_x"},
+    {FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_GAME_MOTION_VECTOR_FIELD_Y,                 "r_game_motion_vector_field_y"},
+    {FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_OPTICAL_FLOW_MOTION_VECTOR_FIELD_X,         "r_optical_flow_motion_vector_field_x"},
+    {FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_OPTICAL_FLOW_MOTION_VECTOR_FIELD_Y,         "r_optical_flow_motion_vector_field_y"},
+
+    {FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_OPTICAL_FLOW_VECTOR,                        "r_optical_flow"},
+    {FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_OPTICAL_FLOW_CONFIDENCE,                    "r_optical_flow_confidence"},
+    {FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_OPTICAL_FLOW_GLOBAL_MOTION,                 "r_optical_flow_global_motion"},
+    {FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_OPTICAL_FLOW_SCENE_CHANGE_DETECTION,        "r_optical_flow_scd"},
+    {FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_OUTPUT,                                     "r_output"},
+    {FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_INPAINTING_MASK,                            "r_inpainting_mask"},
+    {FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_INPAINTING_PYRAMID,                         "r_inpainting_pyramid"},
+    {FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_PRESENT_BACKBUFFER,                         "r_present_backbuffer"},
+    {FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_COUNTERS,                                   "r_counters"},
 };
 
 static const ResourceBinding uavResourceBindingTable[] =
 {
     // Frame Interpolation textures
-    {FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_DILATED_DEPTH,                              L"rw_dilated_depth"},
-    {FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_DILATED_MOTION_VECTORS,                     L"rw_dilated_motion_vectors"},
-    {FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_RECONSTRUCTED_DEPTH_PREVIOUS_FRAME,         L"rw_reconstructed_depth_previous_frame"},
-    {FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_RECONSTRUCTED_DEPTH_INTERPOLATED_FRAME,     L"rw_reconstructed_depth_interpolated_frame"},
-    {FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_OUTPUT,                                     L"rw_output"},
-    {FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_DISOCCLUSION_MASK,                          L"rw_disocclusion_mask"},
-    {FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_GAME_MOTION_VECTOR_FIELD_X,                 L"rw_game_motion_vector_field_x"},
-    {FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_GAME_MOTION_VECTOR_FIELD_Y,                 L"rw_game_motion_vector_field_y"},
-    {FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_OPTICAL_FLOW_MOTION_VECTOR_FIELD_X,         L"rw_optical_flow_motion_vector_field_x"},
-    {FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_OPTICAL_FLOW_MOTION_VECTOR_FIELD_Y,         L"rw_optical_flow_motion_vector_field_y"},
-    {FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_INPAINTING_MASK,                            L"rw_inpainting_mask"},
-
-    {FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_COUNTERS,                                   L"rw_counters"},
-    {FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_INPAINTING_PYRAMID_MIPMAP_0,                L"rw_inpainting_pyramid0"},
-    {FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_INPAINTING_PYRAMID_MIPMAP_1,                L"rw_inpainting_pyramid1"},
-    {FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_INPAINTING_PYRAMID_MIPMAP_2,                L"rw_inpainting_pyramid2"},
-    {FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_INPAINTING_PYRAMID_MIPMAP_3,                L"rw_inpainting_pyramid3"},
-    {FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_INPAINTING_PYRAMID_MIPMAP_4,                L"rw_inpainting_pyramid4"},
-    {FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_INPAINTING_PYRAMID_MIPMAP_5,                L"rw_inpainting_pyramid5"}, // extra declaration, as this is globallycoherent
-    {FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_INPAINTING_PYRAMID_MIPMAP_6,                L"rw_inpainting_pyramid6"},
-    {FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_INPAINTING_PYRAMID_MIPMAP_7,                L"rw_inpainting_pyramid7"},
-    {FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_INPAINTING_PYRAMID_MIPMAP_8,                L"rw_inpainting_pyramid8"},
-    {FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_INPAINTING_PYRAMID_MIPMAP_9,                L"rw_inpainting_pyramid9"},
-    {FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_INPAINTING_PYRAMID_MIPMAP_10,               L"rw_inpainting_pyramid10"},
-    {FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_INPAINTING_PYRAMID_MIPMAP_11,               L"rw_inpainting_pyramid11"},
-    {FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_INPAINTING_PYRAMID_MIPMAP_12,               L"rw_inpainting_pyramid12"},
+    {FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_DILATED_DEPTH,                              "rw_dilated_depth"},
+    {FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_DILATED_MOTION_VECTORS,                     "rw_dilated_motion_vectors"},
+    {FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_RECONSTRUCTED_DEPTH_PREVIOUS_FRAME,         "rw_reconstructed_depth_previous_frame"},
+    {FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_RECONSTRUCTED_DEPTH_INTERPOLATED_FRAME,     "rw_reconstructed_depth_interpolated_frame"},
+    {FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_OUTPUT,                                     "rw_output"},
+    {FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_DISOCCLUSION_MASK,                          "rw_disocclusion_mask"},
+    {FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_GAME_MOTION_VECTOR_FIELD_X,                 "rw_game_motion_vector_field_x"},
+    {FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_GAME_MOTION_VECTOR_FIELD_Y,                 "rw_game_motion_vector_field_y"},
+    {FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_OPTICAL_FLOW_MOTION_VECTOR_FIELD_X,         "rw_optical_flow_motion_vector_field_x"},
+    {FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_OPTICAL_FLOW_MOTION_VECTOR_FIELD_Y,         "rw_optical_flow_motion_vector_field_y"},
+    {FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_INPAINTING_MASK,                            "rw_inpainting_mask"},
+
+    {FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_COUNTERS,                                   "rw_counters"},
+    {FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_INPAINTING_PYRAMID_MIPMAP_0,                "rw_inpainting_pyramid0"},
+    {FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_INPAINTING_PYRAMID_MIPMAP_1,                "rw_inpainting_pyramid1"},
+    {FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_INPAINTING_PYRAMID_MIPMAP_2,                "rw_inpainting_pyramid2"},
+    {FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_INPAINTING_PYRAMID_MIPMAP_3,                "rw_inpainting_pyramid3"},
+    {FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_INPAINTING_PYRAMID_MIPMAP_4,                "rw_inpainting_pyramid4"},
+    {FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_INPAINTING_PYRAMID_MIPMAP_5,                "rw_inpainting_pyramid5"}, // extra declaration, as this is globallycoherent
+    {FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_INPAINTING_PYRAMID_MIPMAP_6,                "rw_inpainting_pyramid6"},
+    {FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_INPAINTING_PYRAMID_MIPMAP_7,                "rw_inpainting_pyramid7"},
+    {FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_INPAINTING_PYRAMID_MIPMAP_8,                "rw_inpainting_pyramid8"},
+    {FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_INPAINTING_PYRAMID_MIPMAP_9,                "rw_inpainting_pyramid9"},
+    {FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_INPAINTING_PYRAMID_MIPMAP_10,               "rw_inpainting_pyramid10"},
+    {FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_INPAINTING_PYRAMID_MIPMAP_11,               "rw_inpainting_pyramid11"},
+    {FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_INPAINTING_PYRAMID_MIPMAP_12,               "rw_inpainting_pyramid12"},
 };
 
 static const ResourceBinding cbResourceBindingTable[] =
 {
-    {FFX_FRAMEINTERPOLATION_CONSTANTBUFFER_IDENTIFIER,                                      L"cbFI"},
-    {FFX_FRAMEINTERPOLATION_INPAINTING_PYRAMID_CONSTANTBUFFER_IDENTIFIER,                   L"cbInpaintingPyramid"},
+    {FFX_FRAMEINTERPOLATION_CONSTANTBUFFER_IDENTIFIER,                                      "cbFI"},
+    {FFX_FRAMEINTERPOLATION_INPAINTING_PYRAMID_CONSTANTBUFFER_IDENTIFIER,                   "cbInpaintingPyramid"},
 };
 
 // Broad structure of the root signature.
@@ -154,12 +155,12 @@ static FfxErrorCode patchResourceBindings(FfxPipelineState* inoutPipeline)
     for (uint32_t srvIndex = 0; srvIndex < inoutPipeline->srvTextureCount; ++srvIndex)
     {
         int32_t mapIndex = 0;
-        for (mapIndex = 0; mapIndex < _countof(srvResourceBindingTable); ++mapIndex)
+        for (mapIndex = 0; mapIndex < std::size(srvResourceBindingTable); ++mapIndex)
         {
-            if (0 == wcscmp(srvResourceBindingTable[mapIndex].name, inoutPipeline->srvTextureBindings[srvIndex].name))
+            if (0 == strcmp(srvResourceBindingTable[mapIndex].name, inoutPipeline->srvTextureBindings[srvIndex].name))
                 break;
         }
-        if (mapIndex == _countof(srvResourceBindingTable))
+        if (mapIndex == std::size(srvResourceBindingTable))
             return FFX_ERROR_INVALID_ARGUMENT;
 
         inoutPipeline->srvTextureBindings[srvIndex].resourceIdentifier = srvResourceBindingTable[mapIndex].index;
@@ -169,12 +170,12 @@ static FfxErrorCode patchResourceBindings(FfxPipelineState* inoutPipeline)
     for (uint32_t uavIndex = 0; uavIndex < inoutPipeline->uavTextureCount; ++uavIndex)
     {
         int32_t mapIndex = 0;
-        for (mapIndex = 0; mapIndex < _countof(uavResourceBindingTable); ++mapIndex)
+        for (mapIndex = 0; mapIndex < std::size(uavResourceBindingTable); ++mapIndex)
         {
-            if (0 == wcscmp(uavResourceBindingTable[mapIndex].name, inoutPipeline->uavTextureBindings[uavIndex].name))
+            if (0 == strcmp(uavResourceBindingTable[mapIndex].name, inoutPipeline->uavTextureBindings[uavIndex].name))
                 break;
         }
-        if (mapIndex == _countof(uavResourceBindingTable))
+        if (mapIndex == std::size(uavResourceBindingTable))
             return FFX_ERROR_INVALID_ARGUMENT;
 
         inoutPipeline->uavTextureBindings[uavIndex].resourceIdentifier = uavResourceBindingTable[mapIndex].index;
@@ -183,12 +184,12 @@ static FfxErrorCode patchResourceBindings(FfxPipelineState* inoutPipeline)
     for (uint32_t cbIndex = 0; cbIndex < inoutPipeline->constCount; ++cbIndex)
     {
         int32_t mapIndex = 0;
-        for (mapIndex = 0; mapIndex < _countof(cbResourceBindingTable); ++mapIndex)
+        for (mapIndex = 0; mapIndex < std::size(cbResourceBindingTable); ++mapIndex)
         {
-            if (0 == wcscmp(cbResourceBindingTable[mapIndex].name, inoutPipeline->constantBufferBindings[cbIndex].name))
+            if (0 == strcmp(cbResourceBindingTable[mapIndex].name, inoutPipeline->constantBufferBindings[cbIndex].name))
                 break;
         }
-        if (mapIndex == _countof(cbResourceBindingTable))
+        if (mapIndex == std::size(cbResourceBindingTable))
             return FFX_ERROR_INVALID_ARGUMENT;
 
         inoutPipeline->constantBufferBindings[cbIndex].resourceIdentifier = cbResourceBindingTable[mapIndex].index;
@@ -197,12 +198,12 @@ static FfxErrorCode patchResourceBindings(FfxPipelineState* inoutPipeline)
     for (uint32_t uavBufferIndex = 0; uavBufferIndex < inoutPipeline->uavBufferCount; ++uavBufferIndex)
     {
         int32_t mapIndex = 0;
-        for (mapIndex = 0; mapIndex < _countof(uavResourceBindingTable); ++mapIndex)
+        for (mapIndex = 0; mapIndex < std::size(uavResourceBindingTable); ++mapIndex)
         {
-            if (0 == wcscmp(uavResourceBindingTable[mapIndex].name, inoutPipeline->uavBufferBindings[uavBufferIndex].name))
+            if (0 == strcmp(uavResourceBindingTable[mapIndex].name, inoutPipeline->uavBufferBindings[uavBufferIndex].name))
                 break;
         }
-        if (mapIndex == _countof(uavResourceBindingTable))
+        if (mapIndex == std::size(uavResourceBindingTable))
             return FFX_ERROR_INVALID_ARGUMENT;
 
         inoutPipeline->uavBufferBindings[uavBufferIndex].resourceIdentifier = uavResourceBindingTable[mapIndex].index;
@@ -211,12 +212,12 @@ static FfxErrorCode patchResourceBindings(FfxPipelineState* inoutPipeline)
     for (uint32_t srvBufferIndex = 0; srvBufferIndex < inoutPipeline->srvBufferCount; ++srvBufferIndex)
     {
         int32_t mapIndex = 0;
-        for (mapIndex = 0; mapIndex < _countof(srvResourceBindingTable); ++mapIndex)
+        for (mapIndex = 0; mapIndex < std::size(srvResourceBindingTable); ++mapIndex)
         {
-            if (0 == wcscmp(srvResourceBindingTable[mapIndex].name, inoutPipeline->srvBufferBindings[srvBufferIndex].name))
+            if (0 == strcmp(srvResourceBindingTable[mapIndex].name, inoutPipeline->srvBufferBindings[srvBufferIndex].name))
                 break;
         }
-        if (mapIndex == _countof(srvResourceBindingTable))
+        if (mapIndex == std::size(srvResourceBindingTable))
             return FFX_ERROR_INVALID_ARGUMENT;
 
         inoutPipeline->srvBufferBindings[srvBufferIndex].resourceIdentifier = srvResourceBindingTable[mapIndex].index;
@@ -286,9 +287,9 @@ static FfxErrorCode createPipelineStates(FfxFrameInterpolationContext_Private* c
     uint32_t contextFlags = context->contextDescription.flags;
 
     // Set up pipeline descriptor (basically RootSignature and binding)
-    auto CreateComputePipeline = [&](FfxPass pass, const wchar_t* name, FfxPipelineState* pipeline) -> FfxErrorCode {
+    auto CreateComputePipeline = [&](FfxPass pass, const char* name, FfxPipelineState* pipeline) -> FfxErrorCode {
         ffxSafeReleasePipeline(&context->contextDescription.backendInterface, pipeline, context->effectContextId);
-        wcscpy_s(pipelineDescription.name, name);
+        strcpy(pipelineDescription.name, name);
         FFX_VALIDATE(context->contextDescription.backendInterface.fpCreatePipeline(
             &context->contextDescription.backendInterface,
             FFX_EFFECT_FRAMEINTERPOLATION,
@@ -302,8 +303,8 @@ static FfxErrorCode createPipelineStates(FfxFrameInterpolationContext_Private* c
         return FFX_OK;
     };
 
-    auto CreateRasterPipeline = [&](FfxPass pass, const wchar_t* name, FfxPipelineState* pipeline) -> FfxErrorCode {
-        wcscpy_s(pipelineDescription.name, name);
+    auto CreateRasterPipeline = [&](FfxPass pass, const char* name, FfxPipelineState* pipeline) -> FfxErrorCode {
+        strcpy(pipelineDescription.name, name);
         pipelineDescription.stage            = (FfxBindStage)(FFX_BIND_VERTEX_SHADER_STAGE | FFX_BIND_PIXEL_SHADER_STAGE);
         pipelineDescription.backbufferFormat = context->contextDescription.backBufferFormat;
         FFX_VALIDATE(context->contextDescription.backendInterface.fpCreatePipeline(
@@ -319,17 +320,17 @@ static FfxErrorCode createPipelineStates(FfxFrameInterpolationContext_Private* c
     };
 
     // Frame Interpolation Pipelines
-    CreateComputePipeline(FFX_FRAMEINTERPOLATION_PASS_RECONSTRUCT_AND_DILATE,               L"RECONSTRUCT_AND_DILATE", &context->pipelineFiReconstructAndDilate);
-    CreateComputePipeline(FFX_FRAMEINTERPOLATION_PASS_SETUP,                                L"SETUP", &context->pipelineFiSetup);
-    CreateComputePipeline(FFX_FRAMEINTERPOLATION_PASS_RECONSTRUCT_PREV_DEPTH,               L"RECONSTRUCT_PREV_DEPTH", &context->pipelineFiReconstructPreviousDepth);
-    CreateComputePipeline(FFX_FRAMEINTERPOLATION_PASS_GAME_MOTION_VECTOR_FIELD,             L"GAME_MOTION_VECTOR_FIELD", &context->pipelineFiGameMotionVectorField);
-    CreateComputePipeline(FFX_FRAMEINTERPOLATION_PASS_OPTICAL_FLOW_VECTOR_FIELD,            L"OPTICAL_FLOW_VECTOR_FIELD", &context->pipelineFiOpticalFlowVectorField);
-    CreateComputePipeline(FFX_FRAMEINTERPOLATION_PASS_DISOCCLUSION_MASK,                    L"DISOCCLUSION_MASK", &context->pipelineFiDisocclusionMask);
-    CreateComputePipeline(FFX_FRAMEINTERPOLATION_PASS_INTERPOLATION,                        L"INTERPOLATION", &context->pipelineFiScfi);
-    CreateComputePipeline(FFX_FRAMEINTERPOLATION_PASS_INPAINTING_PYRAMID,                   L"INPAINTING_PYRAMID", &context->pipelineInpaintingPyramid);
-    CreateComputePipeline(FFX_FRAMEINTERPOLATION_PASS_INPAINTING,                           L"INPAINTING", &context->pipelineInpainting);
-    CreateComputePipeline(FFX_FRAMEINTERPOLATION_PASS_GAME_VECTOR_FIELD_INPAINTING_PYRAMID, L"GAME_VECTOR_FIELD_INPAINTING_PYRAMID", & context->pipelineGameVectorFieldInpaintingPyramid);
-    CreateComputePipeline(FFX_FRAMEINTERPOLATION_PASS_DEBUG_VIEW,                           L"DEBUG_VIEW", &context->pipelineDebugView);
+    CreateComputePipeline(FFX_FRAMEINTERPOLATION_PASS_RECONSTRUCT_AND_DILATE,               "RECONSTRUCT_AND_DILATE", &context->pipelineFiReconstructAndDilate);
+    CreateComputePipeline(FFX_FRAMEINTERPOLATION_PASS_SETUP,                                "SETUP", &context->pipelineFiSetup);
+    CreateComputePipeline(FFX_FRAMEINTERPOLATION_PASS_RECONSTRUCT_PREV_DEPTH,               "RECONSTRUCT_PREV_DEPTH", &context->pipelineFiReconstructPreviousDepth);
+    CreateComputePipeline(FFX_FRAMEINTERPOLATION_PASS_GAME_MOTION_VECTOR_FIELD,             "GAME_MOTION_VECTOR_FIELD", &context->pipelineFiGameMotionVectorField);
+    CreateComputePipeline(FFX_FRAMEINTERPOLATION_PASS_OPTICAL_FLOW_VECTOR_FIELD,            "OPTICAL_FLOW_VECTOR_FIELD", &context->pipelineFiOpticalFlowVectorField);
+    CreateComputePipeline(FFX_FRAMEINTERPOLATION_PASS_DISOCCLUSION_MASK,                    "DISOCCLUSION_MASK", &context->pipelineFiDisocclusionMask);
+    CreateComputePipeline(FFX_FRAMEINTERPOLATION_PASS_INTERPOLATION,                        "INTERPOLATION", &context->pipelineFiScfi);
+    CreateComputePipeline(FFX_FRAMEINTERPOLATION_PASS_INPAINTING_PYRAMID,                   "INPAINTING_PYRAMID", &context->pipelineInpaintingPyramid);
+    CreateComputePipeline(FFX_FRAMEINTERPOLATION_PASS_INPAINTING,                           "INPAINTING", &context->pipelineInpainting);
+    CreateComputePipeline(FFX_FRAMEINTERPOLATION_PASS_GAME_VECTOR_FIELD_INPAINTING_PYRAMID, "GAME_VECTOR_FIELD_INPAINTING_PYRAMID", & context->pipelineGameVectorFieldInpaintingPyramid);
+    CreateComputePipeline(FFX_FRAMEINTERPOLATION_PASS_DEBUG_VIEW,                           "DEBUG_VIEW", &context->pipelineDebugView);
 
     return FFX_OK;
 }
@@ -458,27 +459,27 @@ static FfxErrorCode frameinterpolationCreate(FfxFrameInterpolationContext_Privat
     // declare internal resources needed
     const FfxInternalResourceDescription internalSurfaceDesc[] = {
 
-        {FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_RECONSTRUCTED_DEPTH_INTERPOLATED_FRAME, L"FI_ReconstructedDepthInterpolatedFrame",  FFX_RESOURCE_TYPE_TEXTURE2D, FFX_RESOURCE_USAGE_UAV,
+        {FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_RECONSTRUCTED_DEPTH_INTERPOLATED_FRAME, "FI_ReconstructedDepthInterpolatedFrame",  FFX_RESOURCE_TYPE_TEXTURE2D, FFX_RESOURCE_USAGE_UAV,
             FFX_SURFACE_FORMAT_R32_UINT, contextDescription->maxRenderSize.width, contextDescription->maxRenderSize.height, 1,      FFX_RESOURCE_FLAGS_ALIASABLE, {FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED}},
-        {FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_GAME_MOTION_VECTOR_FIELD_X,             L"FI_GameMotionVectorFieldX",               FFX_RESOURCE_TYPE_TEXTURE2D, FFX_RESOURCE_USAGE_UAV, 
+        {FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_GAME_MOTION_VECTOR_FIELD_X,             "FI_GameMotionVectorFieldX",               FFX_RESOURCE_TYPE_TEXTURE2D, FFX_RESOURCE_USAGE_UAV, 
             FFX_SURFACE_FORMAT_R32_UINT, contextDescription->maxRenderSize.width, contextDescription->maxRenderSize.height, 1,      FFX_RESOURCE_FLAGS_ALIASABLE, {FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED}},
-        {FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_GAME_MOTION_VECTOR_FIELD_Y,             L"FI_GameMotionVectorFieldY",               FFX_RESOURCE_TYPE_TEXTURE2D, FFX_RESOURCE_USAGE_UAV,
+        {FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_GAME_MOTION_VECTOR_FIELD_Y,             "FI_GameMotionVectorFieldY",               FFX_RESOURCE_TYPE_TEXTURE2D, FFX_RESOURCE_USAGE_UAV,
             FFX_SURFACE_FORMAT_R32_UINT, contextDescription->maxRenderSize.width, contextDescription->maxRenderSize.height, 1,      FFX_RESOURCE_FLAGS_ALIASABLE, {FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED}},
-        {FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_INPAINTING_PYRAMID,                     L"FI_InpaintingPyramid",                    FFX_RESOURCE_TYPE_TEXTURE2D, FFX_RESOURCE_USAGE_UAV,
+        {FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_INPAINTING_PYRAMID,                     "FI_InpaintingPyramid",                    FFX_RESOURCE_TYPE_TEXTURE2D, FFX_RESOURCE_USAGE_UAV,
             FFX_SURFACE_FORMAT_R16G16B16A16_FLOAT, contextDescription->displaySize.width / 2, contextDescription->displaySize.height / 2, 0, FFX_RESOURCE_FLAGS_ALIASABLE, {FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED}},
-        {FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_COUNTERS,                               L"FI_Counters",                             FFX_RESOURCE_TYPE_BUFFER, FFX_RESOURCE_USAGE_UAV,
+        {FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_COUNTERS,                               "FI_Counters",                             FFX_RESOURCE_TYPE_BUFFER, FFX_RESOURCE_USAGE_UAV,
             FFX_SURFACE_FORMAT_UNKNOWN, 8, 4, 1, FFX_RESOURCE_FLAGS_NONE, {FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED}}, // structured buffer contraining 2 UINT values
-        {FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_OPTICAL_FLOW_MOTION_VECTOR_FIELD_X,     L"FI_OpticalFlowMotionVectorFieldX",        FFX_RESOURCE_TYPE_TEXTURE2D, FFX_RESOURCE_USAGE_UAV,
+        {FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_OPTICAL_FLOW_MOTION_VECTOR_FIELD_X,     "FI_OpticalFlowMotionVectorFieldX",        FFX_RESOURCE_TYPE_TEXTURE2D, FFX_RESOURCE_USAGE_UAV,
             FFX_SURFACE_FORMAT_R32_UINT, contextDescription->maxRenderSize.width, contextDescription->maxRenderSize.height, 1,      FFX_RESOURCE_FLAGS_ALIASABLE, {FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED}},
-        {FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_OPTICAL_FLOW_MOTION_VECTOR_FIELD_Y,     L"FI_OpticalFlowMotionVectorFieldY",        FFX_RESOURCE_TYPE_TEXTURE2D, FFX_RESOURCE_USAGE_UAV,
+        {FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_OPTICAL_FLOW_MOTION_VECTOR_FIELD_Y,     "FI_OpticalFlowMotionVectorFieldY",        FFX_RESOURCE_TYPE_TEXTURE2D, FFX_RESOURCE_USAGE_UAV,
             FFX_SURFACE_FORMAT_R32_UINT, contextDescription->maxRenderSize.width, contextDescription->maxRenderSize.height, 1,      FFX_RESOURCE_FLAGS_ALIASABLE, {FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED}},
-        {FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_PREVIOUS_INTERPOLATION_SOURCE,          L"FI_PreviousInterpolationSouce",           FFX_RESOURCE_TYPE_TEXTURE2D, FFX_RESOURCE_USAGE_UAV,
+        {FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_PREVIOUS_INTERPOLATION_SOURCE,          "FI_PreviousInterpolationSouce",           FFX_RESOURCE_TYPE_TEXTURE2D, FFX_RESOURCE_USAGE_UAV,
             contextDescription->previousInterpolationSourceFormat, contextDescription->displaySize.width, contextDescription->displaySize.height, 1, FFX_RESOURCE_FLAGS_NONE, {FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED}},
-        {FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_INPAINTING_MASK,                        L"FI_InpaintingMask",                       FFX_RESOURCE_TYPE_TEXTURE2D, FFX_RESOURCE_USAGE_UAV,
+        {FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_INPAINTING_MASK,                        "FI_InpaintingMask",                       FFX_RESOURCE_TYPE_TEXTURE2D, FFX_RESOURCE_USAGE_UAV,
             FFX_SURFACE_FORMAT_R8_UNORM, contextDescription->displaySize.width, contextDescription->displaySize.height, 1,          FFX_RESOURCE_FLAGS_ALIASABLE, {FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED}},
-        {FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_DISOCCLUSION_MASK,                      L"FI_DisocclusionMask",                     FFX_RESOURCE_TYPE_TEXTURE2D, FFX_RESOURCE_USAGE_UAV, 
+        {FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_DISOCCLUSION_MASK,                      "FI_DisocclusionMask",                     FFX_RESOURCE_TYPE_TEXTURE2D, FFX_RESOURCE_USAGE_UAV, 
             FFX_SURFACE_FORMAT_R8G8_UNORM, contextDescription->maxRenderSize.width, contextDescription->maxRenderSize.height, 1,    FFX_RESOURCE_FLAGS_ALIASABLE, {FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED}},
-        {FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_DEFAULT_DISTORTION_FIELD, L"FI_DefaultDistortionField", FFX_RESOURCE_TYPE_TEXTURE2D, FFX_RESOURCE_USAGE_READ_ONLY,
+        {FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_DEFAULT_DISTORTION_FIELD, "FI_DefaultDistortionField", FFX_RESOURCE_TYPE_TEXTURE2D, FFX_RESOURCE_USAGE_READ_ONLY,
             FFX_SURFACE_FORMAT_R8G8_UNORM, 1, 1, 1, FFX_RESOURCE_FLAGS_NONE, FfxResourceInitData::FfxResourceInitBuffer(sizeof(defaultDistortionFieldData), defaultDistortionFieldData) },
 
     };
@@ -577,7 +578,7 @@ static void scheduleDispatch(FfxFrameInterpolationContext_Private* context, cons
         const FfxResourceInternal currentResource = context->srvResources[currentResourceId];
         jobDescriptor.srvTextures[currentShaderResourceViewIndex].resource = currentResource;
 #ifdef FFX_DEBUG
-        wcscpy_s(jobDescriptor.srvTextures[currentShaderResourceViewIndex].name, pipeline->srvTextureBindings[currentShaderResourceViewIndex].name);
+        strcpy(jobDescriptor.srvTextures[currentShaderResourceViewIndex].name, pipeline->srvTextureBindings[currentShaderResourceViewIndex].name);
 #endif
     }
 
@@ -585,7 +586,7 @@ static void scheduleDispatch(FfxFrameInterpolationContext_Private* context, cons
 
         const uint32_t currentResourceId = pipeline->uavTextureBindings[currentUnorderedAccessViewIndex].resourceIdentifier;
 #ifdef FFX_DEBUG
-        wcscpy_s(jobDescriptor.uavTextures[currentUnorderedAccessViewIndex].name, pipeline->uavTextureBindings[currentUnorderedAccessViewIndex].name);
+        strcpy(jobDescriptor.uavTextures[currentUnorderedAccessViewIndex].name, pipeline->uavTextureBindings[currentUnorderedAccessViewIndex].name);
 #endif
 
         if (currentResourceId >= FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_INPAINTING_PYRAMID_MIPMAP_0 && currentResourceId <= FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_INPAINTING_PYRAMID_MIPMAP_12)
@@ -609,7 +610,7 @@ static void scheduleDispatch(FfxFrameInterpolationContext_Private* context, cons
 
     for (uint32_t currentRootConstantIndex = 0; currentRootConstantIndex < pipeline->constCount; ++currentRootConstantIndex) {
 #ifdef FFX_DEBUG
-        wcscpy_s(jobDescriptor.cbNames[currentRootConstantIndex], pipeline->constantBufferBindings[currentRootConstantIndex].name);
+        strcpy(jobDescriptor.cbNames[currentRootConstantIndex], pipeline->constantBufferBindings[currentRootConstantIndex].name);
 #endif
         jobDescriptor.cbs[currentRootConstantIndex] = context->constantBuffers[pipeline->constantBufferBindings[currentRootConstantIndex].resourceIdentifier];
     }
@@ -619,7 +620,7 @@ static void scheduleDispatch(FfxFrameInterpolationContext_Private* context, cons
         const uint32_t currentResourceId = pipeline->uavBufferBindings[currentUnorderedAccessViewIndex].resourceIdentifier;
         jobDescriptor.uavBuffers[currentUnorderedAccessViewIndex].resource = context->uavResources[currentResourceId];        
 #ifdef FFX_DEBUG
-        wcscpy_s(jobDescriptor.uavBuffers[currentUnorderedAccessViewIndex].name, pipeline->uavBufferBindings[currentUnorderedAccessViewIndex].name);
+        strcpy(jobDescriptor.uavBuffers[currentUnorderedAccessViewIndex].name, pipeline->uavBufferBindings[currentUnorderedAccessViewIndex].name);
 #endif
     }
 
@@ -628,12 +629,12 @@ static void scheduleDispatch(FfxFrameInterpolationContext_Private* context, cons
         const uint32_t currentResourceId = pipeline->srvBufferBindings[currentShaderResourceViewIndex].resourceIdentifier;
         jobDescriptor.srvBuffers[currentShaderResourceViewIndex].resource = context->srvResources[currentResourceId];
 #ifdef FFX_DEBUG
-        wcscpy_s(jobDescriptor.srvBuffers[currentShaderResourceViewIndex].name, pipeline->srvBufferBindings[currentShaderResourceViewIndex].name);
+        strcpy(jobDescriptor.srvBuffers[currentShaderResourceViewIndex].name, pipeline->srvBufferBindings[currentShaderResourceViewIndex].name);
 #endif
     }
 
     FfxGpuJobDescription dispatchJob = { FFX_GPU_JOB_COMPUTE };
-    wcscpy_s(dispatchJob.jobLabel, pipeline->name);
+    strcpy(dispatchJob.jobLabel, pipeline->name);
     dispatchJob.computeJobDescriptor = jobDescriptor;
 
     context->contextDescription.backendInterface.fpScheduleGpuJob(&context->contextDescription.backendInterface, &dispatchJob);
@@ -650,11 +651,11 @@ FFX_API FfxErrorCode ffxFrameInterpolationGetSharedResourceDescriptions(FfxFrame
 
     FfxFrameInterpolationContext_Private* contextPrivate = (FfxFrameInterpolationContext_Private*)(context);
     SharedResources->dilatedDepth = { FFX_HEAP_TYPE_DEFAULT, { FFX_RESOURCE_TYPE_TEXTURE2D, FFX_SURFACE_FORMAT_R32_FLOAT, contextPrivate->contextDescription.maxRenderSize.width, contextPrivate->contextDescription.maxRenderSize.height, 1, 1, FFX_RESOURCE_FLAGS_NONE, (FfxResourceUsage)(FFX_RESOURCE_USAGE_RENDERTARGET | FFX_RESOURCE_USAGE_UAV | FFX_RESOURCE_USAGE_DCC_RENDERTARGET) },
-        FFX_RESOURCE_STATE_UNORDERED_ACCESS, L"FISHARED_DilatedDepth", FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_DILATED_DEPTH, {FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED} };
+        FFX_RESOURCE_STATE_UNORDERED_ACCESS, "FISHARED_DilatedDepth", FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_DILATED_DEPTH, {FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED} };
     SharedResources->dilatedMotionVectors = { FFX_HEAP_TYPE_DEFAULT, { FFX_RESOURCE_TYPE_TEXTURE2D, FFX_SURFACE_FORMAT_R16G16_FLOAT, contextPrivate->contextDescription.maxRenderSize.width, contextPrivate->contextDescription.maxRenderSize.height, 1, 1, FFX_RESOURCE_FLAGS_NONE, (FfxResourceUsage)(FFX_RESOURCE_USAGE_RENDERTARGET | FFX_RESOURCE_USAGE_UAV | FFX_RESOURCE_USAGE_DCC_RENDERTARGET) },
-            FFX_RESOURCE_STATE_UNORDERED_ACCESS, L"FISHARED_DilatedVelocity", FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_DILATED_MOTION_VECTORS, {FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED} };
+            FFX_RESOURCE_STATE_UNORDERED_ACCESS, "FISHARED_DilatedVelocity", FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_DILATED_MOTION_VECTORS, {FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED} };
     SharedResources->reconstructedPrevNearestDepth = { FFX_HEAP_TYPE_DEFAULT, { FFX_RESOURCE_TYPE_TEXTURE2D, FFX_SURFACE_FORMAT_R32_UINT, contextPrivate->contextDescription.maxRenderSize.width, contextPrivate->contextDescription.maxRenderSize.height, 1, 1, FFX_RESOURCE_FLAGS_NONE, (FfxResourceUsage)(FFX_RESOURCE_USAGE_UAV) },
-            FFX_RESOURCE_STATE_UNORDERED_ACCESS, L"FISHARED_ReconstructedPrevNearestDepth", FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_RECONSTRUCTED_DEPTH_PREVIOUS_FRAME, {FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED} };
+            FFX_RESOURCE_STATE_UNORDERED_ACCESS, "FISHARED_ReconstructedPrevNearestDepth", FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_RECONSTRUCTED_DEPTH_PREVIOUS_FRAME, {FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED} };
 
     return FFX_OK;
 }
@@ -873,7 +874,7 @@ FFX_API FfxErrorCode ffxFrameInterpolationPrepare(FfxFrameInterpolationContext*
         const bool bInverted = (contextPrivate->contextDescription.flags & FFX_FRAMEINTERPOLATION_ENABLE_DEPTH_INVERTED) == FFX_FRAMEINTERPOLATION_ENABLE_DEPTH_INVERTED;
         const float clearDepthValue[]{bInverted ? 0.f : 1.f, bInverted ? 0.f : 1.f, bInverted ? 0.f : 1.f, bInverted ? 0.f : 1.f};
         memcpy(clearJob.clearJobDescriptor.color, clearDepthValue, 4 * sizeof(float));
-        wcscpy_s(clearJob.jobLabel, L"Clear Reconstructed Previous Nearest Depth");
+        strcpy(clearJob.jobLabel, "Clear Reconstructed Previous Nearest Depth");
         clearJob.clearJobDescriptor.target = contextPrivate->uavResources[FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_RECONSTRUCTED_DEPTH_PREVIOUS_FRAME];
         contextPrivate->contextDescription.backendInterface.fpScheduleGpuJob(&contextPrivate->contextDescription.backendInterface, &clearJob);
     }
@@ -1081,7 +1082,7 @@ FFX_API FfxErrorCode ffxFrameInterpolationDispatch(FfxFrameInterpolationContext*
             contextPrivate->uavResources[FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_INPAINTING_MASK],
             contextPrivate->uavResources[FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_DISOCCLUSION_MASK]
         };
-        for (int i = 0; i < _countof(aliasableResources); ++i)
+        for (int i = 0; i < std::size(aliasableResources); ++i)
         {
             FfxGpuJobDescription discardJob        = {FFX_GPU_JOB_DISCARD};
             discardJob.discardJobDescriptor.target = aliasableResources[i];
@@ -1127,7 +1128,7 @@ FFX_API FfxErrorCode ffxFrameInterpolationDispatch(FfxFrameInterpolationContext*
                 const float clearDepthValue[]{bInverted ? 0.f : 1.f, bInverted ? 0.f : 1.f, bInverted ? 0.f : 1.f, bInverted ? 0.f : 1.f};
                 memcpy(clearJob.clearJobDescriptor.color, clearDepthValue, 4 * sizeof(float));
 
-                wcscpy_s(clearJob.jobLabel, L"Clear Reconstructed Depth Interpolated Frame");
+                strcpy(clearJob.jobLabel, "Clear Reconstructed Depth Interpolated Frame");
                 clearJob.clearJobDescriptor.target =
                     contextPrivate->uavResources[FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_RECONSTRUCTED_DEPTH_INTERPOLATED_FRAME];
                 contextPrivate->contextDescription.backendInterface.fpScheduleGpuJob(&contextPrivate->contextDescription.backendInterface, &clearJob);
@@ -1180,10 +1181,10 @@ FFX_API FfxErrorCode ffxFrameInterpolationDispatch(FfxFrameInterpolationContext*
         // store current buffer
         {
             FfxGpuJobDescription copyJobs[] = { {FFX_GPU_JOB_COPY} };
-            FfxResourceInternal  copySources[_countof(copyJobs)] = { contextPrivate->srvResources[FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_CURRENT_INTERPOLATION_SOURCE] };
-            FfxResourceInternal destSources[_countof(copyJobs)] = { contextPrivate->uavResources[FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_PREVIOUS_INTERPOLATION_SOURCE] };
+            FfxResourceInternal  copySources[std::size(copyJobs)] = { contextPrivate->srvResources[FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_CURRENT_INTERPOLATION_SOURCE] };
+            FfxResourceInternal destSources[std::size(copyJobs)] = { contextPrivate->uavResources[FFX_FRAMEINTERPOLATION_RESOURCE_IDENTIFIER_PREVIOUS_INTERPOLATION_SOURCE] };
 
-            for (int i = 0; i < _countof(copyJobs); ++i)
+            for (int i = 0; i < std::size(copyJobs); ++i)
             {
                 copyJobs[i].copyJobDescriptor.src = copySources[i];
                 copyJobs[i].copyJobDescriptor.dst = destSources[i];
diff --git a/sdk/src/components/fsr1/CMakeLists.txt b/sdk/src/components/fsr1/CMakeLists.txt
index 823d3f7..5acd019 100644
--- a/sdk/src/components/fsr1/CMakeLists.txt
+++ b/sdk/src/components/fsr1/CMakeLists.txt
@@ -38,17 +38,17 @@ if (FFX_FSR1 OR FFX_ALL)
 	list(APPEND PUBLIC_SOURCES ${FFX_PUBLIC_SOURCES})
 
 	if (FFX_BUILD_AS_DLL)
-		add_library(ffx_fsr1_${FFX_PLATFORM_NAME} SHARED ${SHARED_SOURCES} ${PRIVATE_SOURCES} ${PUBLIC_SOURCES})
+		add_library(fsr1 SHARED ${SHARED_SOURCES} ${PRIVATE_SOURCES} ${PUBLIC_SOURCES})
 	else()
-		add_library(ffx_fsr1_${FFX_PLATFORM_NAME} STATIC ${SHARED_SOURCES} ${PRIVATE_SOURCES} ${PUBLIC_SOURCES})
+		add_library(fsr1 STATIC ${SHARED_SOURCES} ${PRIVATE_SOURCES} ${PUBLIC_SOURCES})
 	endif()
 
-	target_compile_definitions(ffx_fsr1_${FFX_PLATFORM_NAME} PRIVATE
+	target_compile_definitions(fsr1 PRIVATE
 		NOMINMAX
 		WIN32_LEAN_AND_MEAN)
 
 	if (MSVC)
-		target_compile_options(ffx_fsr1_${FFX_PLATFORM_NAME} PRIVATE
+		target_compile_options(fsr1 PRIVATE
 		"/W4" # warning level 4
 		"/WX" # warnings as errors
 		# disable MSVC warnings that are too strict
@@ -64,10 +64,17 @@ if (FFX_FSR1 OR FFX_ALL)
 	source_group("private_source" FILES ${PRIVATE_SOURCES})
 	source_group("public_source"  FILES ${PUBLIC_SOURCES})
 
-	target_include_directories(ffx_fsr1_${FFX_PLATFORM_NAME} PUBLIC ${FFX_INCLUDE_PATH})
-	target_include_directories(ffx_fsr1_${FFX_PLATFORM_NAME} PUBLIC ${FFX_SHARED_PATH})
+	target_include_directories(fsr1 PUBLIC
+		$<BUILD_INTERFACE:${FFX_INCLUDE_PATH}>
+		$<INSTALL_INTERFACE:include>)
+	target_include_directories(fsr1 PRIVATE ${FFX_SHARED_PATH})
 
 	set_source_files_properties(${SHADERS} PROPERTIES HEADER_FILE_ONLY TRUE)
-	set_target_properties(ffx_fsr1_${FFX_PLATFORM_NAME} PROPERTIES FOLDER Components)
+	set_target_properties(fsr1 PROPERTIES FOLDER Components)
+	
+	install(TARGETS fsr1 EXPORT fsr1-targets)
+	install(EXPORT fsr1-targets 
+		DESTINATION "${CMAKE_INSTALL_DATADIR}/cmake/${PROJECT_NAME}"
+		NAMESPACE fidelityfx::)
 	
 endif()
diff --git a/sdk/src/components/fsr1/ffx_fsr1.cpp b/sdk/src/components/fsr1/ffx_fsr1.cpp
index 14b306f..8c12b3b 100644
--- a/sdk/src/components/fsr1/ffx_fsr1.cpp
+++ b/sdk/src/components/fsr1/ffx_fsr1.cpp
@@ -21,7 +21,8 @@
 // THE SOFTWARE.
 
 #include <string.h>     // for memset
-#include <stdlib.h>     // for _countof
+#include <array>        // for std::size
+#include <stdlib.h>     // for std::size
 #include <cmath>        // for fabs, abs, sinf, sqrt, etc.
 
 #ifdef __clang__
@@ -44,26 +45,26 @@
 typedef struct ResourceBinding
 {
     uint32_t    index;
-    wchar_t     name[64];
+    char        name[64];
 }ResourceBinding;
 
 static const ResourceBinding srvTextureBindingTable[] =
 {
-    {FFX_FSR1_RESOURCE_IDENTIFIER_INPUT_COLOR,                  L"r_input_color"},
-    {FFX_FSR1_RESOURCE_IDENTIFIER_INTERNAL_UPSCALED_COLOR,      L"r_internal_upscaled_color"},
-    {FFX_FSR1_RESOURCE_IDENTIFIER_UPSCALED_OUTPUT,              L"r_upscaled_output" },
+    {FFX_FSR1_RESOURCE_IDENTIFIER_INPUT_COLOR,                  "r_input_color"},
+    {FFX_FSR1_RESOURCE_IDENTIFIER_INTERNAL_UPSCALED_COLOR,      "r_internal_upscaled_color"},
+    {FFX_FSR1_RESOURCE_IDENTIFIER_UPSCALED_OUTPUT,              "r_upscaled_output" },
 };
 
 static const ResourceBinding uavTextureBindingTable[] =
 {
-    {FFX_FSR1_RESOURCE_IDENTIFIER_INPUT_COLOR,                  L"rw_input_color"},
-    {FFX_FSR1_RESOURCE_IDENTIFIER_INTERNAL_UPSCALED_COLOR,      L"rw_internal_upscaled_color"},
-    {FFX_FSR1_RESOURCE_IDENTIFIER_UPSCALED_OUTPUT,              L"rw_upscaled_output"},
+    {FFX_FSR1_RESOURCE_IDENTIFIER_INPUT_COLOR,                  "rw_input_color"},
+    {FFX_FSR1_RESOURCE_IDENTIFIER_INTERNAL_UPSCALED_COLOR,      "rw_internal_upscaled_color"},
+    {FFX_FSR1_RESOURCE_IDENTIFIER_UPSCALED_OUTPUT,              "rw_upscaled_output"},
 };
 
 static const ResourceBinding cbResourceBindingTable[] =
 {
-    {FFX_FSR1_CONSTANTBUFFER_IDENTIFIER_FSR1,                   L"cbFSR1"},
+    {FFX_FSR1_CONSTANTBUFFER_IDENTIFIER_FSR1,                   "cbFSR1"},
 };
 
 static FfxErrorCode patchResourceBindings(FfxPipelineState* inoutPipeline)
@@ -71,12 +72,12 @@ static FfxErrorCode patchResourceBindings(FfxPipelineState* inoutPipeline)
     for (uint32_t srvIndex = 0; srvIndex < inoutPipeline->srvTextureCount; ++srvIndex)
     {
         int32_t mapIndex = 0;
-        for (mapIndex = 0; mapIndex < _countof(srvTextureBindingTable); ++mapIndex)
+        for (mapIndex = 0; mapIndex < std::size(srvTextureBindingTable); ++mapIndex)
         {
-            if (0 == wcscmp(srvTextureBindingTable[mapIndex].name, inoutPipeline->srvTextureBindings[srvIndex].name))
+            if (0 == strcmp(srvTextureBindingTable[mapIndex].name, inoutPipeline->srvTextureBindings[srvIndex].name))
                 break;
         }
-        if (mapIndex == _countof(srvTextureBindingTable))
+        if (mapIndex == std::size(srvTextureBindingTable))
             return FFX_ERROR_INVALID_ARGUMENT;
 
         inoutPipeline->srvTextureBindings[srvIndex].resourceIdentifier = srvTextureBindingTable[mapIndex].index;
@@ -85,12 +86,12 @@ static FfxErrorCode patchResourceBindings(FfxPipelineState* inoutPipeline)
     for (uint32_t uavIndex = 0; uavIndex < inoutPipeline->uavTextureCount; ++uavIndex)
     {
         int32_t mapIndex = 0;
-        for (mapIndex = 0; mapIndex < _countof(uavTextureBindingTable); ++mapIndex)
+        for (mapIndex = 0; mapIndex < std::size(uavTextureBindingTable); ++mapIndex)
         {
-            if (0 == wcscmp(uavTextureBindingTable[mapIndex].name, inoutPipeline->uavTextureBindings[uavIndex].name))
+            if (0 == strcmp(uavTextureBindingTable[mapIndex].name, inoutPipeline->uavTextureBindings[uavIndex].name))
                 break;
         }
-        if (mapIndex == _countof(uavTextureBindingTable))
+        if (mapIndex == std::size(uavTextureBindingTable))
             return FFX_ERROR_INVALID_ARGUMENT;
 
         inoutPipeline->uavTextureBindings[uavIndex].resourceIdentifier = uavTextureBindingTable[mapIndex].index;
@@ -99,12 +100,12 @@ static FfxErrorCode patchResourceBindings(FfxPipelineState* inoutPipeline)
     for (uint32_t cbIndex = 0; cbIndex < inoutPipeline->constCount; ++cbIndex)
     {
         int32_t mapIndex = 0;
-        for (mapIndex = 0; mapIndex < _countof(cbResourceBindingTable); ++mapIndex)
+        for (mapIndex = 0; mapIndex < std::size(cbResourceBindingTable); ++mapIndex)
         {
-            if (0 == wcscmp(cbResourceBindingTable[mapIndex].name, inoutPipeline->constantBufferBindings[cbIndex].name))
+            if (0 == strcmp(cbResourceBindingTable[mapIndex].name, inoutPipeline->constantBufferBindings[cbIndex].name))
                 break;
         }
-        if (mapIndex == _countof(cbResourceBindingTable))
+        if (mapIndex == std::size(cbResourceBindingTable))
             return FFX_ERROR_INVALID_ARGUMENT;
 
         inoutPipeline->constantBufferBindings[cbIndex].resourceIdentifier = cbResourceBindingTable[mapIndex].index;
@@ -168,15 +169,15 @@ static FfxErrorCode createPipelineStates(FfxFsr1Context_Private* context)
     uint32_t contextFlags = context->contextDescription.flags;
 
     // Set up pipeline descriptors (basically RootSignature and binding)
-    wcscpy_s(pipelineDescription.name, L"FSR1-EASU");
+    strcpy(pipelineDescription.name, "FSR1-EASU");
     FFX_VALIDATE(context->contextDescription.backendInterface.fpCreatePipeline(&context->contextDescription.backendInterface, FFX_EFFECT_FSR1, FFX_FSR1_PASS_EASU,
         getPipelinePermutationFlags(contextFlags, FFX_FSR1_PASS_EASU, supportedFP16, canForceWave64),
         &pipelineDescription, context->effectContextId, &context->pipelineEASU));
-    wcscpy_s(pipelineDescription.name, L"FSR1-EASU_RCAS");
+    strcpy(pipelineDescription.name, "FSR1-EASU_RCAS");
     FFX_VALIDATE(context->contextDescription.backendInterface.fpCreatePipeline(&context->contextDescription.backendInterface, FFX_EFFECT_FSR1, FFX_FSR1_PASS_EASU_RCAS,
         getPipelinePermutationFlags(contextFlags, FFX_FSR1_PASS_EASU_RCAS, supportedFP16, canForceWave64),
         &pipelineDescription, context->effectContextId, &context->pipelineEASU_RCAS));
-    wcscpy_s(pipelineDescription.name, L"FSR1-RCAS");
+    strcpy(pipelineDescription.name, "FSR1-RCAS");
     FFX_VALIDATE(context->contextDescription.backendInterface.fpCreatePipeline(&context->contextDescription.backendInterface, FFX_EFFECT_FSR1, FFX_FSR1_PASS_RCAS,
         getPipelinePermutationFlags(contextFlags, FFX_FSR1_PASS_RCAS, supportedFP16, canForceWave64),
         &pipelineDescription, context->effectContextId, &context->pipelineRCAS));
@@ -192,7 +193,7 @@ static FfxErrorCode createPipelineStates(FfxFsr1Context_Private* context)
 static void scheduleDispatch(FfxFsr1Context_Private* context, const FfxFsr1DispatchDescription*, const FfxPipelineState* pipeline, uint32_t dispatchX, uint32_t dispatchY)
 {
     FfxGpuJobDescription dispatchJob = {FFX_GPU_JOB_COMPUTE};
-    wcscpy_s(dispatchJob.jobLabel, pipeline->name);
+    strcpy(dispatchJob.jobLabel, pipeline->name);
 
     for (uint32_t currentShaderResourceViewIndex = 0; currentShaderResourceViewIndex < pipeline->srvTextureCount; ++currentShaderResourceViewIndex) {
 
@@ -200,7 +201,7 @@ static void scheduleDispatch(FfxFsr1Context_Private* context, const FfxFsr1Dispa
         const FfxResourceInternal currentResource = context->srvResources[currentResourceId];
         dispatchJob.computeJobDescriptor.srvTextures[currentShaderResourceViewIndex].resource = currentResource;
 #ifdef FFX_DEBUG
-        wcscpy_s(dispatchJob.computeJobDescriptor.srvTextures[currentShaderResourceViewIndex].name,
+        strcpy(dispatchJob.computeJobDescriptor.srvTextures[currentShaderResourceViewIndex].name,
                  pipeline->srvTextureBindings[currentShaderResourceViewIndex].name);
 #endif
     }
@@ -209,7 +210,7 @@ static void scheduleDispatch(FfxFsr1Context_Private* context, const FfxFsr1Dispa
 
         const uint32_t currentResourceId = pipeline->uavTextureBindings[currentUnorderedAccessViewIndex].resourceIdentifier;
 #ifdef FFX_DEBUG
-        wcscpy_s(dispatchJob.computeJobDescriptor.uavTextures[currentUnorderedAccessViewIndex].name,
+        strcpy(dispatchJob.computeJobDescriptor.uavTextures[currentUnorderedAccessViewIndex].name,
                  pipeline->uavTextureBindings[currentUnorderedAccessViewIndex].name);
 #endif
         const FfxResourceInternal currentResource                       = context->uavResources[currentResourceId];
@@ -223,7 +224,7 @@ static void scheduleDispatch(FfxFsr1Context_Private* context, const FfxFsr1Dispa
     dispatchJob.computeJobDescriptor.pipeline      = *pipeline;
 
 #ifdef FFX_DEBUG
-    wcscpy_s(dispatchJob.computeJobDescriptor.cbNames[0], pipeline->constantBufferBindings[0].name);
+    strcpy(dispatchJob.computeJobDescriptor.cbNames[0], pipeline->constantBufferBindings[0].name);
 #endif
     dispatchJob.computeJobDescriptor.cbs[0] = context->constantBuffer;
 
@@ -318,7 +319,7 @@ static FfxErrorCode fsr1Create(FfxFsr1Context_Private* context, const FfxFsr1Con
 
     // Create the intermediate upscale resource if RCAS is enabled
     const FfxInternalResourceDescription internalSurfaceDesc = {FFX_FSR1_RESOURCE_IDENTIFIER_INTERNAL_UPSCALED_COLOR,
-                                                                L"FSR1_InternalUpscaledColor",
+                                                                "FSR1_InternalUpscaledColor",
                                                                 FFX_RESOURCE_TYPE_TEXTURE2D,
                                                                 FFX_RESOURCE_USAGE_UAV,
                                                                 contextDescription->outputFormat,
diff --git a/sdk/src/components/fsr2/CMakeLists.txt b/sdk/src/components/fsr2/CMakeLists.txt
index 11b20a7..8fb26fc 100644
--- a/sdk/src/components/fsr2/CMakeLists.txt
+++ b/sdk/src/components/fsr2/CMakeLists.txt
@@ -38,17 +38,17 @@ if (FFX_FSR2 OR FFX_ALL)
 	list(APPEND PUBLIC_SOURCES ${FFX_PUBLIC_SOURCES})
 
 	if (FFX_BUILD_AS_DLL)
-		add_library(ffx_fsr2_${FFX_PLATFORM_NAME} SHARED ${SHARED_SOURCES} ${PRIVATE_SOURCES} ${PUBLIC_SOURCES})
+		add_library(fsr2 SHARED ${SHARED_SOURCES} ${PRIVATE_SOURCES} ${PUBLIC_SOURCES})
 	else()
-		add_library(ffx_fsr2_${FFX_PLATFORM_NAME} STATIC ${SHARED_SOURCES} ${PRIVATE_SOURCES} ${PUBLIC_SOURCES})
+		add_library(fsr2 STATIC ${SHARED_SOURCES} ${PRIVATE_SOURCES} ${PUBLIC_SOURCES})
 	endif()
 
-	target_compile_definitions(ffx_fsr2_${FFX_PLATFORM_NAME} PRIVATE
+	target_compile_definitions(fsr2 PRIVATE
 		NOMINMAX
 		WIN32_LEAN_AND_MEAN)
 
 	if (MSVC)
-		target_compile_options(ffx_fsr2_${FFX_PLATFORM_NAME} PRIVATE
+		target_compile_options(fsr2 PRIVATE
 		"/W4" # warning level 4
 		"/WX" # warnings as errors
 		# disable MSVC warnings that are too strict
@@ -64,10 +64,17 @@ if (FFX_FSR2 OR FFX_ALL)
 	source_group("private_source" FILES ${PRIVATE_SOURCES})
 	source_group("public_source"  FILES ${PUBLIC_SOURCES})
 
-	target_include_directories(ffx_fsr2_${FFX_PLATFORM_NAME} PUBLIC ${FFX_INCLUDE_PATH})
-	target_include_directories(ffx_fsr2_${FFX_PLATFORM_NAME} PUBLIC ${FFX_SHARED_PATH})
+	target_include_directories(fsr2 PUBLIC
+		$<BUILD_INTERFACE:${FFX_INCLUDE_PATH}>
+		$<INSTALL_INTERFACE:include>)
+	target_include_directories(fsr2 PRIVATE ${FFX_SHARED_PATH})
 
 	set_source_files_properties(${SHADERS} PROPERTIES HEADER_FILE_ONLY TRUE)
-	set_target_properties(ffx_fsr2_${FFX_PLATFORM_NAME} PROPERTIES FOLDER Components)
+	set_target_properties(fsr2 PROPERTIES FOLDER Components)
+	
+	install(TARGETS fsr2 EXPORT fsr2-targets)
+	install(EXPORT fsr2-targets 
+		DESTINATION "${CMAKE_INSTALL_DATADIR}/cmake/${PROJECT_NAME}"
+		NAMESPACE fidelityfx::)
 	
 endif()
diff --git a/sdk/src/components/fsr2/ffx_fsr2.cpp b/sdk/src/components/fsr2/ffx_fsr2.cpp
index c27f2f6..3863208 100644
--- a/sdk/src/components/fsr2/ffx_fsr2.cpp
+++ b/sdk/src/components/fsr2/ffx_fsr2.cpp
@@ -21,6 +21,7 @@
 // THE SOFTWARE.
 
 #include <algorithm>    // for max used inside SPD CPU code.
+#include <array>        // for std::size
 #include <cmath>        // for fabs, abs, sinf, sqrt, etc.
 #include <string.h>     // for memset
 #include <cfloat>       // for FLT_EPSILON
@@ -54,69 +55,69 @@ static const uint32_t FSR2_MAX_QUEUED_FRAMES = 16;
 typedef struct ResourceBinding
 {
     uint32_t    index;
-    wchar_t     name[64];
+    char        name[64];
 }ResourceBinding;
 
 static const ResourceBinding srvTextureBindingTable[] =
 {
-    {FFX_FSR2_RESOURCE_IDENTIFIER_INPUT_COLOR,                              L"r_input_color_jittered"},
-    {FFX_FSR2_RESOURCE_IDENTIFIER_INPUT_OPAQUE_ONLY,                        L"r_input_opaque_only"},
-    {FFX_FSR2_RESOURCE_IDENTIFIER_INPUT_MOTION_VECTORS,                     L"r_input_motion_vectors"},
-    {FFX_FSR2_RESOURCE_IDENTIFIER_INPUT_DEPTH,                              L"r_input_depth" },
-    {FFX_FSR2_RESOURCE_IDENTIFIER_INPUT_EXPOSURE,                           L"r_input_exposure"},
-    {FFX_FSR2_RESOURCE_IDENTIFIER_AUTO_EXPOSURE,                            L"r_auto_exposure"},
-    {FFX_FSR2_RESOURCE_IDENTIFIER_INPUT_REACTIVE_MASK,                      L"r_reactive_mask"},
-    {FFX_FSR2_RESOURCE_IDENTIFIER_INPUT_TRANSPARENCY_AND_COMPOSITION_MASK,  L"r_transparency_and_composition_mask"},
-    {FFX_FSR2_RESOURCE_IDENTIFIER_RECONSTRUCTED_PREVIOUS_NEAREST_DEPTH,     L"r_reconstructed_previous_nearest_depth"},
-    {FFX_FSR2_RESOURCE_IDENTIFIER_DILATED_MOTION_VECTORS,                   L"r_dilated_motion_vectors"},
-    {FFX_FSR2_RESOURCE_IDENTIFIER_PREVIOUS_DILATED_MOTION_VECTORS,          L"r_previous_dilated_motion_vectors"},
-    {FFX_FSR2_RESOURCE_IDENTIFIER_DILATED_DEPTH,                            L"r_dilatedDepth"},
-    {FFX_FSR2_RESOURCE_IDENTIFIER_INTERNAL_UPSCALED_COLOR,                  L"r_internal_upscaled_color"},
-    {FFX_FSR2_RESOURCE_IDENTIFIER_LOCK_STATUS,                              L"r_lock_status"},
-    {FFX_FSR2_RESOURCE_IDENTIFIER_PREPARED_INPUT_COLOR,                     L"r_prepared_input_color"},
-    {FFX_FSR2_RESOURCE_IDENTIFIER_LUMA_HISTORY,                             L"r_luma_history" },
-    {FFX_FSR2_RESOURCE_IDENTIFIER_RCAS_INPUT,                               L"r_rcas_input"},
-    {FFX_FSR2_RESOURCE_IDENTIFIER_LANCZOS_LUT,                              L"r_lanczos_lut"},
-    {FFX_FSR2_RESOURCE_IDENTIFIER_SCENE_LUMINANCE,                          L"r_imgMips"},
-    {FFX_FSR2_RESOURCE_IDENTIFIER_SCENE_LUMINANCE_MIPMAP_SHADING_CHANGE,    L"r_img_mip_shading_change"},
-    {FFX_FSR2_RESOURCE_IDENTIFIER_SCENE_LUMINANCE_MIPMAP_5,                 L"r_img_mip_5"},
-    {FFX_FSR2_RESOURCE_IDENTITIER_UPSAMPLE_MAXIMUM_BIAS_LUT,                L"r_upsample_maximum_bias_lut"},
-    {FFX_FSR2_RESOURCE_IDENTIFIER_DILATED_REACTIVE_MASKS,                   L"r_dilated_reactive_masks"},
-    {FFX_FSR2_RESOURCE_IDENTIFIER_NEW_LOCKS,                                L"r_new_locks"},
-    {FFX_FSR2_RESOURCE_IDENTIFIER_LOCK_INPUT_LUMA,                          L"r_lock_input_luma"},
-    {FFX_FSR2_RESOURCE_IDENTIFIER_PREV_PRE_ALPHA_COLOR,                     L"r_input_prev_color_pre_alpha"},
-    {FFX_FSR2_RESOURCE_IDENTIFIER_PREV_POST_ALPHA_COLOR,                    L"r_input_prev_color_post_alpha"},
+    {FFX_FSR2_RESOURCE_IDENTIFIER_INPUT_COLOR,                              "r_input_color_jittered"},
+    {FFX_FSR2_RESOURCE_IDENTIFIER_INPUT_OPAQUE_ONLY,                        "r_input_opaque_only"},
+    {FFX_FSR2_RESOURCE_IDENTIFIER_INPUT_MOTION_VECTORS,                     "r_input_motion_vectors"},
+    {FFX_FSR2_RESOURCE_IDENTIFIER_INPUT_DEPTH,                              "r_input_depth" },
+    {FFX_FSR2_RESOURCE_IDENTIFIER_INPUT_EXPOSURE,                           "r_input_exposure"},
+    {FFX_FSR2_RESOURCE_IDENTIFIER_AUTO_EXPOSURE,                            "r_auto_exposure"},
+    {FFX_FSR2_RESOURCE_IDENTIFIER_INPUT_REACTIVE_MASK,                      "r_reactive_mask"},
+    {FFX_FSR2_RESOURCE_IDENTIFIER_INPUT_TRANSPARENCY_AND_COMPOSITION_MASK,  "r_transparency_and_composition_mask"},
+    {FFX_FSR2_RESOURCE_IDENTIFIER_RECONSTRUCTED_PREVIOUS_NEAREST_DEPTH,     "r_reconstructed_previous_nearest_depth"},
+    {FFX_FSR2_RESOURCE_IDENTIFIER_DILATED_MOTION_VECTORS,                   "r_dilated_motion_vectors"},
+    {FFX_FSR2_RESOURCE_IDENTIFIER_PREVIOUS_DILATED_MOTION_VECTORS,          "r_previous_dilated_motion_vectors"},
+    {FFX_FSR2_RESOURCE_IDENTIFIER_DILATED_DEPTH,                            "r_dilatedDepth"},
+    {FFX_FSR2_RESOURCE_IDENTIFIER_INTERNAL_UPSCALED_COLOR,                  "r_internal_upscaled_color"},
+    {FFX_FSR2_RESOURCE_IDENTIFIER_LOCK_STATUS,                              "r_lock_status"},
+    {FFX_FSR2_RESOURCE_IDENTIFIER_PREPARED_INPUT_COLOR,                     "r_prepared_input_color"},
+    {FFX_FSR2_RESOURCE_IDENTIFIER_LUMA_HISTORY,                             "r_luma_history" },
+    {FFX_FSR2_RESOURCE_IDENTIFIER_RCAS_INPUT,                               "r_rcas_input"},
+    {FFX_FSR2_RESOURCE_IDENTIFIER_LANCZOS_LUT,                              "r_lanczos_lut"},
+    {FFX_FSR2_RESOURCE_IDENTIFIER_SCENE_LUMINANCE,                          "r_imgMips"},
+    {FFX_FSR2_RESOURCE_IDENTIFIER_SCENE_LUMINANCE_MIPMAP_SHADING_CHANGE,    "r_img_mip_shading_change"},
+    {FFX_FSR2_RESOURCE_IDENTIFIER_SCENE_LUMINANCE_MIPMAP_5,                 "r_img_mip_5"},
+    {FFX_FSR2_RESOURCE_IDENTITIER_UPSAMPLE_MAXIMUM_BIAS_LUT,                "r_upsample_maximum_bias_lut"},
+    {FFX_FSR2_RESOURCE_IDENTIFIER_DILATED_REACTIVE_MASKS,                   "r_dilated_reactive_masks"},
+    {FFX_FSR2_RESOURCE_IDENTIFIER_NEW_LOCKS,                                "r_new_locks"},
+    {FFX_FSR2_RESOURCE_IDENTIFIER_LOCK_INPUT_LUMA,                          "r_lock_input_luma"},
+    {FFX_FSR2_RESOURCE_IDENTIFIER_PREV_PRE_ALPHA_COLOR,                     "r_input_prev_color_pre_alpha"},
+    {FFX_FSR2_RESOURCE_IDENTIFIER_PREV_POST_ALPHA_COLOR,                    "r_input_prev_color_post_alpha"},
 };
 
 static const ResourceBinding uavTextureBindingTable[] =
 {
-    {FFX_FSR2_RESOURCE_IDENTIFIER_RECONSTRUCTED_PREVIOUS_NEAREST_DEPTH,    L"rw_reconstructed_previous_nearest_depth"},
-    {FFX_FSR2_RESOURCE_IDENTIFIER_DILATED_MOTION_VECTORS,                  L"rw_dilated_motion_vectors"},
-    {FFX_FSR2_RESOURCE_IDENTIFIER_DILATED_DEPTH,                           L"rw_dilatedDepth"},
-    {FFX_FSR2_RESOURCE_IDENTIFIER_INTERNAL_UPSCALED_COLOR,                 L"rw_internal_upscaled_color"},
-    {FFX_FSR2_RESOURCE_IDENTIFIER_LOCK_STATUS,                             L"rw_lock_status"},
-    {FFX_FSR2_RESOURCE_IDENTIFIER_PREPARED_INPUT_COLOR,                    L"rw_prepared_input_color"},
-    {FFX_FSR2_RESOURCE_IDENTIFIER_LUMA_HISTORY,                            L"rw_luma_history"},
-    {FFX_FSR2_RESOURCE_IDENTIFIER_UPSCALED_OUTPUT,                         L"rw_upscaled_output"},
-    {FFX_FSR2_RESOURCE_IDENTIFIER_SCENE_LUMINANCE_MIPMAP_SHADING_CHANGE,   L"rw_img_mip_shading_change"},
-    {FFX_FSR2_RESOURCE_IDENTIFIER_SCENE_LUMINANCE_MIPMAP_5,                L"rw_img_mip_5"},
-    {FFX_FSR2_RESOURCE_IDENTIFIER_DILATED_REACTIVE_MASKS,                  L"rw_dilated_reactive_masks"},
-    {FFX_FSR2_RESOURCE_IDENTIFIER_AUTO_EXPOSURE,                           L"rw_auto_exposure"},
-    {FFX_FSR2_RESOURCE_IDENTIFIER_SPD_ATOMIC_COUNT,                        L"rw_spd_global_atomic"},
-    {FFX_FSR2_RESOURCE_IDENTIFIER_NEW_LOCKS,                               L"rw_new_locks"},
-    {FFX_FSR2_RESOURCE_IDENTIFIER_LOCK_INPUT_LUMA,                         L"rw_lock_input_luma"},
-    {FFX_FSR2_RESOURCE_IDENTIFIER_AUTOREACTIVE,                            L"rw_output_autoreactive"},
-    {FFX_FSR2_RESOURCE_IDENTIFIER_AUTOCOMPOSITION,                         L"rw_output_autocomposition"},
-    {FFX_FSR2_RESOURCE_IDENTIFIER_PREV_PRE_ALPHA_COLOR,                    L"rw_output_prev_color_pre_alpha"},
-    {FFX_FSR2_RESOURCE_IDENTIFIER_PREV_POST_ALPHA_COLOR,                   L"rw_output_prev_color_post_alpha"},
+    {FFX_FSR2_RESOURCE_IDENTIFIER_RECONSTRUCTED_PREVIOUS_NEAREST_DEPTH,    "rw_reconstructed_previous_nearest_depth"},
+    {FFX_FSR2_RESOURCE_IDENTIFIER_DILATED_MOTION_VECTORS,                  "rw_dilated_motion_vectors"},
+    {FFX_FSR2_RESOURCE_IDENTIFIER_DILATED_DEPTH,                           "rw_dilatedDepth"},
+    {FFX_FSR2_RESOURCE_IDENTIFIER_INTERNAL_UPSCALED_COLOR,                 "rw_internal_upscaled_color"},
+    {FFX_FSR2_RESOURCE_IDENTIFIER_LOCK_STATUS,                             "rw_lock_status"},
+    {FFX_FSR2_RESOURCE_IDENTIFIER_PREPARED_INPUT_COLOR,                    "rw_prepared_input_color"},
+    {FFX_FSR2_RESOURCE_IDENTIFIER_LUMA_HISTORY,                            "rw_luma_history"},
+    {FFX_FSR2_RESOURCE_IDENTIFIER_UPSCALED_OUTPUT,                         "rw_upscaled_output"},
+    {FFX_FSR2_RESOURCE_IDENTIFIER_SCENE_LUMINANCE_MIPMAP_SHADING_CHANGE,   "rw_img_mip_shading_change"},
+    {FFX_FSR2_RESOURCE_IDENTIFIER_SCENE_LUMINANCE_MIPMAP_5,                "rw_img_mip_5"},
+    {FFX_FSR2_RESOURCE_IDENTIFIER_DILATED_REACTIVE_MASKS,                  "rw_dilated_reactive_masks"},
+    {FFX_FSR2_RESOURCE_IDENTIFIER_AUTO_EXPOSURE,                           "rw_auto_exposure"},
+    {FFX_FSR2_RESOURCE_IDENTIFIER_SPD_ATOMIC_COUNT,                        "rw_spd_global_atomic"},
+    {FFX_FSR2_RESOURCE_IDENTIFIER_NEW_LOCKS,                               "rw_new_locks"},
+    {FFX_FSR2_RESOURCE_IDENTIFIER_LOCK_INPUT_LUMA,                         "rw_lock_input_luma"},
+    {FFX_FSR2_RESOURCE_IDENTIFIER_AUTOREACTIVE,                            "rw_output_autoreactive"},
+    {FFX_FSR2_RESOURCE_IDENTIFIER_AUTOCOMPOSITION,                         "rw_output_autocomposition"},
+    {FFX_FSR2_RESOURCE_IDENTIFIER_PREV_PRE_ALPHA_COLOR,                    "rw_output_prev_color_pre_alpha"},
+    {FFX_FSR2_RESOURCE_IDENTIFIER_PREV_POST_ALPHA_COLOR,                   "rw_output_prev_color_post_alpha"},
 };
 
 static const ResourceBinding constantBufferBindingTable[] =
 {
-    {FFX_FSR2_CONSTANTBUFFER_IDENTIFIER_FSR2,           L"cbFSR2"},
-    {FFX_FSR2_CONSTANTBUFFER_IDENTIFIER_SPD,            L"cbSPD"},
-    {FFX_FSR2_CONSTANTBUFFER_IDENTIFIER_RCAS,           L"cbRCAS"},
-    {FFX_FSR2_CONSTANTBUFFER_IDENTIFIER_GENREACTIVE,    L"cbGenerateReactive"},
+    {FFX_FSR2_CONSTANTBUFFER_IDENTIFIER_FSR2,           "cbFSR2"},
+    {FFX_FSR2_CONSTANTBUFFER_IDENTIFIER_SPD,            "cbSPD"},
+    {FFX_FSR2_CONSTANTBUFFER_IDENTIFIER_RCAS,           "cbRCAS"},
+    {FFX_FSR2_CONSTANTBUFFER_IDENTIFIER_GENREACTIVE,    "cbGenerateReactive"},
 };
 
 // Broad structure of the root signature.
@@ -192,77 +193,77 @@ static void fsr2DebugCheckDispatch(FfxFsr2Context_Private* context, const FfxFsr
 {
     if (params->commandList == nullptr)
     {
-        context->contextDescription.fpMessage(FFX_MESSAGE_TYPE_ERROR, L"commandList is null");
+        context->contextDescription.fpMessage(FFX_MESSAGE_TYPE_ERROR, "commandList is null");
     }
 
     if (params->color.resource == nullptr)
     {
-        context->contextDescription.fpMessage(FFX_MESSAGE_TYPE_ERROR, L"color resource is null");
+        context->contextDescription.fpMessage(FFX_MESSAGE_TYPE_ERROR, "color resource is null");
     }
 
     if (params->depth.resource == nullptr)
     {
-        context->contextDescription.fpMessage(FFX_MESSAGE_TYPE_ERROR, L"depth resource is null");
+        context->contextDescription.fpMessage(FFX_MESSAGE_TYPE_ERROR, "depth resource is null");
     }
 
     if (params->motionVectors.resource == nullptr)
     {
-        context->contextDescription.fpMessage(FFX_MESSAGE_TYPE_ERROR, L"motionVectors resource is null");
+        context->contextDescription.fpMessage(FFX_MESSAGE_TYPE_ERROR, "motionVectors resource is null");
     }
 
     if (params->exposure.resource != nullptr)
     {
         if ((context->contextDescription.flags & FFX_FSR2_ENABLE_AUTO_EXPOSURE) == FFX_FSR2_ENABLE_AUTO_EXPOSURE)
         {
-            context->contextDescription.fpMessage(FFX_MESSAGE_TYPE_WARNING, L"exposure resource provided, however auto exposure flag is present");
+            context->contextDescription.fpMessage(FFX_MESSAGE_TYPE_WARNING, "exposure resource provided, however auto exposure flag is present");
         }
     }
 
     if (params->output.resource == nullptr)
     {
-        context->contextDescription.fpMessage(FFX_MESSAGE_TYPE_ERROR, L"output resource is null");
+        context->contextDescription.fpMessage(FFX_MESSAGE_TYPE_ERROR, "output resource is null");
     }
 
     if (fabs(params->jitterOffset.x) > 1.0f || fabs(params->jitterOffset.y) > 1.0f)
     {
-        context->contextDescription.fpMessage(FFX_MESSAGE_TYPE_WARNING, L"jitterOffset contains value outside of expected range [-1.0, 1.0]");
+        context->contextDescription.fpMessage(FFX_MESSAGE_TYPE_WARNING, "jitterOffset contains value outside of expected range [-1.0, 1.0]");
     }
 
     if ((params->motionVectorScale.x > (float)context->contextDescription.maxRenderSize.width) ||
         (params->motionVectorScale.y > (float)context->contextDescription.maxRenderSize.height))
     {
-        context->contextDescription.fpMessage(FFX_MESSAGE_TYPE_WARNING, L"motionVectorScale contains scale value greater than maxRenderSize");
+        context->contextDescription.fpMessage(FFX_MESSAGE_TYPE_WARNING, "motionVectorScale contains scale value greater than maxRenderSize");
     }
     if ((params->motionVectorScale.x == 0.0f) ||
         (params->motionVectorScale.y == 0.0f))
     {
-        context->contextDescription.fpMessage(FFX_MESSAGE_TYPE_WARNING, L"motionVectorScale contains zero scale value");
+        context->contextDescription.fpMessage(FFX_MESSAGE_TYPE_WARNING, "motionVectorScale contains zero scale value");
     }
 
     if ((params->renderSize.width > context->contextDescription.maxRenderSize.width) ||
         (params->renderSize.height > context->contextDescription.maxRenderSize.height))
     {
-        context->contextDescription.fpMessage(FFX_MESSAGE_TYPE_WARNING, L"renderSize is greater than context maxRenderSize");
+        context->contextDescription.fpMessage(FFX_MESSAGE_TYPE_WARNING, "renderSize is greater than context maxRenderSize");
     }
     if ((params->renderSize.width == 0) ||
         (params->renderSize.height == 0))
     {
-        context->contextDescription.fpMessage(FFX_MESSAGE_TYPE_WARNING, L"renderSize contains zero dimension");
+        context->contextDescription.fpMessage(FFX_MESSAGE_TYPE_WARNING, "renderSize contains zero dimension");
     }
 
     if (params->sharpness < 0.0f || params->sharpness > 1.0f)
     {
-        context->contextDescription.fpMessage(FFX_MESSAGE_TYPE_WARNING, L"sharpness contains value outside of expected range [0.0, 1.0]");
+        context->contextDescription.fpMessage(FFX_MESSAGE_TYPE_WARNING, "sharpness contains value outside of expected range [0.0, 1.0]");
     }
 
     if (params->frameTimeDelta < 1.0f)
     {
-        context->contextDescription.fpMessage(FFX_MESSAGE_TYPE_WARNING, L"frameTimeDelta is less than 1.0f - this value should be milliseconds (~16.6f for 60fps)");
+        context->contextDescription.fpMessage(FFX_MESSAGE_TYPE_WARNING, "frameTimeDelta is less than 1.0f - this value should be milliseconds (~16.6f for 60fps)");
     }
 
     if (params->preExposure == 0.0f)
     {
-        context->contextDescription.fpMessage(FFX_MESSAGE_TYPE_ERROR, L"preExposure provided as 0.0f which is invalid");
+        context->contextDescription.fpMessage(FFX_MESSAGE_TYPE_ERROR, "preExposure provided as 0.0f which is invalid");
     }
 
     bool infiniteDepth = (context->contextDescription.flags & FFX_FSR2_ENABLE_DEPTH_INFINITE) == FFX_FSR2_ENABLE_DEPTH_INFINITE;
@@ -273,20 +274,20 @@ static void fsr2DebugCheckDispatch(FfxFsr2Context_Private* context, const FfxFsr
         if (params->cameraNear < params->cameraFar)
         {
             context->contextDescription.fpMessage(FFX_MESSAGE_TYPE_WARNING,
-                L"FFX_FSR2_ENABLE_DEPTH_INVERTED flag is present yet cameraNear is less than cameraFar");
+                "FFX_FSR2_ENABLE_DEPTH_INVERTED flag is present yet cameraNear is less than cameraFar");
         }
         if (infiniteDepth)
         {
             if (params->cameraNear != FLT_MAX)
             {
                 context->contextDescription.fpMessage(FFX_MESSAGE_TYPE_WARNING,
-                    L"FFX_FSR2_ENABLE_DEPTH_INFINITE and FFX_FSR2_ENABLE_DEPTH_INVERTED present, yet cameraNear != FLT_MAX");
+                    "FFX_FSR2_ENABLE_DEPTH_INFINITE and FFX_FSR2_ENABLE_DEPTH_INVERTED present, yet cameraNear != FLT_MAX");
             }
         }
         if (params->cameraFar < 0.075f)
         {
             context->contextDescription.fpMessage(FFX_MESSAGE_TYPE_WARNING,
-                L"FFX_FSR2_ENABLE_DEPTH_INFINITE and FFX_FSR2_ENABLE_DEPTH_INVERTED present, cameraFar value is very low which may result in depth separation artefacting");
+                "FFX_FSR2_ENABLE_DEPTH_INFINITE and FFX_FSR2_ENABLE_DEPTH_INVERTED present, cameraFar value is very low which may result in depth separation artefacting");
         }
     }
     else
@@ -294,30 +295,30 @@ static void fsr2DebugCheckDispatch(FfxFsr2Context_Private* context, const FfxFsr
         if (params->cameraNear > params->cameraFar)
         {
             context->contextDescription.fpMessage(FFX_MESSAGE_TYPE_WARNING,
-                L"cameraNear is greater than cameraFar in non-inverted-depth context");
+                "cameraNear is greater than cameraFar in non-inverted-depth context");
         }
         if (infiniteDepth)
         {
             if (params->cameraFar != FLT_MAX)
             {
                 context->contextDescription.fpMessage(FFX_MESSAGE_TYPE_WARNING,
-                    L"FFX_FSR2_ENABLE_DEPTH_INFINITE and FFX_FSR2_ENABLE_DEPTH_INVERTED present, yet cameraFar != FLT_MAX");
+                    "FFX_FSR2_ENABLE_DEPTH_INFINITE and FFX_FSR2_ENABLE_DEPTH_INVERTED present, yet cameraFar != FLT_MAX");
             }
         }
         if (params->cameraNear < 0.075f)
         {
             context->contextDescription.fpMessage(FFX_MESSAGE_TYPE_WARNING,
-                L"FFX_FSR2_ENABLE_DEPTH_INFINITE and FFX_FSR2_ENABLE_DEPTH_INVERTED present, cameraNear value is very low which may result in depth separation artefacting");
+                "FFX_FSR2_ENABLE_DEPTH_INFINITE and FFX_FSR2_ENABLE_DEPTH_INVERTED present, cameraNear value is very low which may result in depth separation artefacting");
         }
     }
 
     if (params->cameraFovAngleVertical <= 0.0f)
     {
-        context->contextDescription.fpMessage(FFX_MESSAGE_TYPE_ERROR, L"cameraFovAngleVertical is 0.0f - this value should be > 0.0f");
+        context->contextDescription.fpMessage(FFX_MESSAGE_TYPE_ERROR, "cameraFovAngleVertical is 0.0f - this value should be > 0.0f");
     }
     if (params->cameraFovAngleVertical > FFX_PI)
     {
-        context->contextDescription.fpMessage(FFX_MESSAGE_TYPE_ERROR, L"cameraFovAngleVertical is greater than 180 degrees/PI");
+        context->contextDescription.fpMessage(FFX_MESSAGE_TYPE_ERROR, "cameraFovAngleVertical is greater than 180 degrees/PI");
     }
 }
 
@@ -326,12 +327,12 @@ static FfxErrorCode patchResourceBindings(FfxPipelineState* inoutPipeline)
     for (uint32_t srvIndex = 0; srvIndex < inoutPipeline->srvTextureCount; ++srvIndex)
     {
         int32_t mapIndex = 0;
-        for (mapIndex = 0; mapIndex < _countof(srvTextureBindingTable); ++mapIndex)
+        for (mapIndex = 0; mapIndex < std::size(srvTextureBindingTable); ++mapIndex)
         {
-            if (0 == wcscmp(srvTextureBindingTable[mapIndex].name, inoutPipeline->srvTextureBindings[srvIndex].name))
+            if (0 == strcmp(srvTextureBindingTable[mapIndex].name, inoutPipeline->srvTextureBindings[srvIndex].name))
                 break;
         }
-        if (mapIndex == _countof(srvTextureBindingTable))
+        if (mapIndex == std::size(srvTextureBindingTable))
             return FFX_ERROR_INVALID_ARGUMENT;
 
         inoutPipeline->srvTextureBindings[srvIndex].resourceIdentifier = srvTextureBindingTable[mapIndex].index;
@@ -340,12 +341,12 @@ static FfxErrorCode patchResourceBindings(FfxPipelineState* inoutPipeline)
     for (uint32_t uavIndex = 0; uavIndex < inoutPipeline->uavTextureCount; ++uavIndex)
     {
         int32_t mapIndex = 0;
-        for (mapIndex = 0; mapIndex < _countof(uavTextureBindingTable); ++mapIndex)
+        for (mapIndex = 0; mapIndex < std::size(uavTextureBindingTable); ++mapIndex)
         {
-            if (0 == wcscmp(uavTextureBindingTable[mapIndex].name, inoutPipeline->uavTextureBindings[uavIndex].name))
+            if (0 == strcmp(uavTextureBindingTable[mapIndex].name, inoutPipeline->uavTextureBindings[uavIndex].name))
                 break;
         }
-        if (mapIndex == _countof(uavTextureBindingTable))
+        if (mapIndex == std::size(uavTextureBindingTable))
             return FFX_ERROR_INVALID_ARGUMENT;
 
         inoutPipeline->uavTextureBindings[uavIndex].resourceIdentifier = uavTextureBindingTable[mapIndex].index;
@@ -354,12 +355,12 @@ static FfxErrorCode patchResourceBindings(FfxPipelineState* inoutPipeline)
     for (uint32_t cbIndex = 0; cbIndex < inoutPipeline->constCount; ++cbIndex)
     {
         int32_t mapIndex = 0;
-        for (mapIndex = 0; mapIndex < _countof(constantBufferBindingTable); ++mapIndex)
+        for (mapIndex = 0; mapIndex < std::size(constantBufferBindingTable); ++mapIndex)
         {
-            if (0 == wcscmp(constantBufferBindingTable[mapIndex].name, inoutPipeline->constantBufferBindings[cbIndex].name))
+            if (0 == strcmp(constantBufferBindingTable[mapIndex].name, inoutPipeline->constantBufferBindings[cbIndex].name))
                 break;
         }
-        if (mapIndex == _countof(constantBufferBindingTable))
+        if (mapIndex == std::size(constantBufferBindingTable))
             return FFX_ERROR_INVALID_ARGUMENT;
 
         inoutPipeline->constantBufferBindings[cbIndex].resourceIdentifier = constantBufferBindingTable[mapIndex].index;
@@ -431,42 +432,42 @@ static FfxErrorCode createPipelineStates(FfxFsr2Context_Private* context)
     uint32_t contextFlags = context->contextDescription.flags;
 
     // Set up pipeline descriptor (basically RootSignature and binding)
-    wcscpy_s(pipelineDescription.name, L"FSR2-LUM_PYRAMID");
+    strcpy(pipelineDescription.name, "FSR2-LUM_PYRAMID");
     FFX_VALIDATE(context->contextDescription.backendInterface.fpCreatePipeline(&context->contextDescription.backendInterface, FFX_EFFECT_FSR2, FFX_FSR2_PASS_COMPUTE_LUMINANCE_PYRAMID,
         getPipelinePermutationFlags(contextFlags, FFX_FSR2_PASS_COMPUTE_LUMINANCE_PYRAMID, supportedFP16, canForceWave64, useLut),
         &pipelineDescription, context->effectContextId, &context->pipelineComputeLuminancePyramid));
-    wcscpy_s(pipelineDescription.name, L"FSR2-RCAS");
+    strcpy(pipelineDescription.name, "FSR2-RCAS");
     FFX_VALIDATE(context->contextDescription.backendInterface.fpCreatePipeline(&context->contextDescription.backendInterface, FFX_EFFECT_FSR2, FFX_FSR2_PASS_RCAS,
         getPipelinePermutationFlags(contextFlags, FFX_FSR2_PASS_RCAS, supportedFP16, canForceWave64, useLut),
         &pipelineDescription, context->effectContextId, &context->pipelineRCAS));
-    wcscpy_s(pipelineDescription.name, L"FSR2-GEN_REACTIVE");
+    strcpy(pipelineDescription.name, "FSR2-GEN_REACTIVE");
     FFX_VALIDATE(context->contextDescription.backendInterface.fpCreatePipeline(&context->contextDescription.backendInterface, FFX_EFFECT_FSR2, FFX_FSR2_PASS_GENERATE_REACTIVE,
         getPipelinePermutationFlags(contextFlags, FFX_FSR2_PASS_GENERATE_REACTIVE, supportedFP16, canForceWave64, useLut),
         &pipelineDescription, context->effectContextId, &context->pipelineGenerateReactive));
-    wcscpy_s(pipelineDescription.name, L"FSR2-TCR_AUTOGENERATE");
+    strcpy(pipelineDescription.name, "FSR2-TCR_AUTOGENERATE");
     FFX_VALIDATE(context->contextDescription.backendInterface.fpCreatePipeline(&context->contextDescription.backendInterface, FFX_EFFECT_FSR2, FFX_FSR2_PASS_TCR_AUTOGENERATE,
         getPipelinePermutationFlags(contextFlags, FFX_FSR2_PASS_TCR_AUTOGENERATE, supportedFP16, canForceWave64, useLut),
         &pipelineDescription, context->effectContextId, &context->pipelineTcrAutogenerate));
 
     pipelineDescription.rootConstantBufferCount = 1;
 
-    wcscpy_s(pipelineDescription.name, L"FSR2-DEPTH_CLIP");
+    strcpy(pipelineDescription.name, "FSR2-DEPTH_CLIP");
     FFX_VALIDATE(context->contextDescription.backendInterface.fpCreatePipeline(&context->contextDescription.backendInterface, FFX_EFFECT_FSR2, FFX_FSR2_PASS_DEPTH_CLIP,
         getPipelinePermutationFlags(contextFlags, FFX_FSR2_PASS_DEPTH_CLIP, supportedFP16, canForceWave64, useLut),
         &pipelineDescription, context->effectContextId, &context->pipelineDepthClip));
-    wcscpy_s(pipelineDescription.name, L"FSR2-RECON_PREV_DEPTH");
+    strcpy(pipelineDescription.name, "FSR2-RECON_PREV_DEPTH");
     FFX_VALIDATE(context->contextDescription.backendInterface.fpCreatePipeline(&context->contextDescription.backendInterface, FFX_EFFECT_FSR2, FFX_FSR2_PASS_RECONSTRUCT_PREVIOUS_DEPTH,
         getPipelinePermutationFlags(contextFlags, FFX_FSR2_PASS_RECONSTRUCT_PREVIOUS_DEPTH, supportedFP16, canForceWave64, useLut),
         &pipelineDescription, context->effectContextId, &context->pipelineReconstructPreviousDepth));
-    wcscpy_s(pipelineDescription.name, L"FSR2-LOCK");
+    strcpy(pipelineDescription.name, "FSR2-LOCK");
     FFX_VALIDATE(context->contextDescription.backendInterface.fpCreatePipeline(&context->contextDescription.backendInterface, FFX_EFFECT_FSR2, FFX_FSR2_PASS_LOCK,
         getPipelinePermutationFlags(contextFlags, FFX_FSR2_PASS_LOCK, supportedFP16, canForceWave64, useLut),
         &pipelineDescription, context->effectContextId, &context->pipelineLock));
-    wcscpy_s(pipelineDescription.name, L"FSR2-ACCUMULATE");
+    strcpy(pipelineDescription.name, "FSR2-ACCUMULATE");
     FFX_VALIDATE(context->contextDescription.backendInterface.fpCreatePipeline(&context->contextDescription.backendInterface, FFX_EFFECT_FSR2, FFX_FSR2_PASS_ACCUMULATE,
         getPipelinePermutationFlags(contextFlags, FFX_FSR2_PASS_ACCUMULATE, supportedFP16, canForceWave64, useLut),
         &pipelineDescription, context->effectContextId, &context->pipelineAccumulate));
-    wcscpy_s(pipelineDescription.name, L"FSR2-ACCUM_SHARP");
+    strcpy(pipelineDescription.name, "FSR2-ACCUM_SHARP");
     FFX_VALIDATE(context->contextDescription.backendInterface.fpCreatePipeline(&context->contextDescription.backendInterface, FFX_EFFECT_FSR2, FFX_FSR2_PASS_ACCUMULATE_SHARPEN,
         getPipelinePermutationFlags(contextFlags, FFX_FSR2_PASS_ACCUMULATE_SHARPEN, supportedFP16, canForceWave64, useLut),
         &pipelineDescription, context->effectContextId, &context->pipelineAccumulateSharpen));
@@ -546,7 +547,7 @@ static FfxErrorCode fsr2Create(FfxFsr2Context_Private* context, const FfxFsr2Con
     const FfxInternalResourceDescription internalSurfaceDesc[] = {
 
         {FFX_FSR2_RESOURCE_IDENTIFIER_PREPARED_INPUT_COLOR,
-         L"FSR2_PreparedInputColor",
+         "FSR2_PreparedInputColor",
          FFX_RESOURCE_TYPE_TEXTURE2D,
          (FfxResourceUsage)(FFX_RESOURCE_USAGE_UAV | FFX_RESOURCE_USAGE_DCC_RENDERTARGET),
          FFX_SURFACE_FORMAT_R16G16B16A16_FLOAT,
@@ -557,7 +558,7 @@ static FfxErrorCode fsr2Create(FfxFsr2Context_Private* context, const FfxFsr2Con
          {FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED}},
 
         {FFX_FSR2_RESOURCE_IDENTIFIER_RECONSTRUCTED_PREVIOUS_NEAREST_DEPTH,
-         L"FSR2_ReconstructedPrevNearestDepth",
+         "FSR2_ReconstructedPrevNearestDepth",
          FFX_RESOURCE_TYPE_TEXTURE2D,
          FFX_RESOURCE_USAGE_UAV,
          FFX_SURFACE_FORMAT_R32_UINT,
@@ -568,7 +569,7 @@ static FfxErrorCode fsr2Create(FfxFsr2Context_Private* context, const FfxFsr2Con
          {FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED}},
 
         {FFX_FSR2_RESOURCE_IDENTIFIER_INTERNAL_DILATED_MOTION_VECTORS_1,
-         L"FSR2_InternalDilatedVelocity1",
+         "FSR2_InternalDilatedVelocity1",
          FFX_RESOURCE_TYPE_TEXTURE2D,
          (FfxResourceUsage)(FFX_RESOURCE_USAGE_RENDERTARGET | FFX_RESOURCE_USAGE_UAV | FFX_RESOURCE_USAGE_DCC_RENDERTARGET),
          FFX_SURFACE_FORMAT_R16G16_FLOAT,
@@ -579,7 +580,7 @@ static FfxErrorCode fsr2Create(FfxFsr2Context_Private* context, const FfxFsr2Con
          {FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED}},
 
         {FFX_FSR2_RESOURCE_IDENTIFIER_INTERNAL_DILATED_MOTION_VECTORS_2,
-         L"FSR2_InternalDilatedVelocity2",
+         "FSR2_InternalDilatedVelocity2",
          FFX_RESOURCE_TYPE_TEXTURE2D,
          (FfxResourceUsage)(FFX_RESOURCE_USAGE_RENDERTARGET | FFX_RESOURCE_USAGE_UAV | FFX_RESOURCE_USAGE_DCC_RENDERTARGET),
          FFX_SURFACE_FORMAT_R16G16_FLOAT,
@@ -590,7 +591,7 @@ static FfxErrorCode fsr2Create(FfxFsr2Context_Private* context, const FfxFsr2Con
          {FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED}},
 
         {FFX_FSR2_RESOURCE_IDENTIFIER_DILATED_DEPTH,
-         L"FSR2_DilatedDepth",
+         "FSR2_DilatedDepth",
          FFX_RESOURCE_TYPE_TEXTURE2D,
          (FfxResourceUsage)(FFX_RESOURCE_USAGE_RENDERTARGET | FFX_RESOURCE_USAGE_UAV),
          FFX_SURFACE_FORMAT_R32_FLOAT,
@@ -601,7 +602,7 @@ static FfxErrorCode fsr2Create(FfxFsr2Context_Private* context, const FfxFsr2Con
          {FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED}},
             
         {FFX_FSR2_RESOURCE_IDENTIFIER_LOCK_STATUS_1,
-         L"FSR2_LockStatus1",
+         "FSR2_LockStatus1",
          FFX_RESOURCE_TYPE_TEXTURE2D,
          (FfxResourceUsage)(FFX_RESOURCE_USAGE_RENDERTARGET | FFX_RESOURCE_USAGE_UAV),
          FFX_SURFACE_FORMAT_R16G16_FLOAT,
@@ -612,7 +613,7 @@ static FfxErrorCode fsr2Create(FfxFsr2Context_Private* context, const FfxFsr2Con
          {FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED}},
 
         {FFX_FSR2_RESOURCE_IDENTIFIER_LOCK_STATUS_2,
-         L"FSR2_LockStatus2",
+         "FSR2_LockStatus2",
          FFX_RESOURCE_TYPE_TEXTURE2D,
          (FfxResourceUsage)(FFX_RESOURCE_USAGE_RENDERTARGET | FFX_RESOURCE_USAGE_UAV),
          FFX_SURFACE_FORMAT_R16G16_FLOAT,
@@ -623,7 +624,7 @@ static FfxErrorCode fsr2Create(FfxFsr2Context_Private* context, const FfxFsr2Con
          {FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED}},
 
         {FFX_FSR2_RESOURCE_IDENTIFIER_LOCK_INPUT_LUMA,
-         L"FSR2_LockInputLuma",
+         "FSR2_LockInputLuma",
          FFX_RESOURCE_TYPE_TEXTURE2D,
          (FfxResourceUsage)(FFX_RESOURCE_USAGE_UAV),
          FFX_SURFACE_FORMAT_R16_FLOAT,
@@ -634,7 +635,7 @@ static FfxErrorCode fsr2Create(FfxFsr2Context_Private* context, const FfxFsr2Con
          {FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED}},
 
         {FFX_FSR2_RESOURCE_IDENTIFIER_NEW_LOCKS,
-         L"FSR2_NewLocks",
+         "FSR2_NewLocks",
          FFX_RESOURCE_TYPE_TEXTURE2D,
          (FfxResourceUsage)(FFX_RESOURCE_USAGE_UAV),
          FFX_SURFACE_FORMAT_R8_UNORM,
@@ -645,7 +646,7 @@ static FfxErrorCode fsr2Create(FfxFsr2Context_Private* context, const FfxFsr2Con
          {FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED}},
 
         {FFX_FSR2_RESOURCE_IDENTIFIER_INTERNAL_UPSCALED_COLOR_1,
-         L"FSR2_InternalUpscaled1",
+         "FSR2_InternalUpscaled1",
          FFX_RESOURCE_TYPE_TEXTURE2D,
          (FfxResourceUsage)(FFX_RESOURCE_USAGE_RENDERTARGET | FFX_RESOURCE_USAGE_UAV | FFX_RESOURCE_USAGE_DCC_RENDERTARGET),
          FFX_SURFACE_FORMAT_R16G16B16A16_FLOAT,
@@ -656,7 +657,7 @@ static FfxErrorCode fsr2Create(FfxFsr2Context_Private* context, const FfxFsr2Con
          {FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED}},
 
         {FFX_FSR2_RESOURCE_IDENTIFIER_INTERNAL_UPSCALED_COLOR_2,
-         L"FSR2_InternalUpscaled2",
+         "FSR2_InternalUpscaled2",
          FFX_RESOURCE_TYPE_TEXTURE2D,
          (FfxResourceUsage)(FFX_RESOURCE_USAGE_RENDERTARGET | FFX_RESOURCE_USAGE_UAV | FFX_RESOURCE_USAGE_DCC_RENDERTARGET),
          FFX_SURFACE_FORMAT_R16G16B16A16_FLOAT,
@@ -667,7 +668,7 @@ static FfxErrorCode fsr2Create(FfxFsr2Context_Private* context, const FfxFsr2Con
          {FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED}},
 
         {FFX_FSR2_RESOURCE_IDENTIFIER_SCENE_LUMINANCE,
-         L"FSR2_ExposureMips",
+         "FSR2_ExposureMips",
          FFX_RESOURCE_TYPE_TEXTURE2D,
          FFX_RESOURCE_USAGE_UAV,
          FFX_SURFACE_FORMAT_R16_FLOAT,
@@ -678,7 +679,7 @@ static FfxErrorCode fsr2Create(FfxFsr2Context_Private* context, const FfxFsr2Con
          {FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED}},
 
         {FFX_FSR2_RESOURCE_IDENTIFIER_LUMA_HISTORY_1,
-         L"FSR2_LumaHistory1",
+         "FSR2_LumaHistory1",
          FFX_RESOURCE_TYPE_TEXTURE2D,
          (FfxResourceUsage)(FFX_RESOURCE_USAGE_RENDERTARGET | FFX_RESOURCE_USAGE_UAV),
          FFX_SURFACE_FORMAT_R8G8B8A8_UNORM,
@@ -689,7 +690,7 @@ static FfxErrorCode fsr2Create(FfxFsr2Context_Private* context, const FfxFsr2Con
          {FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED}},
 
         {FFX_FSR2_RESOURCE_IDENTIFIER_LUMA_HISTORY_2,
-         L"FSR2_LumaHistory2",
+         "FSR2_LumaHistory2",
          FFX_RESOURCE_TYPE_TEXTURE2D,
          (FfxResourceUsage)(FFX_RESOURCE_USAGE_RENDERTARGET | FFX_RESOURCE_USAGE_UAV),
          FFX_SURFACE_FORMAT_R8G8B8A8_UNORM,
@@ -700,7 +701,7 @@ static FfxErrorCode fsr2Create(FfxFsr2Context_Private* context, const FfxFsr2Con
          {FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED}},
 
         {FFX_FSR2_RESOURCE_IDENTIFIER_SPD_ATOMIC_COUNT,
-         L"FSR2_SpdAtomicCounter",
+         "FSR2_SpdAtomicCounter",
          FFX_RESOURCE_TYPE_TEXTURE2D,
          FFX_RESOURCE_USAGE_UAV,
          FFX_SURFACE_FORMAT_R32_UINT,
@@ -711,7 +712,7 @@ static FfxErrorCode fsr2Create(FfxFsr2Context_Private* context, const FfxFsr2Con
          {FFX_RESOURCE_INIT_DATA_TYPE_VALUE, sizeof(uint32_t), 0}},
 
         {FFX_FSR2_RESOURCE_IDENTIFIER_DILATED_REACTIVE_MASKS,
-         L"FSR2_DilatedReactiveMasks",
+         "FSR2_DilatedReactiveMasks",
          FFX_RESOURCE_TYPE_TEXTURE2D,
          (FfxResourceUsage)(FFX_RESOURCE_USAGE_UAV | FFX_RESOURCE_USAGE_DCC_RENDERTARGET),
          FFX_SURFACE_FORMAT_R8G8_UNORM,
@@ -722,7 +723,7 @@ static FfxErrorCode fsr2Create(FfxFsr2Context_Private* context, const FfxFsr2Con
          {FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED}},
 
         {FFX_FSR2_RESOURCE_IDENTIFIER_LANCZOS_LUT,
-         L"FSR2_LanczosLutData",
+         "FSR2_LanczosLutData",
          FFX_RESOURCE_TYPE_TEXTURE2D,
          FFX_RESOURCE_USAGE_READ_ONLY,
          FFX_SURFACE_FORMAT_R16_SNORM,
@@ -733,7 +734,7 @@ static FfxErrorCode fsr2Create(FfxFsr2Context_Private* context, const FfxFsr2Con
          {FFX_RESOURCE_INIT_DATA_TYPE_BUFFER, sizeof(lanczos2Weights), lanczos2Weights}},
 
         {FFX_FSR2_RESOURCE_IDENTIFIER_INTERNAL_DEFAULT_REACTIVITY,
-         L"FSR2_DefaultReactiviyMask",
+         "FSR2_DefaultReactiviyMask",
          FFX_RESOURCE_TYPE_TEXTURE2D,
          FFX_RESOURCE_USAGE_READ_ONLY,
          FFX_SURFACE_FORMAT_R8_UNORM,
@@ -744,7 +745,7 @@ static FfxErrorCode fsr2Create(FfxFsr2Context_Private* context, const FfxFsr2Con
          {FFX_RESOURCE_INIT_DATA_TYPE_VALUE, sizeof(uint8_t), 0}},
 
         {FFX_FSR2_RESOURCE_IDENTITIER_UPSAMPLE_MAXIMUM_BIAS_LUT,
-         L"FSR2_MaximumUpsampleBias",
+         "FSR2_MaximumUpsampleBias",
          FFX_RESOURCE_TYPE_TEXTURE2D,
          FFX_RESOURCE_USAGE_READ_ONLY,
          FFX_SURFACE_FORMAT_R16_SNORM,
@@ -755,7 +756,7 @@ static FfxErrorCode fsr2Create(FfxFsr2Context_Private* context, const FfxFsr2Con
          {FFX_RESOURCE_INIT_DATA_TYPE_BUFFER, sizeof(maximumBias), maximumBias}},
 
         {FFX_FSR2_RESOURCE_IDENTIFIER_INTERNAL_DEFAULT_EXPOSURE,
-         L"FSR2_DefaultExposure",
+         "FSR2_DefaultExposure",
          FFX_RESOURCE_TYPE_TEXTURE2D,
          FFX_RESOURCE_USAGE_READ_ONLY,
          FFX_SURFACE_FORMAT_R32G32_FLOAT,
@@ -766,7 +767,7 @@ static FfxErrorCode fsr2Create(FfxFsr2Context_Private* context, const FfxFsr2Con
          {FFX_RESOURCE_INIT_DATA_TYPE_VALUE, sizeof(float) * 2, 0}},
 
         {FFX_FSR2_RESOURCE_IDENTIFIER_AUTO_EXPOSURE,
-         L"FSR2_AutoExposure",
+         "FSR2_AutoExposure",
          FFX_RESOURCE_TYPE_TEXTURE2D,
          FFX_RESOURCE_USAGE_UAV,
          FFX_SURFACE_FORMAT_R32G32_FLOAT,
@@ -779,7 +780,7 @@ static FfxErrorCode fsr2Create(FfxFsr2Context_Private* context, const FfxFsr2Con
 
         // only one for now, will need ping pong to respect the motion vectors
         {FFX_FSR2_RESOURCE_IDENTIFIER_AUTOREACTIVE,
-         L"FSR2_AutoReactive",
+         "FSR2_AutoReactive",
          FFX_RESOURCE_TYPE_TEXTURE2D,
          FFX_RESOURCE_USAGE_UAV,
          FFX_SURFACE_FORMAT_R8_UNORM,
@@ -790,7 +791,7 @@ static FfxErrorCode fsr2Create(FfxFsr2Context_Private* context, const FfxFsr2Con
          {FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED}},
         
         {FFX_FSR2_RESOURCE_IDENTIFIER_AUTOCOMPOSITION,
-         L"FSR2_AutoComposition",
+         "FSR2_AutoComposition",
          FFX_RESOURCE_TYPE_TEXTURE2D,
          FFX_RESOURCE_USAGE_UAV,
          FFX_SURFACE_FORMAT_R8_UNORM,
@@ -801,7 +802,7 @@ static FfxErrorCode fsr2Create(FfxFsr2Context_Private* context, const FfxFsr2Con
          {FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED}},
         
         {FFX_FSR2_RESOURCE_IDENTIFIER_PREV_PRE_ALPHA_COLOR_1,
-         L"FSR2_PrevPreAlpha0",
+         "FSR2_PrevPreAlpha0",
          FFX_RESOURCE_TYPE_TEXTURE2D,
          FFX_RESOURCE_USAGE_UAV,
          FFX_SURFACE_FORMAT_R11G11B10_FLOAT,
@@ -812,7 +813,7 @@ static FfxErrorCode fsr2Create(FfxFsr2Context_Private* context, const FfxFsr2Con
          {FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED}},
         
         {FFX_FSR2_RESOURCE_IDENTIFIER_PREV_POST_ALPHA_COLOR_1,
-         L"FSR2_PrevPostAlpha0",
+         "FSR2_PrevPostAlpha0",
          FFX_RESOURCE_TYPE_TEXTURE2D,
          FFX_RESOURCE_USAGE_UAV,
          FFX_SURFACE_FORMAT_R11G11B10_FLOAT,
@@ -823,7 +824,7 @@ static FfxErrorCode fsr2Create(FfxFsr2Context_Private* context, const FfxFsr2Con
          {FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED}},
         
         {FFX_FSR2_RESOURCE_IDENTIFIER_PREV_PRE_ALPHA_COLOR_2,
-         L"FSR2_PrevPreAlpha1",
+         "FSR2_PrevPreAlpha1",
          FFX_RESOURCE_TYPE_TEXTURE2D,
          FFX_RESOURCE_USAGE_UAV,
          FFX_SURFACE_FORMAT_R11G11B10_FLOAT,
@@ -834,7 +835,7 @@ static FfxErrorCode fsr2Create(FfxFsr2Context_Private* context, const FfxFsr2Con
          {FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED}},
         
         {FFX_FSR2_RESOURCE_IDENTIFIER_PREV_POST_ALPHA_COLOR_2,
-         L"FSR2_PrevPostAlpha1",
+         "FSR2_PrevPostAlpha1",
          FFX_RESOURCE_TYPE_TEXTURE2D,
          FFX_RESOURCE_USAGE_UAV,
          FFX_SURFACE_FORMAT_R11G11B10_FLOAT,
@@ -975,7 +976,7 @@ static void setupDeviceDepthToViewSpaceDepthParams(FfxFsr2Context_Private* conte
 static void scheduleDispatch(FfxFsr2Context_Private* context, const FfxFsr2DispatchDescription*, const FfxPipelineState* pipeline, uint32_t dispatchX, uint32_t dispatchY)
 {
     FfxGpuJobDescription dispatchJob = {FFX_GPU_JOB_COMPUTE};
-    wcscpy_s(dispatchJob.jobLabel, pipeline->name);
+    strcpy(dispatchJob.jobLabel, pipeline->name);
 
     for (uint32_t currentShaderResourceViewIndex = 0; currentShaderResourceViewIndex < pipeline->srvTextureCount; ++currentShaderResourceViewIndex) {
 
@@ -983,7 +984,7 @@ static void scheduleDispatch(FfxFsr2Context_Private* context, const FfxFsr2Dispa
         const FfxResourceInternal currentResource = context->srvResources[currentResourceId];
         dispatchJob.computeJobDescriptor.srvTextures[currentShaderResourceViewIndex].resource = currentResource;
 #ifdef FFX_DEBUG
-        wcscpy_s(dispatchJob.computeJobDescriptor.srvTextures[currentShaderResourceViewIndex].name,
+        strcpy(dispatchJob.computeJobDescriptor.srvTextures[currentShaderResourceViewIndex].name,
                  pipeline->srvTextureBindings[currentShaderResourceViewIndex].name);
 #endif
     }
@@ -992,7 +993,7 @@ static void scheduleDispatch(FfxFsr2Context_Private* context, const FfxFsr2Dispa
 
         const uint32_t currentResourceId = pipeline->uavTextureBindings[currentUnorderedAccessViewIndex].resourceIdentifier;
 #ifdef FFX_DEBUG
-        wcscpy_s(dispatchJob.computeJobDescriptor.uavTextures[currentUnorderedAccessViewIndex].name,
+        strcpy(dispatchJob.computeJobDescriptor.uavTextures[currentUnorderedAccessViewIndex].name,
                  pipeline->uavTextureBindings[currentUnorderedAccessViewIndex].name);
 #endif
         if (currentResourceId >= FFX_FSR2_RESOURCE_IDENTIFIER_SCENE_LUMINANCE_MIPMAP_0 && currentResourceId <= FFX_FSR2_RESOURCE_IDENTIFIER_SCENE_LUMINANCE_MIPMAP_12)
@@ -1017,7 +1018,7 @@ static void scheduleDispatch(FfxFsr2Context_Private* context, const FfxFsr2Dispa
 
     for (uint32_t currentRootConstantIndex = 0; currentRootConstantIndex < pipeline->constCount; ++currentRootConstantIndex) {
 #ifdef FFX_DEBUG
-        wcscpy_s(dispatchJob.computeJobDescriptor.cbNames[currentRootConstantIndex], pipeline->constantBufferBindings[currentRootConstantIndex].name);
+        strcpy(dispatchJob.computeJobDescriptor.cbNames[currentRootConstantIndex], pipeline->constantBufferBindings[currentRootConstantIndex].name);
 #endif
         dispatchJob.computeJobDescriptor.cbs[currentRootConstantIndex] = context->constantBuffers[pipeline->constantBufferBindings[currentRootConstantIndex].resourceIdentifier];
     }
@@ -1039,7 +1040,7 @@ static FfxErrorCode fsr2Dispatch(FfxFsr2Context_Private* context, const FfxFsr2D
     if (context->firstExecution)
     {
         FfxGpuJobDescription clearJob = { FFX_GPU_JOB_CLEAR_FLOAT };
-        wcscpy_s(clearJob.jobLabel, L"Zero initialize resource");
+        strcpy(clearJob.jobLabel, "Zero initialize resource");
 
         const float clearValuesToZeroFloat[]{ 0.f, 0.f, 0.f, 0.f };
         memcpy(clearJob.clearJobDescriptor.color, clearValuesToZeroFloat, 4 * sizeof(float));
@@ -1212,7 +1213,7 @@ static FfxErrorCode fsr2Dispatch(FfxFsr2Context_Private* context, const FfxFsr2D
     if (resetAccumulation) {
 
         FfxGpuJobDescription clearJob = { FFX_GPU_JOB_CLEAR_FLOAT };
-        wcscpy_s(clearJob.jobLabel, L"Zero initialize resource");
+        strcpy(clearJob.jobLabel, "Zero initialize resource");
         // LockStatus resource has no sign bit, callback functions are compensating for this.
         // Clearing the resource must follow the same logic.
         float clearValuesLockStatus[4]{};
@@ -1529,9 +1530,9 @@ FfxErrorCode ffxFsr2ContextGenerateReactiveMask(FfxFsr2Context* context, const F
     jobDescriptor.uavTextures[0].resource = contextPrivate->uavResources[FFX_FSR2_RESOURCE_IDENTIFIER_AUTOREACTIVE];
 
 #ifdef FFX_DEBUG
-    wcscpy_s(jobDescriptor.srvTextures[0].name, pipeline->srvTextureBindings[0].name);
-    wcscpy_s(jobDescriptor.srvTextures[1].name, pipeline->srvTextureBindings[1].name);
-    wcscpy_s(jobDescriptor.uavTextures[0].name, pipeline->uavTextureBindings[0].name);
+    strcpy(jobDescriptor.srvTextures[0].name, pipeline->srvTextureBindings[0].name);
+    strcpy(jobDescriptor.srvTextures[1].name, pipeline->srvTextureBindings[1].name);
+    strcpy(jobDescriptor.uavTextures[0].name, pipeline->uavTextureBindings[0].name);
 #endif
 
     jobDescriptor.dimensions[0] = dispatchSrcX;
@@ -1545,7 +1546,7 @@ FfxErrorCode ffxFsr2ContextGenerateReactiveMask(FfxFsr2Context* context, const F
         const FfxResourceInternal currentResource = contextPrivate->srvResources[currentResourceId];
         jobDescriptor.srvTextures[currentShaderResourceViewIndex].resource = currentResource;
 #ifdef FFX_DEBUG
-        wcscpy_s(jobDescriptor.srvTextures[currentShaderResourceViewIndex].name, pipeline->srvTextureBindings[currentShaderResourceViewIndex].name);
+        strcpy(jobDescriptor.srvTextures[currentShaderResourceViewIndex].name, pipeline->srvTextureBindings[currentShaderResourceViewIndex].name);
 #endif
     }
 
@@ -1560,10 +1561,10 @@ FfxErrorCode ffxFsr2ContextGenerateReactiveMask(FfxFsr2Context* context, const F
                                                                                       sizeof(constants),
                                                                                       &jobDescriptor.cbs[0]);
 #ifdef FFX_DEBUG
-    wcscpy_s(jobDescriptor.cbNames[0], pipeline->constantBufferBindings[0].name);
+    strcpy(jobDescriptor.cbNames[0], pipeline->constantBufferBindings[0].name);
 #endif
     FfxGpuJobDescription dispatchJob = { FFX_GPU_JOB_COMPUTE };
-    wcscpy_s(dispatchJob.jobLabel, pipeline->name);
+    strcpy(dispatchJob.jobLabel, pipeline->name);
     dispatchJob.computeJobDescriptor = jobDescriptor;
 
     //contextPrivate->contextDescription.backendInterface.fpScheduleGpuJob(&contextPrivate->contextDescription.backendInterface, &dispatchJob);
@@ -1598,10 +1599,10 @@ static FfxErrorCode generateReactiveMaskInternal(FfxFsr2Context_Private* context
     jobDescriptor.uavTextures[3].resource = contextPrivate->uavResources[FFX_FSR2_RESOURCE_IDENTIFIER_PREV_POST_ALPHA_COLOR];
 
 #ifdef FFX_DEBUG
-    wcscpy_s(jobDescriptor.uavTextures[0].name, pipeline->uavTextureBindings[0].name);
-    wcscpy_s(jobDescriptor.uavTextures[1].name, pipeline->uavTextureBindings[1].name);
-    wcscpy_s(jobDescriptor.uavTextures[2].name, pipeline->uavTextureBindings[2].name);
-    wcscpy_s(jobDescriptor.uavTextures[3].name, pipeline->uavTextureBindings[3].name);
+    strcpy(jobDescriptor.uavTextures[0].name, pipeline->uavTextureBindings[0].name);
+    strcpy(jobDescriptor.uavTextures[1].name, pipeline->uavTextureBindings[1].name);
+    strcpy(jobDescriptor.uavTextures[2].name, pipeline->uavTextureBindings[2].name);
+    strcpy(jobDescriptor.uavTextures[3].name, pipeline->uavTextureBindings[3].name);
 #endif
 
     jobDescriptor.dimensions[0] = dispatchSrcX;
@@ -1615,20 +1616,20 @@ static FfxErrorCode generateReactiveMaskInternal(FfxFsr2Context_Private* context
         const FfxResourceInternal currentResource = contextPrivate->srvResources[currentResourceId];
         jobDescriptor.srvTextures[currentShaderResourceViewIndex].resource = currentResource;
 #ifdef FFX_DEBUG
-        wcscpy_s(jobDescriptor.srvTextures[currentShaderResourceViewIndex].name, pipeline->srvTextureBindings[currentShaderResourceViewIndex].name);
+        strcpy(jobDescriptor.srvTextures[currentShaderResourceViewIndex].name, pipeline->srvTextureBindings[currentShaderResourceViewIndex].name);
 #endif
     }
 
     for (uint32_t currentRootConstantIndex = 0; currentRootConstantIndex < pipeline->constCount; ++currentRootConstantIndex) {
 #ifdef FFX_DEBUG
-        wcscpy_s(jobDescriptor.cbNames[currentRootConstantIndex], pipeline->constantBufferBindings[currentRootConstantIndex].name);
+        strcpy(jobDescriptor.cbNames[currentRootConstantIndex], pipeline->constantBufferBindings[currentRootConstantIndex].name);
 #endif
         jobDescriptor.cbs[currentRootConstantIndex] = contextPrivate->constantBuffers[pipeline->constantBufferBindings[currentRootConstantIndex].resourceIdentifier];
         //jobDescriptor.cbSlotIndex[currentRootConstantIndex] = pipeline->constantBufferBindings[currentRootConstantIndex].slotIndex;
     }
 
     FfxGpuJobDescription dispatchJob = { FFX_GPU_JOB_COMPUTE };
-    wcscpy_s(dispatchJob.jobLabel, pipeline->name);
+    strcpy(dispatchJob.jobLabel, pipeline->name);
     dispatchJob.computeJobDescriptor = jobDescriptor;
 
     contextPrivate->contextDescription.backendInterface.fpScheduleGpuJob(&contextPrivate->contextDescription.backendInterface, &dispatchJob);
diff --git a/sdk/src/components/fsr3/CMakeLists.txt b/sdk/src/components/fsr3/CMakeLists.txt
index 5cff93c..dac8c5f 100644
--- a/sdk/src/components/fsr3/CMakeLists.txt
+++ b/sdk/src/components/fsr3/CMakeLists.txt
@@ -39,9 +39,9 @@ if (FFX_FSR3 OR FFX_ALL)
 	list(APPEND PUBLIC_SOURCES ${FFX_PUBLIC_SOURCES})
 
 	if (FFX_BUILD_AS_DLL)
-		add_library(ffx_fsr3_${FFX_PLATFORM_NAME} SHARED ${SHARED_SOURCES} ${PRIVATE_SOURCES} ${PUBLIC_SOURCES})
+		add_library(fsr3 SHARED ${SHARED_SOURCES} ${PRIVATE_SOURCES} ${PUBLIC_SOURCES})
 	else()
-		add_library(ffx_fsr3_${FFX_PLATFORM_NAME} STATIC ${SHARED_SOURCES} ${PRIVATE_SOURCES} ${PUBLIC_SOURCES})
+		add_library(fsr3 STATIC ${SHARED_SOURCES} ${PRIVATE_SOURCES} ${PUBLIC_SOURCES})
 	endif()
 
 	# API
@@ -50,12 +50,19 @@ if (FFX_FSR3 OR FFX_ALL)
 	source_group("public_source"  FILES ${PUBLIC_SOURCES})
 
 	# Dependencies
-	target_link_libraries(ffx_fsr3_${FFX_PLATFORM_NAME} PRIVATE ffx_fsr3upscaler_${FFX_PLATFORM_NAME} ffx_opticalflow_${FFX_PLATFORM_NAME} ffx_frameinterpolation_${FFX_PLATFORM_NAME})
+	target_link_libraries(fsr3 PRIVATE fsr3upscaler opticalflow frameinterpolation)
 
-	target_include_directories(ffx_fsr3_${FFX_PLATFORM_NAME} PUBLIC ${FFX_INCLUDE_PATH})
-	target_include_directories(ffx_fsr3_${FFX_PLATFORM_NAME} PUBLIC ${FFX_SHARED_PATH})
+	target_include_directories(fsr3 PUBLIC
+		$<BUILD_INTERFACE:${FFX_INCLUDE_PATH}>
+		$<INSTALL_INTERFACE:include>)
+	target_include_directories(fsr3 PRIVATE ${FFX_SHARED_PATH})
 
 	set_source_files_properties(${SHADERS} PROPERTIES HEADER_FILE_ONLY TRUE)
-	set_target_properties(ffx_fsr3_${FFX_PLATFORM_NAME} PROPERTIES FOLDER Components)
+	set_target_properties(fsr3 PROPERTIES FOLDER Components)
+	
+	install(TARGETS fsr3 EXPORT fsr3-targets)
+	install(EXPORT fsr3-targets 
+		DESTINATION "${CMAKE_INSTALL_DATADIR}/cmake/${PROJECT_NAME}"
+		NAMESPACE fidelityfx::)
 	
 endif()
diff --git a/sdk/src/components/fsr3/ffx_fsr3.cpp b/sdk/src/components/fsr3/ffx_fsr3.cpp
index 38f5220..815238b 100644
--- a/sdk/src/components/fsr3/ffx_fsr3.cpp
+++ b/sdk/src/components/fsr3/ffx_fsr3.cpp
@@ -24,6 +24,7 @@
 #include <cmath>        // for fabs, abs, sinf, sqrt, etc.
 #include <string.h>     // for memset
 #include <cfloat>       // for FLT_EPSILON
+#include <cstdio>       // for snprintf
 #include <FidelityFX/host/ffx_fsr3.h>
 #include <FidelityFX/host/ffx_fsr3upscaler.h>
 #define FFX_CPU
@@ -199,23 +200,23 @@ FfxErrorCode ffxFsr3ContextCreate(FfxFsr3Context* context, FfxFsr3ContextDescrip
         FfxFsr3UpscalerSharedResourceDescriptions fs3UpscalerResourceDescs = {};
         FFX_VALIDATE(ffxFsr3UpscalerGetSharedResourceDescriptions(&contextPrivate->upscalerContext, &fs3UpscalerResourceDescs));
 
-        wchar_t Name[256] = {};
+        char Name[256] = {};
         for (FfxUInt32 i = 0; i < contextPrivate->sharedResourceCount; i++)
         {
             FfxCreateResourceDescription dilD = fs3UpscalerResourceDescs.dilatedDepth;
-            swprintf(Name, 255, L"%s%d", fs3UpscalerResourceDescs.dilatedDepth.name, i);
+            snprintf(Name, 255, "%s%d", fs3UpscalerResourceDescs.dilatedDepth.name, i);
             dilD.name = Name;
             FFX_VALIDATE(contextDescription->backendInterfaceSharedResources.fpCreateResource(
                 &contextDescription->backendInterfaceSharedResources, &dilD, contextPrivate->effectContextIdSharedResources, &contextPrivate->sharedResources[FFX_FSR3_RESOURCE_IDENTIFIER_DILATED_DEPTH_0 + (i * FFX_FSR3_RESOURCE_IDENTIFIER_UPSCALED_COUNT)]));
 
             FfxCreateResourceDescription dilMVs = fs3UpscalerResourceDescs.dilatedMotionVectors;
-            swprintf(Name, 255, L"%s%d", fs3UpscalerResourceDescs.dilatedMotionVectors.name, i);
+            snprintf(Name, 255, "%s%d", fs3UpscalerResourceDescs.dilatedMotionVectors.name, i);
             dilMVs.name = Name;
             FFX_VALIDATE(contextDescription->backendInterfaceSharedResources.fpCreateResource(
                 &contextDescription->backendInterfaceSharedResources, &dilMVs, contextPrivate->effectContextIdSharedResources, &contextPrivate->sharedResources[FFX_FSR3_RESOURCE_IDENTIFIER_DILATED_MOTION_VECTORS_0 + (i * FFX_FSR3_RESOURCE_IDENTIFIER_UPSCALED_COUNT)]));
 
             FfxCreateResourceDescription recND = fs3UpscalerResourceDescs.reconstructedPrevNearestDepth;
-            swprintf(Name, 255, L"%s%d", fs3UpscalerResourceDescs.reconstructedPrevNearestDepth.name, i);
+            snprintf(Name, 255, "%s%d", fs3UpscalerResourceDescs.reconstructedPrevNearestDepth.name, i);
             recND.name = Name;
             FFX_VALIDATE(contextDescription->backendInterfaceSharedResources.fpCreateResource(
                 &contextDescription->backendInterfaceSharedResources, &recND, contextPrivate->effectContextIdSharedResources, &contextPrivate->sharedResources[FFX_FSR3_RESOURCE_IDENTIFIER_RECONSTRUCTED_PREVIOUS_NEAREST_DEPTH_0 + (i * FFX_FSR3_RESOURCE_IDENTIFIER_UPSCALED_COUNT)]));
diff --git a/sdk/src/components/fsr3upscaler/CMakeLists.txt b/sdk/src/components/fsr3upscaler/CMakeLists.txt
index 8afbc2f..b96bf58 100644
--- a/sdk/src/components/fsr3upscaler/CMakeLists.txt
+++ b/sdk/src/components/fsr3upscaler/CMakeLists.txt
@@ -38,9 +38,9 @@ if (FFX_FSR3UPSCALER OR FFX_ALL)
 	list(APPEND PUBLIC_SOURCES ${FFX_PUBLIC_SOURCES})
 
 	if (FFX_BUILD_AS_DLL)
-		add_library(ffx_fsr3upscaler_${FFX_PLATFORM_NAME} SHARED ${SHARED_SOURCES} ${PRIVATE_SOURCES} ${PUBLIC_SOURCES})
+		add_library(fsr3upscaler SHARED ${SHARED_SOURCES} ${PRIVATE_SOURCES} ${PUBLIC_SOURCES})
 	else()
-		add_library(ffx_fsr3upscaler_${FFX_PLATFORM_NAME} STATIC ${SHARED_SOURCES} ${PRIVATE_SOURCES} ${PUBLIC_SOURCES})
+		add_library(fsr3upscaler STATIC ${SHARED_SOURCES} ${PRIVATE_SOURCES} ${PUBLIC_SOURCES})
 	endif()
 
 	# API
@@ -48,10 +48,17 @@ if (FFX_FSR3UPSCALER OR FFX_ALL)
 	source_group("private_source" FILES ${PRIVATE_SOURCES})
 	source_group("public_source"  FILES ${PUBLIC_SOURCES})
 
-	target_include_directories(ffx_fsr3upscaler_${FFX_PLATFORM_NAME} PUBLIC ${FFX_INCLUDE_PATH})
-	target_include_directories(ffx_fsr3upscaler_${FFX_PLATFORM_NAME} PUBLIC ${FFX_SHARED_PATH})
+	target_include_directories(fsr3upscaler PUBLIC
+		$<BUILD_INTERFACE:${FFX_INCLUDE_PATH}>
+		$<INSTALL_INTERFACE:include>)
+	target_include_directories(fsr3upscaler PRIVATE ${FFX_SHARED_PATH})
 
 	set_source_files_properties(${SHADERS} PROPERTIES HEADER_FILE_ONLY TRUE)
-	set_target_properties(ffx_fsr3upscaler_${FFX_PLATFORM_NAME} PROPERTIES FOLDER Components)
+	set_target_properties(fsr3upscaler PROPERTIES FOLDER Components)
+	
+	install(TARGETS fsr3upscaler EXPORT fsr3upscaler-targets)
+	install(EXPORT fsr3upscaler-targets 
+		DESTINATION "${CMAKE_INSTALL_DATADIR}/cmake/${PROJECT_NAME}"
+		NAMESPACE fidelityfx::)
 	
 endif()
diff --git a/sdk/src/components/fsr3upscaler/ffx_fsr3upscaler.cpp b/sdk/src/components/fsr3upscaler/ffx_fsr3upscaler.cpp
index 03b3849..104d8f1 100644
--- a/sdk/src/components/fsr3upscaler/ffx_fsr3upscaler.cpp
+++ b/sdk/src/components/fsr3upscaler/ffx_fsr3upscaler.cpp
@@ -24,6 +24,7 @@
 #include <cmath>        // for fabs, abs, sinf, sqrt, etc.
 #include <string.h>     // for memset
 #include <cfloat>       // for FLT_EPSILON
+#include <array>        // for std::size
 #include <FidelityFX/host/ffx_fsr3upscaler.h>
 
 #define FFX_CPU
@@ -50,76 +51,76 @@ static const uint32_t FSR3UPSCALER_MAX_QUEUED_FRAMES = 16;
 typedef struct ResourceBinding
 {
     uint32_t    index;
-    wchar_t     name[64];
+    char        name[64];
 }ResourceBinding;
 
 static const ResourceBinding srvTextureBindingTable[] =
 {
-    {FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_INPUT_COLOR,                              L"r_input_color_jittered"},
-    {FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_INPUT_OPAQUE_ONLY,                        L"r_input_opaque_only"},
-    {FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_INPUT_MOTION_VECTORS,                     L"r_input_motion_vectors"},
-    {FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_INPUT_DEPTH,                              L"r_input_depth" },
-    {FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_INPUT_EXPOSURE,                           L"r_input_exposure"},
-    {FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_FRAME_INFO,                               L"r_frame_info"},
-    {FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_INPUT_REACTIVE_MASK,                      L"r_reactive_mask"},
-    {FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_INPUT_TRANSPARENCY_AND_COMPOSITION_MASK,  L"r_transparency_and_composition_mask"},
-    {FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_RECONSTRUCTED_PREVIOUS_NEAREST_DEPTH,     L"r_reconstructed_previous_nearest_depth"},
-    {FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_DILATED_MOTION_VECTORS,                   L"r_dilated_motion_vectors"},
-    {FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_DILATED_DEPTH,                            L"r_dilated_depth"},
-    {FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_INTERNAL_UPSCALED_COLOR,                  L"r_internal_upscaled_color"},
-    {FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_ACCUMULATION,                             L"r_accumulation"},
-    {FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_LUMA_HISTORY,                             L"r_luma_history" },
-    {FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_RCAS_INPUT,                               L"r_rcas_input"},
-    {FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_LANCZOS_LUT,                              L"r_lanczos_lut"},
-    {FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_SPD_MIPS,                                 L"r_spd_mips"},
-    {FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_DILATED_REACTIVE_MASKS,                   L"r_dilated_reactive_masks"},
-    {FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_NEW_LOCKS,                                L"r_new_locks"},
-    {FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_FARTHEST_DEPTH,                           L"r_farthest_depth"},
-    {FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_FARTHEST_DEPTH_MIP1,                      L"r_farthest_depth_mip1"},
-    {FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_SHADING_CHANGE,                           L"r_shading_change"},
-
-    {FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_CURRENT_LUMA,                             L"r_current_luma"},
-    {FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_PREVIOUS_LUMA,                            L"r_previous_luma"},
-    {FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_LUMA_INSTABILITY,                         L"r_luma_instability"},
+    {FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_INPUT_COLOR,                              "r_input_color_jittered"},
+    {FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_INPUT_OPAQUE_ONLY,                        "r_input_opaque_only"},
+    {FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_INPUT_MOTION_VECTORS,                     "r_input_motion_vectors"},
+    {FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_INPUT_DEPTH,                              "r_input_depth" },
+    {FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_INPUT_EXPOSURE,                           "r_input_exposure"},
+    {FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_FRAME_INFO,                               "r_frame_info"},
+    {FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_INPUT_REACTIVE_MASK,                      "r_reactive_mask"},
+    {FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_INPUT_TRANSPARENCY_AND_COMPOSITION_MASK,  "r_transparency_and_composition_mask"},
+    {FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_RECONSTRUCTED_PREVIOUS_NEAREST_DEPTH,     "r_reconstructed_previous_nearest_depth"},
+    {FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_DILATED_MOTION_VECTORS,                   "r_dilated_motion_vectors"},
+    {FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_DILATED_DEPTH,                            "r_dilated_depth"},
+    {FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_INTERNAL_UPSCALED_COLOR,                  "r_internal_upscaled_color"},
+    {FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_ACCUMULATION,                             "r_accumulation"},
+    {FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_LUMA_HISTORY,                             "r_luma_history" },
+    {FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_RCAS_INPUT,                               "r_rcas_input"},
+    {FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_LANCZOS_LUT,                              "r_lanczos_lut"},
+    {FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_SPD_MIPS,                                 "r_spd_mips"},
+    {FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_DILATED_REACTIVE_MASKS,                   "r_dilated_reactive_masks"},
+    {FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_NEW_LOCKS,                                "r_new_locks"},
+    {FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_FARTHEST_DEPTH,                           "r_farthest_depth"},
+    {FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_FARTHEST_DEPTH_MIP1,                      "r_farthest_depth_mip1"},
+    {FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_SHADING_CHANGE,                           "r_shading_change"},
+
+    {FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_CURRENT_LUMA,                             "r_current_luma"},
+    {FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_PREVIOUS_LUMA,                            "r_previous_luma"},
+    {FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_LUMA_INSTABILITY,                         "r_luma_instability"},
 };
 
 static const ResourceBinding uavTextureBindingTable[] =
 {
-    {FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_RECONSTRUCTED_PREVIOUS_NEAREST_DEPTH,     L"rw_reconstructed_previous_nearest_depth"},
-    {FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_DILATED_MOTION_VECTORS,                   L"rw_dilated_motion_vectors"},
-    {FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_DILATED_DEPTH,                            L"rw_dilated_depth"},
-    {FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_INTERNAL_UPSCALED_COLOR,                  L"rw_internal_upscaled_color"},
-    {FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_ACCUMULATION,                             L"rw_accumulation"},
-    {FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_LUMA_HISTORY,                             L"rw_luma_history"},
-    {FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_UPSCALED_OUTPUT,                          L"rw_upscaled_output"},
-    {FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_DILATED_REACTIVE_MASKS,                   L"rw_dilated_reactive_masks"},
-    {FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_FRAME_INFO,                               L"rw_frame_info"},
-    {FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_SPD_ATOMIC_COUNT,                         L"rw_spd_global_atomic"},
-    {FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_NEW_LOCKS,                                L"rw_new_locks"},
-    {FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_AUTOREACTIVE,                             L"rw_output_autoreactive"},
-    {FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_SHADING_CHANGE,                           L"rw_shading_change"},
-    {FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_FARTHEST_DEPTH,                           L"rw_farthest_depth"},
-    {FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_FARTHEST_DEPTH_MIP1,                      L"rw_farthest_depth_mip1"},
-
-    {FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_CURRENT_LUMA,                             L"rw_current_luma"},
-    {FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_LUMA_INSTABILITY,                         L"rw_luma_instability"},
-
-    {FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_SPD_MIPS_LEVEL_0,                         L"rw_spd_mip0"},
-    {FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_SPD_MIPS_LEVEL_1,                         L"rw_spd_mip1"},
-    {FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_SPD_MIPS_LEVEL_2,                         L"rw_spd_mip2"},
-    {FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_SPD_MIPS_LEVEL_3,                         L"rw_spd_mip3"},
-    {FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_SPD_MIPS_LEVEL_4,                         L"rw_spd_mip4"},
-    {FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_SPD_MIPS_LEVEL_5,                         L"rw_spd_mip5"},
+    {FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_RECONSTRUCTED_PREVIOUS_NEAREST_DEPTH,     "rw_reconstructed_previous_nearest_depth"},
+    {FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_DILATED_MOTION_VECTORS,                   "rw_dilated_motion_vectors"},
+    {FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_DILATED_DEPTH,                            "rw_dilated_depth"},
+    {FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_INTERNAL_UPSCALED_COLOR,                  "rw_internal_upscaled_color"},
+    {FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_ACCUMULATION,                             "rw_accumulation"},
+    {FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_LUMA_HISTORY,                             "rw_luma_history"},
+    {FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_UPSCALED_OUTPUT,                          "rw_upscaled_output"},
+    {FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_DILATED_REACTIVE_MASKS,                   "rw_dilated_reactive_masks"},
+    {FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_FRAME_INFO,                               "rw_frame_info"},
+    {FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_SPD_ATOMIC_COUNT,                         "rw_spd_global_atomic"},
+    {FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_NEW_LOCKS,                                "rw_new_locks"},
+    {FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_AUTOREACTIVE,                             "rw_output_autoreactive"},
+    {FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_SHADING_CHANGE,                           "rw_shading_change"},
+    {FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_FARTHEST_DEPTH,                           "rw_farthest_depth"},
+    {FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_FARTHEST_DEPTH_MIP1,                      "rw_farthest_depth_mip1"},
+
+    {FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_CURRENT_LUMA,                             "rw_current_luma"},
+    {FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_LUMA_INSTABILITY,                         "rw_luma_instability"},
+
+    {FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_SPD_MIPS_LEVEL_0,                         "rw_spd_mip0"},
+    {FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_SPD_MIPS_LEVEL_1,                         "rw_spd_mip1"},
+    {FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_SPD_MIPS_LEVEL_2,                         "rw_spd_mip2"},
+    {FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_SPD_MIPS_LEVEL_3,                         "rw_spd_mip3"},
+    {FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_SPD_MIPS_LEVEL_4,                         "rw_spd_mip4"},
+    {FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_SPD_MIPS_LEVEL_5,                         "rw_spd_mip5"},
 
 
 };
 
 static const ResourceBinding constantBufferBindingTable[] =
 {
-    {FFX_FSR3UPSCALER_CONSTANTBUFFER_IDENTIFIER_FSR3UPSCALER,   L"cbFSR3Upscaler"},
-    {FFX_FSR3UPSCALER_CONSTANTBUFFER_IDENTIFIER_SPD,            L"cbSPD"},
-    {FFX_FSR3UPSCALER_CONSTANTBUFFER_IDENTIFIER_RCAS,           L"cbRCAS"},
-    {FFX_FSR3UPSCALER_CONSTANTBUFFER_IDENTIFIER_GENREACTIVE,    L"cbGenerateReactive"},
+    {FFX_FSR3UPSCALER_CONSTANTBUFFER_IDENTIFIER_FSR3UPSCALER,   "cbFSR3Upscaler"},
+    {FFX_FSR3UPSCALER_CONSTANTBUFFER_IDENTIFIER_SPD,            "cbSPD"},
+    {FFX_FSR3UPSCALER_CONSTANTBUFFER_IDENTIFIER_RCAS,           "cbRCAS"},
+    {FFX_FSR3UPSCALER_CONSTANTBUFFER_IDENTIFIER_GENREACTIVE,    "cbGenerateReactive"},
 };
 
 typedef struct Fsr3UpscalerRcasConstants {
@@ -185,77 +186,77 @@ static void fsr3upscalerDebugCheckDispatch(FfxFsr3UpscalerContext_Private* conte
 {
     if (params->commandList == nullptr)
     {
-        context->contextDescription.fpMessage(FFX_MESSAGE_TYPE_ERROR, L"commandList is null");
+        context->contextDescription.fpMessage(FFX_MESSAGE_TYPE_ERROR, "commandList is null");
     }
 
     if (params->color.resource == nullptr)
     {
-        context->contextDescription.fpMessage(FFX_MESSAGE_TYPE_ERROR, L"color resource is null");
+        context->contextDescription.fpMessage(FFX_MESSAGE_TYPE_ERROR, "color resource is null");
     }
 
     if (params->depth.resource == nullptr)
     {
-        context->contextDescription.fpMessage(FFX_MESSAGE_TYPE_ERROR, L"depth resource is null");
+        context->contextDescription.fpMessage(FFX_MESSAGE_TYPE_ERROR, "depth resource is null");
     }
 
     if (params->motionVectors.resource == nullptr)
     {
-        context->contextDescription.fpMessage(FFX_MESSAGE_TYPE_ERROR, L"motionVectors resource is null");
+        context->contextDescription.fpMessage(FFX_MESSAGE_TYPE_ERROR, "motionVectors resource is null");
     }
 
     if (params->exposure.resource != nullptr)
     {
         if ((context->contextDescription.flags & FFX_FSR3UPSCALER_ENABLE_AUTO_EXPOSURE) == FFX_FSR3UPSCALER_ENABLE_AUTO_EXPOSURE)
         {
-            context->contextDescription.fpMessage(FFX_MESSAGE_TYPE_WARNING, L"exposure resource provided, however auto exposure flag is present");
+            context->contextDescription.fpMessage(FFX_MESSAGE_TYPE_WARNING, "exposure resource provided, however auto exposure flag is present");
         }
     }
 
     if (params->output.resource == nullptr)
     {
-        context->contextDescription.fpMessage(FFX_MESSAGE_TYPE_ERROR, L"output resource is null");
+        context->contextDescription.fpMessage(FFX_MESSAGE_TYPE_ERROR, "output resource is null");
     }
 
     if (fabs(params->jitterOffset.x) > 1.0f || fabs(params->jitterOffset.y) > 1.0f)
     {
-        context->contextDescription.fpMessage(FFX_MESSAGE_TYPE_WARNING, L"jitterOffset contains value outside of expected range [-1.0, 1.0]");
+        context->contextDescription.fpMessage(FFX_MESSAGE_TYPE_WARNING, "jitterOffset contains value outside of expected range [-1.0, 1.0]");
     }
 
     if ((params->motionVectorScale.x > (float)context->contextDescription.maxRenderSize.width) ||
         (params->motionVectorScale.y > (float)context->contextDescription.maxRenderSize.height))
     {
-        context->contextDescription.fpMessage(FFX_MESSAGE_TYPE_WARNING, L"motionVectorScale contains scale value greater than maxRenderSize");
+        context->contextDescription.fpMessage(FFX_MESSAGE_TYPE_WARNING, "motionVectorScale contains scale value greater than maxRenderSize");
     }
     if ((params->motionVectorScale.x == 0.0f) ||
         (params->motionVectorScale.y == 0.0f))
     {
-        context->contextDescription.fpMessage(FFX_MESSAGE_TYPE_WARNING, L"motionVectorScale contains zero scale value");
+        context->contextDescription.fpMessage(FFX_MESSAGE_TYPE_WARNING, "motionVectorScale contains zero scale value");
     }
 
     if ((params->renderSize.width > context->contextDescription.maxRenderSize.width) ||
         (params->renderSize.height > context->contextDescription.maxRenderSize.height))
     {
-        context->contextDescription.fpMessage(FFX_MESSAGE_TYPE_WARNING, L"renderSize is greater than context maxRenderSize");
+        context->contextDescription.fpMessage(FFX_MESSAGE_TYPE_WARNING, "renderSize is greater than context maxRenderSize");
     }
     if ((params->renderSize.width == 0) ||
         (params->renderSize.height == 0))
     {
-        context->contextDescription.fpMessage(FFX_MESSAGE_TYPE_WARNING, L"renderSize contains zero dimension");
+        context->contextDescription.fpMessage(FFX_MESSAGE_TYPE_WARNING, "renderSize contains zero dimension");
     }
 
     if (params->sharpness < 0.0f || params->sharpness > 1.0f)
     {
-        context->contextDescription.fpMessage(FFX_MESSAGE_TYPE_WARNING, L"sharpness contains value outside of expected range [0.0, 1.0]");
+        context->contextDescription.fpMessage(FFX_MESSAGE_TYPE_WARNING, "sharpness contains value outside of expected range [0.0, 1.0]");
     }
 
     if (params->frameTimeDelta < 1.0f)
     {
-        context->contextDescription.fpMessage(FFX_MESSAGE_TYPE_WARNING, L"frameTimeDelta is less than 1.0f - this value should be milliseconds (~16.6f for 60fps)");
+        context->contextDescription.fpMessage(FFX_MESSAGE_TYPE_WARNING, "frameTimeDelta is less than 1.0f - this value should be milliseconds (~16.6f for 60fps)");
     }
 
     if (params->preExposure == 0.0f)
     {
-        context->contextDescription.fpMessage(FFX_MESSAGE_TYPE_ERROR, L"preExposure provided as 0.0f which is invalid");
+        context->contextDescription.fpMessage(FFX_MESSAGE_TYPE_ERROR, "preExposure provided as 0.0f which is invalid");
     }
 
     bool infiniteDepth = (context->contextDescription.flags & FFX_FSR3UPSCALER_ENABLE_DEPTH_INFINITE) == FFX_FSR3UPSCALER_ENABLE_DEPTH_INFINITE;
@@ -266,20 +267,20 @@ static void fsr3upscalerDebugCheckDispatch(FfxFsr3UpscalerContext_Private* conte
         if (params->cameraNear < params->cameraFar)
         {
             context->contextDescription.fpMessage(FFX_MESSAGE_TYPE_WARNING,
-                L"FFX_FSR3UPSCALER_ENABLE_DEPTH_INVERTED flag is present yet cameraNear is less than cameraFar");
+                "FFX_FSR3UPSCALER_ENABLE_DEPTH_INVERTED flag is present yet cameraNear is less than cameraFar");
         }
         if (infiniteDepth)
         {
             if (params->cameraNear != FLT_MAX)
             {
                 context->contextDescription.fpMessage(FFX_MESSAGE_TYPE_WARNING,
-                    L"FFX_FSR3UPSCALER_ENABLE_DEPTH_INFINITE and FFX_FSR3UPSCALER_ENABLE_DEPTH_INVERTED present, yet cameraNear != FLT_MAX");
+                    "FFX_FSR3UPSCALER_ENABLE_DEPTH_INFINITE and FFX_FSR3UPSCALER_ENABLE_DEPTH_INVERTED present, yet cameraNear != FLT_MAX");
             }
         }
         if (params->cameraFar < 0.075f)
         {
             context->contextDescription.fpMessage(FFX_MESSAGE_TYPE_WARNING,
-                L"FFX_FSR3UPSCALER_ENABLE_DEPTH_INVERTED present, cameraFar value is very low which may result in depth separation artefacting");
+                "FFX_FSR3UPSCALER_ENABLE_DEPTH_INVERTED present, cameraFar value is very low which may result in depth separation artefacting");
         }
     }
     else
@@ -287,30 +288,30 @@ static void fsr3upscalerDebugCheckDispatch(FfxFsr3UpscalerContext_Private* conte
         if (params->cameraNear > params->cameraFar)
         {
             context->contextDescription.fpMessage(FFX_MESSAGE_TYPE_WARNING,
-                L"cameraNear is greater than cameraFar in non-inverted-depth context");
+                "cameraNear is greater than cameraFar in non-inverted-depth context");
         }
         if (infiniteDepth)
         {
             if (params->cameraFar != FLT_MAX)
             {
                 context->contextDescription.fpMessage(FFX_MESSAGE_TYPE_WARNING,
-                    L"FFX_FSR3UPSCALER_ENABLE_DEPTH_INFINITE present, yet cameraFar != FLT_MAX");
+                    "FFX_FSR3UPSCALER_ENABLE_DEPTH_INFINITE present, yet cameraFar != FLT_MAX");
             }
         }
         if (params->cameraNear < 0.075f)
         {
             context->contextDescription.fpMessage(FFX_MESSAGE_TYPE_WARNING,
-                L"cameraNear value is very low which may result in depth separation artefacting");
+                "cameraNear value is very low which may result in depth separation artefacting");
         }
     }
 
     if (params->cameraFovAngleVertical <= 0.0f)
     {
-        context->contextDescription.fpMessage(FFX_MESSAGE_TYPE_ERROR, L"cameraFovAngleVertical is 0.0f - this value should be > 0.0f");
+        context->contextDescription.fpMessage(FFX_MESSAGE_TYPE_ERROR, "cameraFovAngleVertical is 0.0f - this value should be > 0.0f");
     }
     if (params->cameraFovAngleVertical > FFX_PI)
     {
-        context->contextDescription.fpMessage(FFX_MESSAGE_TYPE_ERROR, L"cameraFovAngleVertical is greater than 180 degrees/PI");
+        context->contextDescription.fpMessage(FFX_MESSAGE_TYPE_ERROR, "cameraFovAngleVertical is greater than 180 degrees/PI");
     }
 }
 
@@ -319,12 +320,12 @@ static FfxErrorCode patchResourceBindings(FfxPipelineState* inoutPipeline)
     for (uint32_t srvIndex = 0; srvIndex < inoutPipeline->srvTextureCount; ++srvIndex)
     {
         int32_t mapIndex = 0;
-        for (mapIndex = 0; mapIndex < _countof(srvTextureBindingTable); ++mapIndex)
+        for (mapIndex = 0; mapIndex < std::size(srvTextureBindingTable); ++mapIndex)
         {
-            if (0 == wcscmp(srvTextureBindingTable[mapIndex].name, inoutPipeline->srvTextureBindings[srvIndex].name))
+            if (0 == strcmp(srvTextureBindingTable[mapIndex].name, inoutPipeline->srvTextureBindings[srvIndex].name))
                 break;
         }
-        if (mapIndex == _countof(srvTextureBindingTable))
+        if (mapIndex == std::size(srvTextureBindingTable))
             return FFX_ERROR_INVALID_ARGUMENT;
 
         inoutPipeline->srvTextureBindings[srvIndex].resourceIdentifier = srvTextureBindingTable[mapIndex].index;
@@ -333,12 +334,12 @@ static FfxErrorCode patchResourceBindings(FfxPipelineState* inoutPipeline)
     for (uint32_t uavIndex = 0; uavIndex < inoutPipeline->uavTextureCount; ++uavIndex)
     {
         int32_t mapIndex = 0;
-        for (mapIndex = 0; mapIndex < _countof(uavTextureBindingTable); ++mapIndex)
+        for (mapIndex = 0; mapIndex < std::size(uavTextureBindingTable); ++mapIndex)
         {
-            if (0 == wcscmp(uavTextureBindingTable[mapIndex].name, inoutPipeline->uavTextureBindings[uavIndex].name))
+            if (0 == strcmp(uavTextureBindingTable[mapIndex].name, inoutPipeline->uavTextureBindings[uavIndex].name))
                 break;
         }
-        if (mapIndex == _countof(uavTextureBindingTable))
+        if (mapIndex == std::size(uavTextureBindingTable))
             return FFX_ERROR_INVALID_ARGUMENT;
 
         inoutPipeline->uavTextureBindings[uavIndex].resourceIdentifier = uavTextureBindingTable[mapIndex].index;
@@ -347,12 +348,12 @@ static FfxErrorCode patchResourceBindings(FfxPipelineState* inoutPipeline)
     for (uint32_t cbIndex = 0; cbIndex < inoutPipeline->constCount; ++cbIndex)
     {
         int32_t mapIndex = 0;
-        for (mapIndex = 0; mapIndex < _countof(constantBufferBindingTable); ++mapIndex)
+        for (mapIndex = 0; mapIndex < std::size(constantBufferBindingTable); ++mapIndex)
         {
-            if (0 == wcscmp(constantBufferBindingTable[mapIndex].name, inoutPipeline->constantBufferBindings[cbIndex].name))
+            if (0 == strcmp(constantBufferBindingTable[mapIndex].name, inoutPipeline->constantBufferBindings[cbIndex].name))
                 break;
         }
-        if (mapIndex == _countof(constantBufferBindingTable))
+        if (mapIndex == std::size(constantBufferBindingTable))
             return FFX_ERROR_INVALID_ARGUMENT;
 
         inoutPipeline->constantBufferBindings[cbIndex].resourceIdentifier = constantBufferBindingTable[mapIndex].index;
@@ -427,57 +428,57 @@ static FfxErrorCode createPipelineStates(FfxFsr3UpscalerContext_Private* context
     uint32_t contextFlags = context->contextDescription.flags;
 
     // Set up pipeline descriptor (basically RootSignature and binding)
-    wcscpy_s(pipelineDescription.name, L"FSR3-LUMA-PYRAMID");
+    strcpy(pipelineDescription.name, "FSR3-LUMA-PYRAMID");
     FFX_VALIDATE(context->contextDescription.backendInterface.fpCreatePipeline(&context->contextDescription.backendInterface, FFX_EFFECT_FSR3UPSCALER, FFX_FSR3UPSCALER_PASS_LUMA_PYRAMID,
         getPipelinePermutationFlags(contextFlags, FFX_FSR3UPSCALER_PASS_LUMA_PYRAMID, supportedFP16, canForceWave64, useLut),
         &pipelineDescription, context->effectContextId, &context->pipelineLumaPyramid));
-    wcscpy_s(pipelineDescription.name, L"FSR3-RCAS");
+    strcpy(pipelineDescription.name, "FSR3-RCAS");
     FFX_VALIDATE(context->contextDescription.backendInterface.fpCreatePipeline(&context->contextDescription.backendInterface, FFX_EFFECT_FSR3UPSCALER, FFX_FSR3UPSCALER_PASS_RCAS,
         getPipelinePermutationFlags(contextFlags, FFX_FSR3UPSCALER_PASS_RCAS, supportedFP16, canForceWave64, useLut),
         &pipelineDescription, context->effectContextId, &context->pipelineRCAS));
-    wcscpy_s(pipelineDescription.name, L"FSR3-GEN_REACTIVE");
+    strcpy(pipelineDescription.name, "FSR3-GEN_REACTIVE");
     FFX_VALIDATE(context->contextDescription.backendInterface.fpCreatePipeline(&context->contextDescription.backendInterface, FFX_EFFECT_FSR3UPSCALER, FFX_FSR3UPSCALER_PASS_GENERATE_REACTIVE,
         getPipelinePermutationFlags(contextFlags, FFX_FSR3UPSCALER_PASS_GENERATE_REACTIVE, supportedFP16, canForceWave64, useLut),
         &pipelineDescription, context->effectContextId, &context->pipelineGenerateReactive));
 
     pipelineDescription.rootConstantBufferCount = 1;
 
-    wcscpy_s(pipelineDescription.name, L"FSR3-PREPARE-INPUTS");
+    strcpy(pipelineDescription.name, "FSR3-PREPARE-INPUTS");
     FFX_VALIDATE(context->contextDescription.backendInterface.fpCreatePipeline(&context->contextDescription.backendInterface, FFX_EFFECT_FSR3UPSCALER, FFX_FSR3UPSCALER_PASS_PREPARE_INPUTS,
         getPipelinePermutationFlags(contextFlags, FFX_FSR3UPSCALER_PASS_PREPARE_INPUTS, supportedFP16, canForceWave64, useLut),
         &pipelineDescription, context->effectContextId, &context->pipelinePrepareInputs));
 
-    wcscpy_s(pipelineDescription.name, L"FSR3-PREPARE-REACTIVITY");
+    strcpy(pipelineDescription.name, "FSR3-PREPARE-REACTIVITY");
     FFX_VALIDATE(context->contextDescription.backendInterface.fpCreatePipeline(&context->contextDescription.backendInterface, FFX_EFFECT_FSR3UPSCALER, FFX_FSR3UPSCALER_PASS_PREPARE_REACTIVITY,
         getPipelinePermutationFlags(contextFlags, FFX_FSR3UPSCALER_PASS_PREPARE_REACTIVITY, supportedFP16, canForceWave64, useLut),
         &pipelineDescription, context->effectContextId, &context->pipelinePrepareReactivity));
     
-    wcscpy_s(pipelineDescription.name, L"FSR3-SHADING-CHANGE");
+    strcpy(pipelineDescription.name, "FSR3-SHADING-CHANGE");
     FFX_VALIDATE(context->contextDescription.backendInterface.fpCreatePipeline(&context->contextDescription.backendInterface, FFX_EFFECT_FSR3UPSCALER, FFX_FSR3UPSCALER_PASS_SHADING_CHANGE,
         getPipelinePermutationFlags(contextFlags, FFX_FSR3UPSCALER_PASS_SHADING_CHANGE, supportedFP16, canForceWave64, useLut),
         &pipelineDescription, context->effectContextId, &context->pipelineShadingChange));
     
-    wcscpy_s(pipelineDescription.name, L"FSR3-ACCUMULATE");
+    strcpy(pipelineDescription.name, "FSR3-ACCUMULATE");
     FFX_VALIDATE(context->contextDescription.backendInterface.fpCreatePipeline(&context->contextDescription.backendInterface, FFX_EFFECT_FSR3UPSCALER, FFX_FSR3UPSCALER_PASS_ACCUMULATE,
         getPipelinePermutationFlags(contextFlags, FFX_FSR3UPSCALER_PASS_ACCUMULATE, supportedFP16, canForceWave64, useLut),
         &pipelineDescription, context->effectContextId, &context->pipelineAccumulate));
     
-    wcscpy_s(pipelineDescription.name, L"FSR3-ACCUM_SHARP");
+    strcpy(pipelineDescription.name, "FSR3-ACCUM_SHARP");
     FFX_VALIDATE(context->contextDescription.backendInterface.fpCreatePipeline(&context->contextDescription.backendInterface, FFX_EFFECT_FSR3UPSCALER, FFX_FSR3UPSCALER_PASS_ACCUMULATE_SHARPEN,
         getPipelinePermutationFlags(contextFlags, FFX_FSR3UPSCALER_PASS_ACCUMULATE_SHARPEN, supportedFP16, canForceWave64, useLut),
         &pipelineDescription, context->effectContextId, &context->pipelineAccumulateSharpen));
 
-    wcscpy_s(pipelineDescription.name, L"FSR3-SHADING-CHANGE-PYRAMID");
+    strcpy(pipelineDescription.name, "FSR3-SHADING-CHANGE-PYRAMID");
     FFX_VALIDATE(context->contextDescription.backendInterface.fpCreatePipeline(&context->contextDescription.backendInterface, FFX_EFFECT_FSR3UPSCALER, FFX_FSR3UPSCALER_PASS_SHADING_CHANGE_PYRAMID,
         getPipelinePermutationFlags(contextFlags, FFX_FSR3UPSCALER_PASS_SHADING_CHANGE_PYRAMID, supportedFP16, canForceWave64, useLut),
         &pipelineDescription, context->effectContextId, &context->pipelineShadingChangePyramid));
 
-    wcscpy_s(pipelineDescription.name, L"FSR3-LUMA-INSTABILITY");
+    strcpy(pipelineDescription.name, "FSR3-LUMA-INSTABILITY");
     FFX_VALIDATE(context->contextDescription.backendInterface.fpCreatePipeline(&context->contextDescription.backendInterface, FFX_EFFECT_FSR3UPSCALER, FFX_FSR3UPSCALER_PASS_LUMA_INSTABILITY,
         getPipelinePermutationFlags(contextFlags, FFX_FSR3UPSCALER_PASS_LUMA_INSTABILITY, supportedFP16, canForceWave64, useLut),
         &pipelineDescription, context->effectContextId, &context->pipelineLumaInstability));
 
-    wcscpy_s(pipelineDescription.name, L"FSR3-DEBUG-VIEW");
+    strcpy(pipelineDescription.name, "FSR3-DEBUG-VIEW");
     FFX_VALIDATE(context->contextDescription.backendInterface.fpCreatePipeline(&context->contextDescription.backendInterface, FFX_EFFECT_FSR3UPSCALER, FFX_FSR3UPSCALER_PASS_DEBUG_VIEW,
         getPipelinePermutationFlags(contextFlags, FFX_FSR3UPSCALER_PASS_DEBUG_VIEW, supportedFP16, canForceWave64, useLut),
         &pipelineDescription, context->effectContextId, &context->pipelineDebugView));
@@ -552,61 +553,61 @@ static FfxErrorCode fsr3upscalerCreate(FfxFsr3UpscalerContext_Private* context,
     // declare internal resources needed
     const FfxInternalResourceDescription internalSurfaceDesc[] = {
 
-        {   FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_ACCUMULATION_1, L"FSR3UPSCALER_Accumulation1", FFX_RESOURCE_TYPE_TEXTURE2D, (FfxResourceUsage)(FFX_RESOURCE_USAGE_RENDERTARGET | FFX_RESOURCE_USAGE_UAV),
+        {   FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_ACCUMULATION_1, "FSR3UPSCALER_Accumulation1", FFX_RESOURCE_TYPE_TEXTURE2D, (FfxResourceUsage)(FFX_RESOURCE_USAGE_RENDERTARGET | FFX_RESOURCE_USAGE_UAV),
             FFX_SURFACE_FORMAT_R8_UNORM, contextDescription->maxRenderSize.width, contextDescription->maxRenderSize.height, 1, FFX_RESOURCE_FLAGS_NONE, {FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED} },
 
-        {   FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_ACCUMULATION_2, L"FSR3UPSCALER_Accumulation2", FFX_RESOURCE_TYPE_TEXTURE2D, (FfxResourceUsage)(FFX_RESOURCE_USAGE_RENDERTARGET | FFX_RESOURCE_USAGE_UAV),
+        {   FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_ACCUMULATION_2, "FSR3UPSCALER_Accumulation2", FFX_RESOURCE_TYPE_TEXTURE2D, (FfxResourceUsage)(FFX_RESOURCE_USAGE_RENDERTARGET | FFX_RESOURCE_USAGE_UAV),
             FFX_SURFACE_FORMAT_R8_UNORM, contextDescription->maxRenderSize.width, contextDescription->maxRenderSize.height, 1, FFX_RESOURCE_FLAGS_NONE, {FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED} },
 
-        {   FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_LUMA_1, L"FSR3UPSCALER_Luma1", FFX_RESOURCE_TYPE_TEXTURE2D, (FfxResourceUsage)(FFX_RESOURCE_USAGE_RENDERTARGET | FFX_RESOURCE_USAGE_UAV),
+        {   FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_LUMA_1, "FSR3UPSCALER_Luma1", FFX_RESOURCE_TYPE_TEXTURE2D, (FfxResourceUsage)(FFX_RESOURCE_USAGE_RENDERTARGET | FFX_RESOURCE_USAGE_UAV),
             FFX_SURFACE_FORMAT_R16_FLOAT, contextDescription->maxRenderSize.width, contextDescription->maxRenderSize.height, 1, FFX_RESOURCE_FLAGS_NONE, {FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED} },
 
-        {   FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_LUMA_2, L"FSR3UPSCALER_Luma2", FFX_RESOURCE_TYPE_TEXTURE2D, (FfxResourceUsage)(FFX_RESOURCE_USAGE_RENDERTARGET | FFX_RESOURCE_USAGE_UAV),
+        {   FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_LUMA_2, "FSR3UPSCALER_Luma2", FFX_RESOURCE_TYPE_TEXTURE2D, (FfxResourceUsage)(FFX_RESOURCE_USAGE_RENDERTARGET | FFX_RESOURCE_USAGE_UAV),
             FFX_SURFACE_FORMAT_R16_FLOAT, contextDescription->maxRenderSize.width, contextDescription->maxRenderSize.height, 1, FFX_RESOURCE_FLAGS_NONE, {FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED} },
 
-        {   FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_INTERMEDIATE_FP16x1, L"FSR3UPSCALER_IntermediateFp16x1", FFX_RESOURCE_TYPE_TEXTURE2D, (FfxResourceUsage)(FFX_RESOURCE_USAGE_UAV | FFX_RESOURCE_USAGE_DCC_RENDERTARGET),
+        {   FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_INTERMEDIATE_FP16x1, "FSR3UPSCALER_IntermediateFp16x1", FFX_RESOURCE_TYPE_TEXTURE2D, (FfxResourceUsage)(FFX_RESOURCE_USAGE_UAV | FFX_RESOURCE_USAGE_DCC_RENDERTARGET),
             FFX_SURFACE_FORMAT_R16_FLOAT, contextDescription->maxRenderSize.width, contextDescription->maxRenderSize.height, 1, FFX_RESOURCE_FLAGS_ALIASABLE, {FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED} },
 
-        {   FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_SHADING_CHANGE, L"FSR3UPSCALER_ShadingChange", FFX_RESOURCE_TYPE_TEXTURE2D, (FfxResourceUsage)(FFX_RESOURCE_USAGE_UAV | FFX_RESOURCE_USAGE_DCC_RENDERTARGET),
+        {   FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_SHADING_CHANGE, "FSR3UPSCALER_ShadingChange", FFX_RESOURCE_TYPE_TEXTURE2D, (FfxResourceUsage)(FFX_RESOURCE_USAGE_UAV | FFX_RESOURCE_USAGE_DCC_RENDERTARGET),
             FFX_SURFACE_FORMAT_R8_UNORM, maxRenderSizeDiv2.width, maxRenderSizeDiv2.height, 1, FFX_RESOURCE_FLAGS_ALIASABLE, {FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED} },
 
-        {   FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_NEW_LOCKS, L"FSR3UPSCALER_NewLocks", FFX_RESOURCE_TYPE_TEXTURE2D, (FfxResourceUsage)(FFX_RESOURCE_USAGE_UAV),
+        {   FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_NEW_LOCKS, "FSR3UPSCALER_NewLocks", FFX_RESOURCE_TYPE_TEXTURE2D, (FfxResourceUsage)(FFX_RESOURCE_USAGE_UAV),
             FFX_SURFACE_FORMAT_R8_UNORM, contextDescription->maxUpscaleSize.width, contextDescription->maxUpscaleSize.height, 1, FFX_RESOURCE_FLAGS_ALIASABLE, {FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED} },
 
-        {   FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_INTERNAL_UPSCALED_COLOR_1, L"FSR3UPSCALER_InternalUpscaled1", FFX_RESOURCE_TYPE_TEXTURE2D, (FfxResourceUsage)(FFX_RESOURCE_USAGE_RENDERTARGET | FFX_RESOURCE_USAGE_UAV | FFX_RESOURCE_USAGE_DCC_RENDERTARGET),
+        {   FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_INTERNAL_UPSCALED_COLOR_1, "FSR3UPSCALER_InternalUpscaled1", FFX_RESOURCE_TYPE_TEXTURE2D, (FfxResourceUsage)(FFX_RESOURCE_USAGE_RENDERTARGET | FFX_RESOURCE_USAGE_UAV | FFX_RESOURCE_USAGE_DCC_RENDERTARGET),
             FFX_SURFACE_FORMAT_R16G16B16A16_FLOAT, contextDescription->maxUpscaleSize.width, contextDescription->maxUpscaleSize.height, 1, FFX_RESOURCE_FLAGS_NONE, {FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED} },
 
-        {   FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_INTERNAL_UPSCALED_COLOR_2, L"FSR3UPSCALER_InternalUpscaled2", FFX_RESOURCE_TYPE_TEXTURE2D, (FfxResourceUsage)(FFX_RESOURCE_USAGE_RENDERTARGET | FFX_RESOURCE_USAGE_UAV | FFX_RESOURCE_USAGE_DCC_RENDERTARGET),
+        {   FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_INTERNAL_UPSCALED_COLOR_2, "FSR3UPSCALER_InternalUpscaled2", FFX_RESOURCE_TYPE_TEXTURE2D, (FfxResourceUsage)(FFX_RESOURCE_USAGE_RENDERTARGET | FFX_RESOURCE_USAGE_UAV | FFX_RESOURCE_USAGE_DCC_RENDERTARGET),
             FFX_SURFACE_FORMAT_R16G16B16A16_FLOAT, contextDescription->maxUpscaleSize.width, contextDescription->maxUpscaleSize.height, 1, FFX_RESOURCE_FLAGS_NONE, {FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED} },
 
-        {   FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_SPD_MIPS, L"FSR3UPSCALER_SpdMips", FFX_RESOURCE_TYPE_TEXTURE2D, FFX_RESOURCE_USAGE_UAV,
+        {   FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_SPD_MIPS, "FSR3UPSCALER_SpdMips", FFX_RESOURCE_TYPE_TEXTURE2D, FFX_RESOURCE_USAGE_UAV,
             FFX_SURFACE_FORMAT_R16G16_FLOAT, maxRenderSizeDiv2.width, maxRenderSizeDiv2.height, 0, FFX_RESOURCE_FLAGS_ALIASABLE, {FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED} },
 
-        {   FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_FARTHEST_DEPTH_MIP1, L"FSR3UPSCALER_FarthestDepthMip1", FFX_RESOURCE_TYPE_TEXTURE2D, FFX_RESOURCE_USAGE_UAV,
+        {   FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_FARTHEST_DEPTH_MIP1, "FSR3UPSCALER_FarthestDepthMip1", FFX_RESOURCE_TYPE_TEXTURE2D, FFX_RESOURCE_USAGE_UAV,
             FFX_SURFACE_FORMAT_R16_FLOAT, maxRenderSizeDiv2.width, maxRenderSizeDiv2.height, 1, FFX_RESOURCE_FLAGS_ALIASABLE, {FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED} },
 
-        {   FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_LUMA_HISTORY_1, L"FSR3UPSCALER_LumaHistory1", FFX_RESOURCE_TYPE_TEXTURE2D, (FfxResourceUsage)(FFX_RESOURCE_USAGE_RENDERTARGET | FFX_RESOURCE_USAGE_UAV),
+        {   FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_LUMA_HISTORY_1, "FSR3UPSCALER_LumaHistory1", FFX_RESOURCE_TYPE_TEXTURE2D, (FfxResourceUsage)(FFX_RESOURCE_USAGE_RENDERTARGET | FFX_RESOURCE_USAGE_UAV),
             FFX_SURFACE_FORMAT_R16G16B16A16_FLOAT, contextDescription->maxRenderSize.width, contextDescription->maxRenderSize.height, 1, FFX_RESOURCE_FLAGS_NONE, {FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED} },
 
-        {   FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_LUMA_HISTORY_2, L"FSR3UPSCALER_LumaHistory2", FFX_RESOURCE_TYPE_TEXTURE2D, (FfxResourceUsage)(FFX_RESOURCE_USAGE_RENDERTARGET | FFX_RESOURCE_USAGE_UAV),
+        {   FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_LUMA_HISTORY_2, "FSR3UPSCALER_LumaHistory2", FFX_RESOURCE_TYPE_TEXTURE2D, (FfxResourceUsage)(FFX_RESOURCE_USAGE_RENDERTARGET | FFX_RESOURCE_USAGE_UAV),
             FFX_SURFACE_FORMAT_R16G16B16A16_FLOAT, contextDescription->maxRenderSize.width, contextDescription->maxRenderSize.height, 1, FFX_RESOURCE_FLAGS_NONE, {FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED} },
 
-        {   FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_SPD_ATOMIC_COUNT, L"FSR3UPSCALER_SpdAtomicCounter", FFX_RESOURCE_TYPE_TEXTURE2D, (FfxResourceUsage)(FFX_RESOURCE_USAGE_UAV),
+        {   FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_SPD_ATOMIC_COUNT, "FSR3UPSCALER_SpdAtomicCounter", FFX_RESOURCE_TYPE_TEXTURE2D, (FfxResourceUsage)(FFX_RESOURCE_USAGE_UAV),
             FFX_SURFACE_FORMAT_R32_UINT, 1, 1, 1, FFX_RESOURCE_FLAGS_NONE, FfxResourceInitData::FfxResourceInitValue(sizeof(atomicInitData), 0) },
 
-        {   FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_DILATED_REACTIVE_MASKS, L"FSR3UPSCALER_DilatedReactiveMasks", FFX_RESOURCE_TYPE_TEXTURE2D, (FfxResourceUsage)(FFX_RESOURCE_USAGE_UAV | FFX_RESOURCE_USAGE_DCC_RENDERTARGET),
+        {   FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_DILATED_REACTIVE_MASKS, "FSR3UPSCALER_DilatedReactiveMasks", FFX_RESOURCE_TYPE_TEXTURE2D, (FfxResourceUsage)(FFX_RESOURCE_USAGE_UAV | FFX_RESOURCE_USAGE_DCC_RENDERTARGET),
             FFX_SURFACE_FORMAT_R8G8B8A8_UNORM, contextDescription->maxRenderSize.width, contextDescription->maxRenderSize.height, 1, FFX_RESOURCE_FLAGS_ALIASABLE, {FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED} },
 
-        {   FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_LANCZOS_LUT, L"FSR3UPSCALER_LanczosLutData", FFX_RESOURCE_TYPE_TEXTURE2D, FFX_RESOURCE_USAGE_READ_ONLY,
+        {   FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_LANCZOS_LUT, "FSR3UPSCALER_LanczosLutData", FFX_RESOURCE_TYPE_TEXTURE2D, FFX_RESOURCE_USAGE_READ_ONLY,
             FFX_SURFACE_FORMAT_R16_SNORM, lanczos2LutWidth, 1, 1, FFX_RESOURCE_FLAGS_NONE, {FFX_RESOURCE_INIT_DATA_TYPE_BUFFER, sizeof(lanczos2Weights), lanczos2Weights} },
 
-        {   FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_INTERNAL_DEFAULT_REACTIVITY, L"FSR3UPSCALER_DefaultReactiviyMask", FFX_RESOURCE_TYPE_TEXTURE2D, FFX_RESOURCE_USAGE_READ_ONLY,
+        {   FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_INTERNAL_DEFAULT_REACTIVITY, "FSR3UPSCALER_DefaultReactiviyMask", FFX_RESOURCE_TYPE_TEXTURE2D, FFX_RESOURCE_USAGE_READ_ONLY,
             FFX_SURFACE_FORMAT_R8_UNORM, 1, 1, 1, FFX_RESOURCE_FLAGS_NONE, FfxResourceInitData::FfxResourceInitValue(sizeof(defaultReactiveMaskData), defaultReactiveMaskData) },
 
-        {   FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_INTERNAL_DEFAULT_EXPOSURE, L"FSR3UPSCALER_DefaultExposure", FFX_RESOURCE_TYPE_TEXTURE2D, FFX_RESOURCE_USAGE_READ_ONLY,
+        {   FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_INTERNAL_DEFAULT_EXPOSURE, "FSR3UPSCALER_DefaultExposure", FFX_RESOURCE_TYPE_TEXTURE2D, FFX_RESOURCE_USAGE_READ_ONLY,
             FFX_SURFACE_FORMAT_R32G32_FLOAT, 1, 1, 1, FFX_RESOURCE_FLAGS_NONE, FfxResourceInitData::FfxResourceInitBuffer(sizeof(defaultExposure), defaultExposure) },
 
-        {   FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_FRAME_INFO, L"FSR3UPSCALER_FrameInfo", FFX_RESOURCE_TYPE_TEXTURE2D, FFX_RESOURCE_USAGE_UAV,
+        {   FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_FRAME_INFO, "FSR3UPSCALER_FrameInfo", FFX_RESOURCE_TYPE_TEXTURE2D, FFX_RESOURCE_USAGE_UAV,
             FFX_SURFACE_FORMAT_R32G32B32A32_FLOAT, 1, 1, 1, FFX_RESOURCE_FLAGS_NONE, {FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED} },
 
     };
@@ -762,7 +763,7 @@ static void scheduleDispatch(FfxFsr3UpscalerContext_Private* context, const FfxF
         const FfxResourceInternal currentResource = context->srvResources[currentResourceId];
         jobDescriptor.srvTextures[currentShaderResourceViewIndex].resource = currentResource;
 #ifdef FFX_DEBUG
-        wcscpy_s(jobDescriptor.srvTextures[currentShaderResourceViewIndex].name, pipeline->srvTextureBindings[currentShaderResourceViewIndex].name);
+        strcpy(jobDescriptor.srvTextures[currentShaderResourceViewIndex].name, pipeline->srvTextureBindings[currentShaderResourceViewIndex].name);
 #endif
     }
 
@@ -770,7 +771,7 @@ static void scheduleDispatch(FfxFsr3UpscalerContext_Private* context, const FfxF
 
         const uint32_t currentResourceId = pipeline->uavTextureBindings[currentUnorderedAccessViewIndex].resourceIdentifier;
 #ifdef FFX_DEBUG
-        wcscpy_s(jobDescriptor.uavTextures[currentUnorderedAccessViewIndex].name, pipeline->uavTextureBindings[currentUnorderedAccessViewIndex].name);
+        strcpy(jobDescriptor.uavTextures[currentUnorderedAccessViewIndex].name, pipeline->uavTextureBindings[currentUnorderedAccessViewIndex].name);
 #endif
 
         if (currentResourceId >= FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_SPD_MIPS_LEVEL_0 && currentResourceId <= FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_SPD_MIPS_LEVEL_5)
@@ -794,13 +795,13 @@ static void scheduleDispatch(FfxFsr3UpscalerContext_Private* context, const FfxF
 
     for (uint32_t currentRootConstantIndex = 0; currentRootConstantIndex < pipeline->constCount; ++currentRootConstantIndex) {
 #ifdef FFX_DEBUG
-        wcscpy_s( jobDescriptor.cbNames[currentRootConstantIndex], pipeline->constantBufferBindings[currentRootConstantIndex].name);
+        strcpy( jobDescriptor.cbNames[currentRootConstantIndex], pipeline->constantBufferBindings[currentRootConstantIndex].name);
 #endif
         jobDescriptor.cbs[currentRootConstantIndex] = context->constantBuffers[pipeline->constantBufferBindings[currentRootConstantIndex].resourceIdentifier];
     }
 
     FfxGpuJobDescription dispatchJob = { FFX_GPU_JOB_COMPUTE };
-    wcscpy_s(dispatchJob.jobLabel, pipeline->name);
+    strcpy(dispatchJob.jobLabel, pipeline->name);
     dispatchJob.computeJobDescriptor = jobDescriptor;
 
     context->contextDescription.backendInterface.fpScheduleGpuJob(&context->contextDescription.backendInterface, &dispatchJob);
@@ -817,11 +818,11 @@ FFX_API FfxErrorCode ffxFsr3UpscalerGetSharedResourceDescriptions(FfxFsr3Upscale
 
     FfxFsr3UpscalerContext_Private* contextPrivate = (FfxFsr3UpscalerContext_Private*)(context);
     SharedResources->dilatedDepth = { FFX_HEAP_TYPE_DEFAULT, { FFX_RESOURCE_TYPE_TEXTURE2D, FFX_SURFACE_FORMAT_R32_FLOAT, contextPrivate->contextDescription.maxRenderSize.width, contextPrivate->contextDescription.maxRenderSize.height, 1, 1, FFX_RESOURCE_FLAGS_NONE, (FfxResourceUsage)(FFX_RESOURCE_USAGE_RENDERTARGET | FFX_RESOURCE_USAGE_UAV | FFX_RESOURCE_USAGE_DCC_RENDERTARGET) },
-        FFX_RESOURCE_STATE_UNORDERED_ACCESS, L"FSR3UPSCALER_DilatedDepth", FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_DILATED_DEPTH, {FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED} };
+        FFX_RESOURCE_STATE_UNORDERED_ACCESS, "FSR3UPSCALER_DilatedDepth", FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_DILATED_DEPTH, {FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED} };
     SharedResources->dilatedMotionVectors = { FFX_HEAP_TYPE_DEFAULT, { FFX_RESOURCE_TYPE_TEXTURE2D, FFX_SURFACE_FORMAT_R16G16_FLOAT, contextPrivate->contextDescription.maxRenderSize.width, contextPrivate->contextDescription.maxRenderSize.height, 1, 1, FFX_RESOURCE_FLAGS_NONE, (FfxResourceUsage)(FFX_RESOURCE_USAGE_RENDERTARGET | FFX_RESOURCE_USAGE_UAV | FFX_RESOURCE_USAGE_DCC_RENDERTARGET) },
-            FFX_RESOURCE_STATE_UNORDERED_ACCESS, L"FSR3UPSCALER_DilatedVelocity", FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_DILATED_MOTION_VECTORS, {FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED} };
+            FFX_RESOURCE_STATE_UNORDERED_ACCESS, "FSR3UPSCALER_DilatedVelocity", FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_DILATED_MOTION_VECTORS, {FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED} };
     SharedResources->reconstructedPrevNearestDepth = { FFX_HEAP_TYPE_DEFAULT, { FFX_RESOURCE_TYPE_TEXTURE2D, FFX_SURFACE_FORMAT_R32_UINT, contextPrivate->contextDescription.maxRenderSize.width, contextPrivate->contextDescription.maxRenderSize.height, 1, 1, FFX_RESOURCE_FLAGS_NONE, (FfxResourceUsage)(FFX_RESOURCE_USAGE_UAV) },
-            FFX_RESOURCE_STATE_UNORDERED_ACCESS, L"FSR3UPSCALER_ReconstructedPrevNearestDepth", FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_RECONSTRUCTED_PREVIOUS_NEAREST_DEPTH, {FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED} };
+            FFX_RESOURCE_STATE_UNORDERED_ACCESS, "FSR3UPSCALER_ReconstructedPrevNearestDepth", FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_RECONSTRUCTED_PREVIOUS_NEAREST_DEPTH, {FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED} };
 
     return FFX_OK;
 }
@@ -844,17 +845,17 @@ static FfxErrorCode fsr3upscalerDispatch(FfxFsr3UpscalerContext_Private* context
         const float clearValuesToZeroFloat[]{ 0.f, 0.f, 0.f, 0.f };
         memcpy(clearJob.clearJobDescriptor.color, clearValuesToZeroFloat, 4 * sizeof(float));
 
-        wcscpy_s(clearJob.jobLabel, L"Clear Accumulation 1");
+        strcpy(clearJob.jobLabel, "Clear Accumulation 1");
         clearJob.clearJobDescriptor.target = context->srvResources[FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_ACCUMULATION_1];
         context->contextDescription.backendInterface.fpScheduleGpuJob(&context->contextDescription.backendInterface, &clearJob);
-        wcscpy_s(clearJob.jobLabel, L"Clear Accumulation 2");
+        strcpy(clearJob.jobLabel, "Clear Accumulation 2");
         clearJob.clearJobDescriptor.target = context->srvResources[FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_ACCUMULATION_2];
         context->contextDescription.backendInterface.fpScheduleGpuJob(&context->contextDescription.backendInterface, &clearJob);
 
-        wcscpy_s(clearJob.jobLabel, L"Clear Temporal Luma 1");
+        strcpy(clearJob.jobLabel, "Clear Temporal Luma 1");
         clearJob.clearJobDescriptor.target = context->srvResources[FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_LUMA_1];
         context->contextDescription.backendInterface.fpScheduleGpuJob(&context->contextDescription.backendInterface, &clearJob);
-        wcscpy_s(clearJob.jobLabel, L"Clear Temporal Luma 2");
+        strcpy(clearJob.jobLabel, "Clear Temporal Luma 2");
         clearJob.clearJobDescriptor.target = context->srvResources[FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_LUMA_2];
         context->contextDescription.backendInterface.fpScheduleGpuJob(&context->contextDescription.backendInterface, &clearJob);
     }
@@ -1039,14 +1040,14 @@ static FfxErrorCode fsr3upscalerDispatch(FfxFsr3UpscalerContext_Private* context
     if (resetAccumulation) {
 
         FfxGpuJobDescription clearJob = { FFX_GPU_JOB_CLEAR_FLOAT };
-        wcscpy_s(clearJob.jobLabel, L"Clear Resource");
+        strcpy(clearJob.jobLabel, "Clear Resource");
 
         const float clearValuesToZeroFloat[]{ 0.f, 0.f, 0.f, 0.f };
         memcpy(clearJob.clearJobDescriptor.color, clearValuesToZeroFloat, 4 * sizeof(float));
         clearJob.clearJobDescriptor.target = context->srvResources[accumulationSrvResourceIndex];
         context->contextDescription.backendInterface.fpScheduleGpuJob(&context->contextDescription.backendInterface, &clearJob);
 
-        wcscpy_s(clearJob.jobLabel, L"Clear Scene Luminance");
+        strcpy(clearJob.jobLabel, "Clear Scene Luminance");
         clearJob.clearJobDescriptor.target = context->srvResources[FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_SPD_MIPS];
         context->contextDescription.backendInterface.fpScheduleGpuJob(&context->contextDescription.backendInterface, &clearJob);
 
@@ -1054,7 +1055,7 @@ static FfxErrorCode fsr3upscalerDispatch(FfxFsr3UpscalerContext_Private* context
         {
             const float clearValuesExposure[]{ -1.f, 1.f, 0.f, 0.f };
             memcpy(clearJob.clearJobDescriptor.color, clearValuesExposure, 4 * sizeof(float));
-            wcscpy_s(clearJob.jobLabel, L"Clear Frame Info");
+            strcpy(clearJob.jobLabel, "Clear Frame Info");
             clearJob.clearJobDescriptor.target = context->srvResources[FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_FRAME_INFO];
             context->contextDescription.backendInterface.fpScheduleGpuJob(&context->contextDescription.backendInterface, &clearJob);
         }
@@ -1067,7 +1068,7 @@ static FfxErrorCode fsr3upscalerDispatch(FfxFsr3UpscalerContext_Private* context
         const bool  bInverted = (context->contextDescription.flags & FFX_FSR3UPSCALER_ENABLE_DEPTH_INVERTED) == FFX_FSR3UPSCALER_ENABLE_DEPTH_INVERTED;
         const float clearDepthValue[]{bInverted ? 0.f : 1.f, bInverted ? 0.f : 1.f, bInverted ? 0.f : 1.f, bInverted ? 0.f : 1.f};
         memcpy(clearJob.clearJobDescriptor.color, clearDepthValue, 4 * sizeof(float));
-        wcscpy_s(clearJob.jobLabel, L"Clear Reconstructed Previous Nearest Depth");
+        strcpy(clearJob.jobLabel, "Clear Reconstructed Previous Nearest Depth");
         clearJob.clearJobDescriptor.target = context->srvResources[FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_RECONSTRUCTED_PREVIOUS_NEAREST_DEPTH];
         context->contextDescription.backendInterface.fpScheduleGpuJob(&context->contextDescription.backendInterface, &clearJob);
     }
@@ -1075,7 +1076,7 @@ static FfxErrorCode fsr3upscalerDispatch(FfxFsr3UpscalerContext_Private* context
     // Suggested by Enduring to resolve issues with running FSR3 on console via the RHI backend in the plugin as this resource won't be cleared to 0 by default.
 	{
 		FfxGpuJobDescription clearJob = { FFX_GPU_JOB_CLEAR_FLOAT };
-		wcscpy_s(clearJob.jobLabel, L"Clear Spd Atomic Count");
+		strcpy(clearJob.jobLabel, "Clear Spd Atomic Count");
 		const float clearValuesToZeroFloat[]{ 0.f, 0.f, 0.f, 0.f };
 		memcpy(clearJob.clearJobDescriptor.color, clearValuesToZeroFloat, 4 * sizeof(float));
 		clearJob.clearJobDescriptor.target = context->uavResources[FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_SPD_ATOMIC_COUNT];
@@ -1118,7 +1119,7 @@ static FfxErrorCode fsr3upscalerDispatch(FfxFsr3UpscalerContext_Private* context
             context->uavResources[FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_FARTHEST_DEPTH_MIP1],
             context->uavResources[FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_DILATED_REACTIVE_MASKS],
         };
-        for(int i = 0; i<_countof(aliasableResources); ++i)
+        for(int i = 0; i < std::size(aliasableResources); ++i)
         {
             FfxGpuJobDescription discardJob = { FFX_GPU_JOB_DISCARD };
             discardJob.discardJobDescriptor.target = aliasableResources[i];
@@ -1127,7 +1128,7 @@ static FfxErrorCode fsr3upscalerDispatch(FfxFsr3UpscalerContext_Private* context
         // SPD counter needs to be cleared
         {
             FfxGpuJobDescription clearJob = { FFX_GPU_JOB_CLEAR_FLOAT };
-            wcscpy_s(clearJob.jobLabel, L"Clear Spd Atomic Count");
+            strcpy(clearJob.jobLabel, "Clear Spd Atomic Count");
             const float clearValuesToZeroFloat[]{ 0.f, 0.f, 0.f, 0.f };
             memcpy(clearJob.clearJobDescriptor.color, clearValuesToZeroFloat, 4 * sizeof(float));
             clearJob.clearJobDescriptor.target = context->uavResources[FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_SPD_MIPS];
@@ -1379,9 +1380,9 @@ FfxErrorCode ffxFsr3UpscalerContextGenerateReactiveMask(FfxFsr3UpscalerContext*
     jobDescriptor.uavTextures[0].resource = contextPrivate->uavResources[FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_AUTOREACTIVE];
 
 #ifdef FFX_DEBUG
-    wcscpy_s(jobDescriptor.srvTextures[0].name, pipeline->srvTextureBindings[0].name);
-    wcscpy_s(jobDescriptor.srvTextures[1].name, pipeline->srvTextureBindings[1].name);
-    wcscpy_s(jobDescriptor.uavTextures[0].name, pipeline->uavTextureBindings[0].name);
+    strcpy(jobDescriptor.srvTextures[0].name, pipeline->srvTextureBindings[0].name);
+    strcpy(jobDescriptor.srvTextures[1].name, pipeline->srvTextureBindings[1].name);
+    strcpy(jobDescriptor.uavTextures[0].name, pipeline->uavTextureBindings[0].name);
 #endif
 
     jobDescriptor.dimensions[0] = dispatchSrcX;
@@ -1395,7 +1396,7 @@ FfxErrorCode ffxFsr3UpscalerContextGenerateReactiveMask(FfxFsr3UpscalerContext*
         const FfxResourceInternal currentResource = contextPrivate->srvResources[currentResourceId];
         jobDescriptor.srvTextures[currentShaderResourceViewIndex].resource = currentResource;
 #ifdef FFX_DEBUG
-        wcscpy_s(jobDescriptor.srvTextures[currentShaderResourceViewIndex].name, pipeline->srvTextureBindings[currentShaderResourceViewIndex].name);
+        strcpy(jobDescriptor.srvTextures[currentShaderResourceViewIndex].name, pipeline->srvTextureBindings[currentShaderResourceViewIndex].name);
 #endif
     }
 
@@ -1410,7 +1411,7 @@ FfxErrorCode ffxFsr3UpscalerContextGenerateReactiveMask(FfxFsr3UpscalerContext*
     for (uint32_t currentRootConstantIndex = 0; currentRootConstantIndex < pipeline->constCount; ++currentRootConstantIndex)
     {
 #ifdef FFX_DEBUG
-        wcscpy_s(jobDescriptor.cbNames[currentRootConstantIndex], pipeline->constantBufferBindings[currentRootConstantIndex].name);
+        strcpy(jobDescriptor.cbNames[currentRootConstantIndex], pipeline->constantBufferBindings[currentRootConstantIndex].name);
 #endif
         jobDescriptor.cbs[currentRootConstantIndex] = contextPrivate->constantBuffers[pipeline->constantBufferBindings[currentRootConstantIndex].resourceIdentifier];
     }
diff --git a/sdk/src/components/lens/CMakeLists.txt b/sdk/src/components/lens/CMakeLists.txt
index 91945b1..27f2066 100644
--- a/sdk/src/components/lens/CMakeLists.txt
+++ b/sdk/src/components/lens/CMakeLists.txt
@@ -38,9 +38,9 @@ if (FFX_LENS OR FFX_ALL)
 	list(APPEND PUBLIC_SOURCES ${FFX_PUBLIC_SOURCES})
 
 	if (FFX_BUILD_AS_DLL)
-		add_library(ffx_lens_${FFX_PLATFORM_NAME} SHARED ${SHARED_SOURCES} ${PRIVATE_SOURCES} ${PUBLIC_SOURCES})
+		add_library(lens SHARED ${SHARED_SOURCES} ${PRIVATE_SOURCES} ${PUBLIC_SOURCES})
 	else()
-		add_library(ffx_lens_${FFX_PLATFORM_NAME} STATIC ${SHARED_SOURCES} ${PRIVATE_SOURCES} ${PUBLIC_SOURCES})
+		add_library(lens STATIC ${SHARED_SOURCES} ${PRIVATE_SOURCES} ${PUBLIC_SOURCES})
 	endif()
 
 	# API
@@ -48,10 +48,17 @@ if (FFX_LENS OR FFX_ALL)
 	source_group("private_source" FILES ${PRIVATE_SOURCES})
 	source_group("public_source"  FILES ${PUBLIC_SOURCES})
 
-	target_include_directories(ffx_lens_${FFX_PLATFORM_NAME} PUBLIC ${FFX_INCLUDE_PATH})
-	target_include_directories(ffx_lens_${FFX_PLATFORM_NAME} PUBLIC ${FFX_SHARED_PATH})
+	target_include_directories(lens PUBLIC
+		$<BUILD_INTERFACE:${FFX_INCLUDE_PATH}>
+		$<INSTALL_INTERFACE:include>)
+	target_include_directories(lens PRIVATE ${FFX_SHARED_PATH})
 
 	set_source_files_properties(${SHADERS} PROPERTIES HEADER_FILE_ONLY TRUE)
-	set_target_properties(ffx_lens_${FFX_PLATFORM_NAME} PROPERTIES FOLDER Components)
+	set_target_properties(lens PROPERTIES FOLDER Components)
+	
+	install(TARGETS lens EXPORT lens-targets)
+	install(EXPORT lens-targets 
+		DESTINATION "${CMAKE_INSTALL_DATADIR}/cmake/${PROJECT_NAME}"
+		NAMESPACE fidelityfx::)
 	
 endif()
diff --git a/sdk/src/components/lens/ffx_lens.cpp b/sdk/src/components/lens/ffx_lens.cpp
index 59d86e8..727b48c 100644
--- a/sdk/src/components/lens/ffx_lens.cpp
+++ b/sdk/src/components/lens/ffx_lens.cpp
@@ -20,6 +20,7 @@
 // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 // THE SOFTWARE.
 
+#include <array>        // for std::size
 #include <string.h>     // for memset
 #include <cmath>        // for fabs, abs, sinf, sqrt, etc.
 
@@ -32,22 +33,22 @@
 typedef struct ResourceBinding
 {
     uint32_t    index;
-    wchar_t     name[64];
+    char        name[64];
 }ResourceBinding;
 
 static const ResourceBinding srvTextureBindingTable[] =
 {
-    {FFX_LENS_RESOURCE_IDENTIFIER_INPUT_TEXTURE,                   L"r_input_texture"},
+    {FFX_LENS_RESOURCE_IDENTIFIER_INPUT_TEXTURE,                   "r_input_texture"},
 };
 
 static const ResourceBinding uavTextureBindingTable[] =
 {
-    {FFX_LENS_RESOURCE_IDENTIFIER_OUTPUT_TEXTURE,                  L"rw_output_texture"},
+    {FFX_LENS_RESOURCE_IDENTIFIER_OUTPUT_TEXTURE,                  "rw_output_texture"},
 };
 
 static const ResourceBinding cbResourceBindingTable[] =
 {
-    {FFX_LENS_CONSTANTBUFFER_IDENTIFIER_LENS,                      L"cbLens"},
+    {FFX_LENS_CONSTANTBUFFER_IDENTIFIER_LENS,                      "cbLens"},
 };
 
 static FfxErrorCode patchResourceBindings(FfxPipelineState* inoutPipeline)
@@ -56,12 +57,12 @@ static FfxErrorCode patchResourceBindings(FfxPipelineState* inoutPipeline)
     for (uint32_t srvIndex = 0; srvIndex < inoutPipeline->srvTextureCount; ++srvIndex)
     {
         int32_t mapIndex = 0;
-        for (mapIndex = 0; mapIndex < _countof(srvTextureBindingTable); ++mapIndex)
+        for (mapIndex = 0; mapIndex < std::size(srvTextureBindingTable); ++mapIndex)
         {
-            if (0 == wcscmp(srvTextureBindingTable[mapIndex].name, inoutPipeline->srvTextureBindings[srvIndex].name))
+            if (0 == strcmp(srvTextureBindingTable[mapIndex].name, inoutPipeline->srvTextureBindings[srvIndex].name))
                 break;
         }
-        if (mapIndex == _countof(srvTextureBindingTable))
+        if (mapIndex == std::size(srvTextureBindingTable))
             return FFX_ERROR_INVALID_ARGUMENT;
 
         inoutPipeline->srvTextureBindings[srvIndex].resourceIdentifier = srvTextureBindingTable[mapIndex].index;
@@ -71,12 +72,12 @@ static FfxErrorCode patchResourceBindings(FfxPipelineState* inoutPipeline)
     for (uint32_t uavIndex = 0; uavIndex < inoutPipeline->uavTextureCount; ++uavIndex)
     {
         int32_t mapIndex = 0;
-        for (mapIndex = 0; mapIndex < _countof(uavTextureBindingTable); ++mapIndex)
+        for (mapIndex = 0; mapIndex < std::size(uavTextureBindingTable); ++mapIndex)
         {
-            if (0 == wcscmp(uavTextureBindingTable[mapIndex].name, inoutPipeline->uavTextureBindings[uavIndex].name))
+            if (0 == strcmp(uavTextureBindingTable[mapIndex].name, inoutPipeline->uavTextureBindings[uavIndex].name))
                 break;
         }
-        if (mapIndex == _countof(uavTextureBindingTable))
+        if (mapIndex == std::size(uavTextureBindingTable))
             return FFX_ERROR_INVALID_ARGUMENT;
 
         inoutPipeline->uavTextureBindings[uavIndex].resourceIdentifier = uavTextureBindingTable[mapIndex].index;
@@ -86,12 +87,12 @@ static FfxErrorCode patchResourceBindings(FfxPipelineState* inoutPipeline)
     for (uint32_t cbIndex = 0; cbIndex < inoutPipeline->constCount; ++cbIndex)
     {
         int32_t mapIndex = 0;
-        for (mapIndex = 0; mapIndex < _countof(cbResourceBindingTable); ++mapIndex)
+        for (mapIndex = 0; mapIndex < std::size(cbResourceBindingTable); ++mapIndex)
         {
-            if (0 == wcscmp(cbResourceBindingTable[mapIndex].name, inoutPipeline->constantBufferBindings[cbIndex].name))
+            if (0 == strcmp(cbResourceBindingTable[mapIndex].name, inoutPipeline->constantBufferBindings[cbIndex].name))
                 break;
         }
-        if (mapIndex == _countof(cbResourceBindingTable))
+        if (mapIndex == std::size(cbResourceBindingTable))
             return FFX_ERROR_INVALID_ARGUMENT;
 
         inoutPipeline->constantBufferBindings[cbIndex].resourceIdentifier = cbResourceBindingTable[mapIndex].index;
@@ -145,7 +146,7 @@ static FfxErrorCode createPipelineStates(FfxLensContext_Private* context)
     bool useFP16 = context->contextDescription.floatPrecision == FfxLensFloatPrecision::FFX_LENS_FLOAT_PRECISION_16BIT;
 
     // Set up pipeline descriptors (basically RootSignature and binding)
-    wcscpy_s(pipelineDescription.name, L"LENS-MAIN");
+    strcpy(pipelineDescription.name, "LENS-MAIN");
     FFX_VALIDATE(context->contextDescription.backendInterface.fpCreatePipeline(&context->contextDescription.backendInterface, FFX_EFFECT_LENS, FFX_LENS_PASS_MAIN_PASS,
         getPipelinePermutationFlags(canForceWave64, supportedFP16 && useFP16),
         &pipelineDescription, context->effectContextId, &context->pipelineLens));
@@ -159,7 +160,7 @@ static FfxErrorCode createPipelineStates(FfxLensContext_Private* context)
 static void scheduleDispatch(FfxLensContext_Private* context, const FfxLensDispatchDescription* params, const FfxPipelineState* pipeline, uint32_t dispatchX, uint32_t dispatchY, uint32_t dispatchZ)
 {
     FfxGpuJobDescription dispatchJob = {FFX_GPU_JOB_COMPUTE};
-    wcscpy_s(dispatchJob.jobLabel, pipeline->name);
+    strcpy(dispatchJob.jobLabel, pipeline->name);
 
     // Texture srv
     for (uint32_t currentShaderResourceViewIndex = 0; currentShaderResourceViewIndex < pipeline->srvTextureCount; ++currentShaderResourceViewIndex) {
@@ -168,7 +169,7 @@ static void scheduleDispatch(FfxLensContext_Private* context, const FfxLensDispa
         const FfxResourceInternal currentResource = context->srvResources[currentResourceId];
         dispatchJob.computeJobDescriptor.srvTextures[currentShaderResourceViewIndex].resource = currentResource;
 #ifdef FFX_DEBUG
-        wcscpy_s(dispatchJob.computeJobDescriptor.srvTextures[currentShaderResourceViewIndex].name,
+        strcpy(dispatchJob.computeJobDescriptor.srvTextures[currentShaderResourceViewIndex].name,
                  pipeline->srvTextureBindings[currentShaderResourceViewIndex].name);
 #endif
     }
@@ -179,7 +180,7 @@ static void scheduleDispatch(FfxLensContext_Private* context, const FfxLensDispa
 
         uint32_t currentResourceId = pipeline->uavTextureBindings[currentUnorderedAccessViewIndex].resourceIdentifier;
 #ifdef FFX_DEBUG
-        wcscpy_s(dispatchJob.computeJobDescriptor.uavTextures[currentUnorderedAccessViewIndex].name,
+        strcpy(dispatchJob.computeJobDescriptor.uavTextures[currentUnorderedAccessViewIndex].name,
                  pipeline->uavTextureBindings[currentUnorderedAccessViewIndex].name);
 #endif
         const FfxResourceInternal currentResource = context->uavResources[currentResourceId];
@@ -195,7 +196,7 @@ static void scheduleDispatch(FfxLensContext_Private* context, const FfxLensDispa
     dispatchJob.computeJobDescriptor.pipeline      = *pipeline;
 
 #ifdef FFX_DEBUG
-    wcscpy_s(dispatchJob.computeJobDescriptor.cbNames[0], pipeline->constantBufferBindings[0].name);
+    strcpy(dispatchJob.computeJobDescriptor.cbNames[0], pipeline->constantBufferBindings[0].name);
 #endif
     dispatchJob.computeJobDescriptor.cbs[0] = context->constantBuffer;
 
diff --git a/sdk/src/components/lpm/CMakeLists.txt b/sdk/src/components/lpm/CMakeLists.txt
index 2faf50a..4bd9df0 100644
--- a/sdk/src/components/lpm/CMakeLists.txt
+++ b/sdk/src/components/lpm/CMakeLists.txt
@@ -38,9 +38,9 @@ if (FFX_LPM OR FFX_ALL)
 	list(APPEND PUBLIC_SOURCES ${FFX_PUBLIC_SOURCES})
 
 	if (FFX_BUILD_AS_DLL)
-		add_library(ffx_lpm_${FFX_PLATFORM_NAME} SHARED ${SHARED_SOURCES} ${PRIVATE_SOURCES} ${PUBLIC_SOURCES})
+		add_library(lpm SHARED ${SHARED_SOURCES} ${PRIVATE_SOURCES} ${PUBLIC_SOURCES})
 	else()
-		add_library(ffx_lpm_${FFX_PLATFORM_NAME} STATIC ${SHARED_SOURCES} ${PRIVATE_SOURCES} ${PUBLIC_SOURCES})
+		add_library(lpm STATIC ${SHARED_SOURCES} ${PRIVATE_SOURCES} ${PUBLIC_SOURCES})
 	endif()
 
 	# API
@@ -48,10 +48,17 @@ if (FFX_LPM OR FFX_ALL)
 	source_group("private_source" FILES ${PRIVATE_SOURCES})
 	source_group("public_source"  FILES ${PUBLIC_SOURCES})
 
-	target_include_directories(ffx_lpm_${FFX_PLATFORM_NAME} PUBLIC ${FFX_INCLUDE_PATH})
-	target_include_directories(ffx_lpm_${FFX_PLATFORM_NAME} PUBLIC ${FFX_SHARED_PATH})
+	target_include_directories(lpm PUBLIC
+		$<BUILD_INTERFACE:${FFX_INCLUDE_PATH}>
+		$<INSTALL_INTERFACE:include>)
+	target_include_directories(lpm PRIVATE ${FFX_SHARED_PATH})
 
 	set_source_files_properties(${SHADERS} PROPERTIES HEADER_FILE_ONLY TRUE)
-	set_target_properties(ffx_lpm_${FFX_PLATFORM_NAME} PROPERTIES FOLDER Components)
+	set_target_properties(lpm PROPERTIES FOLDER Components)
+	
+	install(TARGETS lpm EXPORT lpm-targets)
+	install(EXPORT lpm-targets 
+		DESTINATION "${CMAKE_INSTALL_DATADIR}/cmake/${PROJECT_NAME}"
+		NAMESPACE fidelityfx::)
 	
 endif()
diff --git a/sdk/src/components/lpm/ffx_lpm.cpp b/sdk/src/components/lpm/ffx_lpm.cpp
index a2af2f2..9d96ebb 100644
--- a/sdk/src/components/lpm/ffx_lpm.cpp
+++ b/sdk/src/components/lpm/ffx_lpm.cpp
@@ -20,8 +20,9 @@
 // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 // THE SOFTWARE.
 
+#include <array>     // for std::size
 #include <string.h>  // for memset
-#include <stdlib.h>  // for _countof
+#include <stdlib.h>  //  
 #include <cmath>     // for fabs, abs, sinf, sqrt, etc.
 
 
@@ -50,19 +51,19 @@ static void LpmSetupOut(uint32_t i, uint32_t* v)
 typedef struct ResourceBinding
 {
     uint32_t index;
-    wchar_t  name[64];
+    char     name[64];
 } ResourceBinding;
 
 static const ResourceBinding srvTextureBindingTable[] = {
-    {FFX_LPM_RESOURCE_IDENTIFIER_INPUT_COLOR, L"r_input_color"},
+    {FFX_LPM_RESOURCE_IDENTIFIER_INPUT_COLOR, "r_input_color"},
 };
 
 static const ResourceBinding uavTextureBindingTable[] = {
-    {FFX_LPM_RESOURCE_IDENTIFIER_OUTPUT_COLOR, L"rw_output_color"},
+    {FFX_LPM_RESOURCE_IDENTIFIER_OUTPUT_COLOR, "rw_output_color"},
 };
 
 static const ResourceBinding cbResourceBindingTable[] = {
-    {FFX_LPM_CONSTANTBUFFER_IDENTIFIER_LPM, L"cbLPM"},
+    {FFX_LPM_CONSTANTBUFFER_IDENTIFIER_LPM, "cbLPM"},
 };
 
 static FfxErrorCode patchResourceBindings(FfxPipelineState* inoutPipeline)
@@ -70,12 +71,12 @@ static FfxErrorCode patchResourceBindings(FfxPipelineState* inoutPipeline)
     for (uint32_t srvIndex = 0; srvIndex < inoutPipeline->srvTextureCount; ++srvIndex)
     {
         int32_t mapIndex = 0;
-        for (mapIndex = 0; mapIndex < _countof(srvTextureBindingTable); ++mapIndex)
+        for (mapIndex = 0; mapIndex < std::size(srvTextureBindingTable); ++mapIndex)
         {
-            if (0 == wcscmp(srvTextureBindingTable[mapIndex].name, inoutPipeline->srvTextureBindings[srvIndex].name))
+            if (0 == strcmp(srvTextureBindingTable[mapIndex].name, inoutPipeline->srvTextureBindings[srvIndex].name))
                 break;
         }
-        if (mapIndex == _countof(srvTextureBindingTable))
+        if (mapIndex == std::size(srvTextureBindingTable))
             return FFX_ERROR_INVALID_ARGUMENT;
 
         inoutPipeline->srvTextureBindings[srvIndex].resourceIdentifier = srvTextureBindingTable[mapIndex].index;
@@ -84,12 +85,12 @@ static FfxErrorCode patchResourceBindings(FfxPipelineState* inoutPipeline)
     for (uint32_t uavIndex = 0; uavIndex < inoutPipeline->uavTextureCount; ++uavIndex)
     {
         int32_t mapIndex = 0;
-        for (mapIndex = 0; mapIndex < _countof(uavTextureBindingTable); ++mapIndex)
+        for (mapIndex = 0; mapIndex < std::size(uavTextureBindingTable); ++mapIndex)
         {
-            if (0 == wcscmp(uavTextureBindingTable[mapIndex].name, inoutPipeline->uavTextureBindings[uavIndex].name))
+            if (0 == strcmp(uavTextureBindingTable[mapIndex].name, inoutPipeline->uavTextureBindings[uavIndex].name))
                 break;
         }
-        if (mapIndex == _countof(uavTextureBindingTable))
+        if (mapIndex == std::size(uavTextureBindingTable))
             return FFX_ERROR_INVALID_ARGUMENT;
 
         inoutPipeline->uavTextureBindings[uavIndex].resourceIdentifier = uavTextureBindingTable[mapIndex].index;
@@ -98,12 +99,12 @@ static FfxErrorCode patchResourceBindings(FfxPipelineState* inoutPipeline)
     for (uint32_t cbIndex = 0; cbIndex < inoutPipeline->constCount; ++cbIndex)
     {
         int32_t mapIndex = 0;
-        for (mapIndex = 0; mapIndex < _countof(cbResourceBindingTable); ++mapIndex)
+        for (mapIndex = 0; mapIndex < std::size(cbResourceBindingTable); ++mapIndex)
         {
-            if (0 == wcscmp(cbResourceBindingTable[mapIndex].name, inoutPipeline->constantBufferBindings[cbIndex].name))
+            if (0 == strcmp(cbResourceBindingTable[mapIndex].name, inoutPipeline->constantBufferBindings[cbIndex].name))
                 break;
         }
-        if (mapIndex == _countof(cbResourceBindingTable))
+        if (mapIndex == std::size(cbResourceBindingTable))
             return FFX_ERROR_INVALID_ARGUMENT;
 
         inoutPipeline->constantBufferBindings[cbIndex].resourceIdentifier = cbResourceBindingTable[mapIndex].index;
@@ -159,7 +160,7 @@ static FfxErrorCode createPipelineStates(FfxLpmContext_Private* context)
     uint32_t contextFlags = context->contextDescription.flags;
 
     // Set up pipeline descriptors (basically RootSignature and binding)
-    wcscpy_s(pipelineDescription.name, L"LPM-FILTER");
+    strcpy(pipelineDescription.name, "LPM-FILTER");
     FFX_VALIDATE(context->contextDescription.backendInterface.fpCreatePipeline(
         &context->contextDescription.backendInterface,
         FFX_EFFECT_LPM,
@@ -177,7 +178,7 @@ static FfxErrorCode createPipelineStates(FfxLpmContext_Private* context)
 static void scheduleDispatch(FfxLpmContext_Private* context, const FfxLpmDispatchDescription* params, const FfxPipelineState* pipeline, uint32_t dispatchX, uint32_t dispatchY)
 {
     FfxGpuJobDescription dispatchJob = {FFX_GPU_JOB_COMPUTE};
-    wcscpy_s(dispatchJob.jobLabel, pipeline->name);
+    strcpy(dispatchJob.jobLabel, pipeline->name);
 
     for (uint32_t currentShaderResourceViewIndex = 0; currentShaderResourceViewIndex < pipeline->srvTextureCount; ++currentShaderResourceViewIndex)
     {
@@ -185,7 +186,7 @@ static void scheduleDispatch(FfxLpmContext_Private* context, const FfxLpmDispatc
         const FfxResourceInternal currentResource                 = context->srvResources[currentResourceId];
         dispatchJob.computeJobDescriptor.srvTextures[currentShaderResourceViewIndex].resource = currentResource;
 #ifdef FFX_DEBUG
-        wcscpy_s(dispatchJob.computeJobDescriptor.srvTextures[currentShaderResourceViewIndex].name,
+        strcpy(dispatchJob.computeJobDescriptor.srvTextures[currentShaderResourceViewIndex].name,
                  pipeline->srvTextureBindings[currentShaderResourceViewIndex].name);
 #endif
     }
@@ -194,7 +195,7 @@ static void scheduleDispatch(FfxLpmContext_Private* context, const FfxLpmDispatc
     {
         const uint32_t currentResourceId = pipeline->uavTextureBindings[currentUnorderedAccessViewIndex].resourceIdentifier;
 #ifdef FFX_DEBUG
-        wcscpy_s(dispatchJob.computeJobDescriptor.uavTextures[currentUnorderedAccessViewIndex].name,
+        strcpy(dispatchJob.computeJobDescriptor.uavTextures[currentUnorderedAccessViewIndex].name,
                  pipeline->uavTextureBindings[currentUnorderedAccessViewIndex].name);
 #endif
         const FfxResourceInternal currentResource                     = context->uavResources[currentResourceId];
@@ -208,7 +209,7 @@ static void scheduleDispatch(FfxLpmContext_Private* context, const FfxLpmDispatc
     dispatchJob.computeJobDescriptor.pipeline      = *pipeline;
 
 #ifdef FFX_DEBUG
-    wcscpy_s(dispatchJob.computeJobDescriptor.cbNames[0], pipeline->constantBufferBindings[0].name);
+    strcpy(dispatchJob.computeJobDescriptor.cbNames[0], pipeline->constantBufferBindings[0].name);
 #endif
     dispatchJob.computeJobDescriptor.cbs[0] = context->constantBuffer;
 
diff --git a/sdk/src/components/opticalflow/CMakeLists.txt b/sdk/src/components/opticalflow/CMakeLists.txt
index 02423ad..27ee886 100644
--- a/sdk/src/components/opticalflow/CMakeLists.txt
+++ b/sdk/src/components/opticalflow/CMakeLists.txt
@@ -39,20 +39,28 @@ if (FFX_OF  OR FFX_ALL)
 	list(APPEND PUBLIC_SOURCES ${FFX_PUBLIC_SOURCES})
 
 	if (FFX_BUILD_AS_DLL)
-		add_library(ffx_opticalflow_${FFX_PLATFORM_NAME} SHARED ${SHARED_SOURCES} ${PRIVATE_SOURCES} ${PUBLIC_SOURCES})
+		add_library(fopticalflow SHARED ${SHARED_SOURCES} ${PRIVATE_SOURCES} ${PUBLIC_SOURCES})
 	else()
-		add_library(ffx_opticalflow_${FFX_PLATFORM_NAME} STATIC ${SHARED_SOURCES} ${PRIVATE_SOURCES} ${PUBLIC_SOURCES})
+		add_library(opticalflow STATIC ${SHARED_SOURCES} ${PRIVATE_SOURCES} ${PUBLIC_SOURCES})
 	endif()
+	add_library(fidelityfx::opticalflow ALIAS opticalflow)
 
 	# API
 	source_group("shared_source"  FILES ${SHARED_SOURCES})
 	source_group("private_source" FILES ${PRIVATE_SOURCES})
 	source_group("public_source"  FILES ${PUBLIC_SOURCES})
 
-	target_include_directories(ffx_opticalflow_${FFX_PLATFORM_NAME} PUBLIC ${FFX_INCLUDE_PATH})
-	target_include_directories(ffx_opticalflow_${FFX_PLATFORM_NAME} PUBLIC ${FFX_SHARED_PATH})
+	target_include_directories(opticalflow PUBLIC
+		$<BUILD_INTERFACE:${FFX_INCLUDE_PATH}>
+		$<INSTALL_INTERFACE:include>)
+	target_include_directories(opticalflow PRIVATE ${FFX_SHARED_PATH})
 
 	set_source_files_properties(${SHADERS} PROPERTIES HEADER_FILE_ONLY TRUE)
-	set_target_properties(ffx_opticalflow_${FFX_PLATFORM_NAME} PROPERTIES FOLDER Components)
+	set_target_properties(opticalflow PROPERTIES FOLDER Components)
+	
+	install(TARGETS opticalflow EXPORT opticalflow-targets)
+	install(EXPORT opticalflow-targets 
+		DESTINATION "${CMAKE_INSTALL_DATADIR}/cmake/${PROJECT_NAME}"
+		NAMESPACE fidelityfx::)
 	
 endif()
diff --git a/sdk/src/components/opticalflow/ffx_opticalflow.cpp b/sdk/src/components/opticalflow/ffx_opticalflow.cpp
index 7b0c84f..8ce90a7 100644
--- a/sdk/src/components/opticalflow/ffx_opticalflow.cpp
+++ b/sdk/src/components/opticalflow/ffx_opticalflow.cpp
@@ -24,6 +24,7 @@
 #include <cmath>        // for fabs, abs, sinf, sqrt, etc.
 #include <string>       // for memset
 #include <cfloat>       // for FLT_EPSILON
+#include <cstring>      // for strcpy
 #include "FidelityFX/host/ffx_opticalflow.h"
 
 #ifdef __clang__
@@ -44,39 +45,39 @@
 typedef struct Binding
 {
     uint32_t    index;
-    wchar_t     name[64];
+    char        name[64];
 }Binding;
 
 static const Binding srvBindingNames[] =
 {
-    {FFX_OF_BINDING_IDENTIFIER_INPUT_COLOR,                           L"r_input_color"},
-    {FFX_OF_BINDING_IDENTIFIER_OPTICAL_FLOW_INPUT,                    L"r_optical_flow_input"},
-    {FFX_OF_BINDING_IDENTIFIER_OPTICAL_FLOW_PREVIOUS_INPUT,           L"r_optical_flow_previous_input"},
-    {FFX_OF_BINDING_IDENTIFIER_OPTICAL_FLOW,                          L"r_optical_flow"},
-    {FFX_OF_BINDING_IDENTIFIER_OPTICAL_FLOW_PREVIOUS,                 L"r_optical_flow_previous"},
+    {FFX_OF_BINDING_IDENTIFIER_INPUT_COLOR,                           "r_input_color"},
+    {FFX_OF_BINDING_IDENTIFIER_OPTICAL_FLOW_INPUT,                    "r_optical_flow_input"},
+    {FFX_OF_BINDING_IDENTIFIER_OPTICAL_FLOW_PREVIOUS_INPUT,           "r_optical_flow_previous_input"},
+    {FFX_OF_BINDING_IDENTIFIER_OPTICAL_FLOW,                          "r_optical_flow"},
+    {FFX_OF_BINDING_IDENTIFIER_OPTICAL_FLOW_PREVIOUS,                 "r_optical_flow_previous"},
 };
 
 static const Binding uavBindingNames[] =
 {
-    {FFX_OF_BINDING_IDENTIFIER_OPTICAL_FLOW_INPUT,                      L"rw_optical_flow_input"},
-    {FFX_OF_BINDING_IDENTIFIER_OPTICAL_FLOW_INPUT_LEVEL_1,              L"rw_optical_flow_input_level_1"},
-    {FFX_OF_BINDING_IDENTIFIER_OPTICAL_FLOW_INPUT_LEVEL_2,              L"rw_optical_flow_input_level_2"},
-    {FFX_OF_BINDING_IDENTIFIER_OPTICAL_FLOW_INPUT_LEVEL_3,              L"rw_optical_flow_input_level_3"},
-    {FFX_OF_BINDING_IDENTIFIER_OPTICAL_FLOW_INPUT_LEVEL_4,              L"rw_optical_flow_input_level_4"},
-    {FFX_OF_BINDING_IDENTIFIER_OPTICAL_FLOW_INPUT_LEVEL_5,              L"rw_optical_flow_input_level_5"},
-    {FFX_OF_BINDING_IDENTIFIER_OPTICAL_FLOW_INPUT_LEVEL_6,              L"rw_optical_flow_input_level_6"},
-    {FFX_OF_BINDING_IDENTIFIER_OPTICAL_FLOW,                            L"rw_optical_flow"},
-    {FFX_OF_BINDING_IDENTIFIER_OPTICAL_FLOW_NEXT_LEVEL,                 L"rw_optical_flow_next_level"},
-    {FFX_OF_BINDING_IDENTIFIER_OPTICAL_FLOW_SCD_HISTOGRAM,              L"rw_optical_flow_scd_histogram"}, // scene change detection histogram
-    {FFX_OF_BINDING_IDENTIFIER_OPTICAL_FLOW_SCD_PREVIOUS_HISTOGRAM,     L"rw_optical_flow_scd_previous_histogram"},
-    {FFX_OF_BINDING_IDENTIFIER_OPTICAL_FLOW_SCD_TEMP,                   L"rw_optical_flow_scd_temp"},
-    {FFX_OF_BINDING_IDENTIFIER_OPTICAL_FLOW_SCD_OUTPUT,                 L"rw_optical_flow_scd_output"},
+    {FFX_OF_BINDING_IDENTIFIER_OPTICAL_FLOW_INPUT,                      "rw_optical_flow_input"},
+    {FFX_OF_BINDING_IDENTIFIER_OPTICAL_FLOW_INPUT_LEVEL_1,              "rw_optical_flow_input_level_1"},
+    {FFX_OF_BINDING_IDENTIFIER_OPTICAL_FLOW_INPUT_LEVEL_2,              "rw_optical_flow_input_level_2"},
+    {FFX_OF_BINDING_IDENTIFIER_OPTICAL_FLOW_INPUT_LEVEL_3,              "rw_optical_flow_input_level_3"},
+    {FFX_OF_BINDING_IDENTIFIER_OPTICAL_FLOW_INPUT_LEVEL_4,              "rw_optical_flow_input_level_4"},
+    {FFX_OF_BINDING_IDENTIFIER_OPTICAL_FLOW_INPUT_LEVEL_5,              "rw_optical_flow_input_level_5"},
+    {FFX_OF_BINDING_IDENTIFIER_OPTICAL_FLOW_INPUT_LEVEL_6,              "rw_optical_flow_input_level_6"},
+    {FFX_OF_BINDING_IDENTIFIER_OPTICAL_FLOW,                            "rw_optical_flow"},
+    {FFX_OF_BINDING_IDENTIFIER_OPTICAL_FLOW_NEXT_LEVEL,                 "rw_optical_flow_next_level"},
+    {FFX_OF_BINDING_IDENTIFIER_OPTICAL_FLOW_SCD_HISTOGRAM,              "rw_optical_flow_scd_histogram"}, // scene change detection histogram
+    {FFX_OF_BINDING_IDENTIFIER_OPTICAL_FLOW_SCD_PREVIOUS_HISTOGRAM,     "rw_optical_flow_scd_previous_histogram"},
+    {FFX_OF_BINDING_IDENTIFIER_OPTICAL_FLOW_SCD_TEMP,                   "rw_optical_flow_scd_temp"},
+    {FFX_OF_BINDING_IDENTIFIER_OPTICAL_FLOW_SCD_OUTPUT,                 "rw_optical_flow_scd_output"},
 };
 
 static const Binding cbBindingNames[] =
 {
-    {FFX_OPTICALFLOW_CONSTANTBUFFER_IDENTIFIER,       L"cbOF"},
-    {FFX_OPTICALFLOW_CONSTANTBUFFER_IDENTIFIER_SPD,   L"cbOF_SPD"}
+    {FFX_OPTICALFLOW_CONSTANTBUFFER_IDENTIFIER,       "cbOF"},
+    {FFX_OPTICALFLOW_CONSTANTBUFFER_IDENTIFIER_SPD,   "cbOF_SPD"}
 };
 
 // Broad structure of the root signature.
@@ -107,13 +108,13 @@ static FfxErrorCode patchResourceBindings(FfxPipelineState* inoutPipeline)
     for (uint32_t srvIndex = 0; srvIndex < inoutPipeline->srvTextureCount; ++srvIndex)
     {
         int32_t mapIndex = 0;
-        for (mapIndex = 0; mapIndex < _countof(srvBindingNames); ++mapIndex)
+        for (mapIndex = 0; mapIndex < std::size(srvBindingNames); ++mapIndex)
         {
-            if (0 == wcscmp(srvBindingNames[mapIndex].name, inoutPipeline->srvTextureBindings[srvIndex].name))
+            if (0 == strcmp(srvBindingNames[mapIndex].name, inoutPipeline->srvTextureBindings[srvIndex].name))
                 break;
         }
-        FFX_ASSERT(mapIndex < _countof(srvBindingNames));
-        if (mapIndex == _countof(srvBindingNames))
+        FFX_ASSERT(mapIndex < std::size(srvBindingNames));
+        if (mapIndex == std::size(srvBindingNames))
             return FFX_ERROR_INVALID_ARGUMENT;
 
         inoutPipeline->srvTextureBindings[srvIndex].resourceIdentifier = srvBindingNames[mapIndex].index;
@@ -122,13 +123,13 @@ static FfxErrorCode patchResourceBindings(FfxPipelineState* inoutPipeline)
     for (uint32_t uavIndex = 0; uavIndex < inoutPipeline->uavTextureCount; ++uavIndex)
     {
         int32_t mapIndex = 0;
-        for (mapIndex = 0; mapIndex < _countof(uavBindingNames); ++mapIndex)
+        for (mapIndex = 0; mapIndex < std::size(uavBindingNames); ++mapIndex)
         {
-            if (0 == wcscmp(uavBindingNames[mapIndex].name, inoutPipeline->uavTextureBindings[uavIndex].name))
+            if (0 == strcmp(uavBindingNames[mapIndex].name, inoutPipeline->uavTextureBindings[uavIndex].name))
                 break;
         }
-        FFX_ASSERT(mapIndex < _countof(uavBindingNames));
-        if (mapIndex == _countof(uavBindingNames))
+        FFX_ASSERT(mapIndex < std::size(uavBindingNames));
+        if (mapIndex == std::size(uavBindingNames))
             return FFX_ERROR_INVALID_ARGUMENT;
 
         inoutPipeline->uavTextureBindings[uavIndex].resourceIdentifier = uavBindingNames[mapIndex].index;
@@ -137,13 +138,13 @@ static FfxErrorCode patchResourceBindings(FfxPipelineState* inoutPipeline)
     for (uint32_t cbIndex = 0; cbIndex < inoutPipeline->constCount; ++cbIndex)
     {
         int32_t mapIndex = 0;
-        for (mapIndex = 0; mapIndex < _countof(cbBindingNames); ++mapIndex)
+        for (mapIndex = 0; mapIndex < std::size(cbBindingNames); ++mapIndex)
         {
-            if (0 == wcscmp(cbBindingNames[mapIndex].name, inoutPipeline->constantBufferBindings[cbIndex].name))
+            if (0 == strcmp(cbBindingNames[mapIndex].name, inoutPipeline->constantBufferBindings[cbIndex].name))
                 break;
         }
-        FFX_ASSERT(mapIndex < _countof(cbBindingNames));
-        if (mapIndex == _countof(cbBindingNames))
+        FFX_ASSERT(mapIndex < std::size(cbBindingNames));
+        if (mapIndex == std::size(cbBindingNames))
             return FFX_ERROR_INVALID_ARGUMENT;
 
         inoutPipeline->constantBufferBindings[cbIndex].resourceIdentifier = cbBindingNames[mapIndex].index;
@@ -200,9 +201,9 @@ static FfxErrorCode createPipelineStates(FfxOpticalflowContext_Private* context)
 
     uint32_t contextFlags = context->contextDescription.flags;
 
-    auto CreateComputePipeline = [&](FfxPass pass, const wchar_t* name, FfxPipelineState* pipeline) -> FfxErrorCode {
+    auto CreateComputePipeline = [&](FfxPass pass, const char* name, FfxPipelineState* pipeline) -> FfxErrorCode {
         ffxSafeReleasePipeline(&context->contextDescription.backendInterface, pipeline, context->effectContextId);
-        wcscpy_s(pipelineDescription.name, name);
+        strcpy(pipelineDescription.name, name);
         FFX_VALIDATE(context->contextDescription.backendInterface.fpCreatePipeline(
             &context->contextDescription.backendInterface,
             FFX_EFFECT_OPTICALFLOW,
@@ -216,14 +217,14 @@ static FfxErrorCode createPipelineStates(FfxOpticalflowContext_Private* context)
         return FFX_OK;
     };
 
-    CreateComputePipeline(FFX_OPTICALFLOW_PASS_GENERATE_OPTICAL_FLOW_INPUT_PYRAMID, L"Opticalflow_InputPyramid", & context->pipelineGenerateOpticalFlowInputPyramid);
+    CreateComputePipeline(FFX_OPTICALFLOW_PASS_GENERATE_OPTICAL_FLOW_INPUT_PYRAMID, "Opticalflow_InputPyramid", & context->pipelineGenerateOpticalFlowInputPyramid);
     pipelineDescription.rootConstantBufferCount = 1;
-    CreateComputePipeline(FFX_OPTICALFLOW_PASS_PREPARE_LUMA, L"Opticalflow_Luma", &context->pipelinePrepareLuma);
-    CreateComputePipeline(FFX_OPTICALFLOW_PASS_GENERATE_SCD_HISTOGRAM, L"Opticalflow_SCD_Histogram", &context->pipelineGenerateSCDHistogram);
-    CreateComputePipeline(FFX_OPTICALFLOW_PASS_COMPUTE_SCD_DIVERGENCE, L"Opticalflow_SCD_Divergence", &context->pipelineComputeSCDDivergence);
-    CreateComputePipeline(FFX_OPTICALFLOW_PASS_COMPUTE_OPTICAL_FLOW_ADVANCED_V5, L"Opticalflow_Search", &context->pipelineComputeOpticalFlowAdvancedV5);
-    CreateComputePipeline(FFX_OPTICALFLOW_PASS_FILTER_OPTICAL_FLOW_V5, L"Opticalflow_Filter", &context->pipelineFilterOpticalFlowV5);
-    CreateComputePipeline(FFX_OPTICALFLOW_PASS_SCALE_OPTICAL_FLOW_ADVANCED_V5, L"Opticalflow_Upscale", &context->pipelineScaleOpticalFlowAdvancedV5);
+    CreateComputePipeline(FFX_OPTICALFLOW_PASS_PREPARE_LUMA, "Opticalflow_Luma", &context->pipelinePrepareLuma);
+    CreateComputePipeline(FFX_OPTICALFLOW_PASS_GENERATE_SCD_HISTOGRAM, "Opticalflow_SCD_Histogram", &context->pipelineGenerateSCDHistogram);
+    CreateComputePipeline(FFX_OPTICALFLOW_PASS_COMPUTE_SCD_DIVERGENCE, "Opticalflow_SCD_Divergence", &context->pipelineComputeSCDDivergence);
+    CreateComputePipeline(FFX_OPTICALFLOW_PASS_COMPUTE_OPTICAL_FLOW_ADVANCED_V5, "Opticalflow_Search", &context->pipelineComputeOpticalFlowAdvancedV5);
+    CreateComputePipeline(FFX_OPTICALFLOW_PASS_FILTER_OPTICAL_FLOW_V5, "Opticalflow_Filter", &context->pipelineFilterOpticalFlowV5);
+    CreateComputePipeline(FFX_OPTICALFLOW_PASS_SCALE_OPTICAL_FLOW_ADVANCED_V5, "Opticalflow_Upscale", &context->pipelineScaleOpticalFlowAdvancedV5);
 
     return FFX_OK;
 }
@@ -313,97 +314,97 @@ static FfxErrorCode opticalflowCreate(FfxOpticalflowContext_Private* context, co
     const uint32_t globalMotionSearchTextureWidth = 4 + (globalMotionSearchMaxDispatchSize.width * globalMotionSearchMaxDispatchSize.height);
 
     const FfxInternalResourceDescription internalSurfaceDesc[] =    {
-        {   FFX_OF_RESOURCE_IDENTIFIER_OPTICAL_FLOW_INPUT_1, L"OPTICALFLOW_OpticalFlowInput1", FFX_RESOURCE_TYPE_TEXTURE2D, FFX_RESOURCE_USAGE_UAV,
+        {   FFX_OF_RESOURCE_IDENTIFIER_OPTICAL_FLOW_INPUT_1, "OPTICALFLOW_OpticalFlowInput1", FFX_RESOURCE_TYPE_TEXTURE2D, FFX_RESOURCE_USAGE_UAV,
             FFX_SURFACE_FORMAT_R8_UINT, opticalFlowInputTextureSize.width, opticalFlowInputTextureSize.height, 1,  FFX_RESOURCE_FLAGS_NONE, {FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED} },
 
-        {   FFX_OF_RESOURCE_IDENTIFIER_OPTICAL_FLOW_INPUT_1_LEVEL_1, L"OPTICALFLOW_OpticalFlowInput1Level1", FFX_RESOURCE_TYPE_TEXTURE2D, FFX_RESOURCE_USAGE_UAV,
+        {   FFX_OF_RESOURCE_IDENTIFIER_OPTICAL_FLOW_INPUT_1_LEVEL_1, "OPTICALFLOW_OpticalFlowInput1Level1", FFX_RESOURCE_TYPE_TEXTURE2D, FFX_RESOURCE_USAGE_UAV,
             FFX_SURFACE_FORMAT_R8_UINT, opticalFlowInputTextureSize.width >> 1, opticalFlowInputTextureSize.height >> 1, 1,  FFX_RESOURCE_FLAGS_NONE, {FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED} },
 
-        {   FFX_OF_RESOURCE_IDENTIFIER_OPTICAL_FLOW_INPUT_1_LEVEL_2, L"OPTICALFLOW_OpticalFlowInput1Level2", FFX_RESOURCE_TYPE_TEXTURE2D, FFX_RESOURCE_USAGE_UAV,
+        {   FFX_OF_RESOURCE_IDENTIFIER_OPTICAL_FLOW_INPUT_1_LEVEL_2, "OPTICALFLOW_OpticalFlowInput1Level2", FFX_RESOURCE_TYPE_TEXTURE2D, FFX_RESOURCE_USAGE_UAV,
             FFX_SURFACE_FORMAT_R8_UINT, opticalFlowInputTextureSize.width >> 2, opticalFlowInputTextureSize.height >> 2, 1,  FFX_RESOURCE_FLAGS_NONE, {FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED} },
 
-        {   FFX_OF_RESOURCE_IDENTIFIER_OPTICAL_FLOW_INPUT_1_LEVEL_3, L"OPTICALFLOW_OpticalFlowInput1Level3", FFX_RESOURCE_TYPE_TEXTURE2D, FFX_RESOURCE_USAGE_UAV,
+        {   FFX_OF_RESOURCE_IDENTIFIER_OPTICAL_FLOW_INPUT_1_LEVEL_3, "OPTICALFLOW_OpticalFlowInput1Level3", FFX_RESOURCE_TYPE_TEXTURE2D, FFX_RESOURCE_USAGE_UAV,
             FFX_SURFACE_FORMAT_R8_UINT, opticalFlowInputTextureSize.width >> 3, opticalFlowInputTextureSize.height >> 3, 1,  FFX_RESOURCE_FLAGS_NONE, {FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED} },
 
-        {   FFX_OF_RESOURCE_IDENTIFIER_OPTICAL_FLOW_INPUT_1_LEVEL_4, L"OPTICALFLOW_OpticalFlowInput1Level4", FFX_RESOURCE_TYPE_TEXTURE2D, FFX_RESOURCE_USAGE_UAV,
+        {   FFX_OF_RESOURCE_IDENTIFIER_OPTICAL_FLOW_INPUT_1_LEVEL_4, "OPTICALFLOW_OpticalFlowInput1Level4", FFX_RESOURCE_TYPE_TEXTURE2D, FFX_RESOURCE_USAGE_UAV,
             FFX_SURFACE_FORMAT_R8_UINT, opticalFlowInputTextureSize.width >> 4, opticalFlowInputTextureSize.height >> 4, 1,  FFX_RESOURCE_FLAGS_NONE, {FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED} },
 
-        {   FFX_OF_RESOURCE_IDENTIFIER_OPTICAL_FLOW_INPUT_1_LEVEL_5, L"OPTICALFLOW_OpticalFlowInput1Level5", FFX_RESOURCE_TYPE_TEXTURE2D, FFX_RESOURCE_USAGE_UAV,
+        {   FFX_OF_RESOURCE_IDENTIFIER_OPTICAL_FLOW_INPUT_1_LEVEL_5, "OPTICALFLOW_OpticalFlowInput1Level5", FFX_RESOURCE_TYPE_TEXTURE2D, FFX_RESOURCE_USAGE_UAV,
             FFX_SURFACE_FORMAT_R8_UINT, opticalFlowInputTextureSize.width >> 5, opticalFlowInputTextureSize.height >> 5, 1,  FFX_RESOURCE_FLAGS_NONE, {FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED} },
 
-        {   FFX_OF_RESOURCE_IDENTIFIER_OPTICAL_FLOW_INPUT_1_LEVEL_6, L"OPTICALFLOW_OpticalFlowInput1Level6", FFX_RESOURCE_TYPE_TEXTURE2D, FFX_RESOURCE_USAGE_UAV,
+        {   FFX_OF_RESOURCE_IDENTIFIER_OPTICAL_FLOW_INPUT_1_LEVEL_6, "OPTICALFLOW_OpticalFlowInput1Level6", FFX_RESOURCE_TYPE_TEXTURE2D, FFX_RESOURCE_USAGE_UAV,
             FFX_SURFACE_FORMAT_R8_UINT, opticalFlowInputTextureSize.width >> 6, opticalFlowInputTextureSize.height >> 6, 1,  FFX_RESOURCE_FLAGS_NONE, {FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED} },
 
-        {   FFX_OF_RESOURCE_IDENTIFIER_OPTICAL_FLOW_INPUT_2, L"OPTICALFLOW_OpticalFlowInput2", FFX_RESOURCE_TYPE_TEXTURE2D, FFX_RESOURCE_USAGE_UAV,
+        {   FFX_OF_RESOURCE_IDENTIFIER_OPTICAL_FLOW_INPUT_2, "OPTICALFLOW_OpticalFlowInput2", FFX_RESOURCE_TYPE_TEXTURE2D, FFX_RESOURCE_USAGE_UAV,
             FFX_SURFACE_FORMAT_R8_UINT, opticalFlowInputTextureSize.width, opticalFlowInputTextureSize.height, 1,  FFX_RESOURCE_FLAGS_NONE, {FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED} },
 
-        {   FFX_OF_RESOURCE_IDENTIFIER_OPTICAL_FLOW_INPUT_2_LEVEL_1, L"OPTICALFLOW_OpticalFlowInput2Level1", FFX_RESOURCE_TYPE_TEXTURE2D, FFX_RESOURCE_USAGE_UAV,
+        {   FFX_OF_RESOURCE_IDENTIFIER_OPTICAL_FLOW_INPUT_2_LEVEL_1, "OPTICALFLOW_OpticalFlowInput2Level1", FFX_RESOURCE_TYPE_TEXTURE2D, FFX_RESOURCE_USAGE_UAV,
             FFX_SURFACE_FORMAT_R8_UINT, opticalFlowInputTextureSize.width >> 1, opticalFlowInputTextureSize.height >> 1, 1,  FFX_RESOURCE_FLAGS_NONE, {FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED} },
 
-        {   FFX_OF_RESOURCE_IDENTIFIER_OPTICAL_FLOW_INPUT_2_LEVEL_2, L"OPTICALFLOW_OpticalFlowInput2Level2", FFX_RESOURCE_TYPE_TEXTURE2D, FFX_RESOURCE_USAGE_UAV,
+        {   FFX_OF_RESOURCE_IDENTIFIER_OPTICAL_FLOW_INPUT_2_LEVEL_2, "OPTICALFLOW_OpticalFlowInput2Level2", FFX_RESOURCE_TYPE_TEXTURE2D, FFX_RESOURCE_USAGE_UAV,
             FFX_SURFACE_FORMAT_R8_UINT, opticalFlowInputTextureSize.width >> 2, opticalFlowInputTextureSize.height >> 2, 1,  FFX_RESOURCE_FLAGS_NONE, {FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED} },
 
-        {   FFX_OF_RESOURCE_IDENTIFIER_OPTICAL_FLOW_INPUT_2_LEVEL_3, L"OPTICALFLOW_OpticalFlowInput2Level3", FFX_RESOURCE_TYPE_TEXTURE2D, FFX_RESOURCE_USAGE_UAV,
+        {   FFX_OF_RESOURCE_IDENTIFIER_OPTICAL_FLOW_INPUT_2_LEVEL_3, "OPTICALFLOW_OpticalFlowInput2Level3", FFX_RESOURCE_TYPE_TEXTURE2D, FFX_RESOURCE_USAGE_UAV,
             FFX_SURFACE_FORMAT_R8_UINT, opticalFlowInputTextureSize.width >> 3, opticalFlowInputTextureSize.height >> 3, 1,  FFX_RESOURCE_FLAGS_NONE, {FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED} },
 
-        {   FFX_OF_RESOURCE_IDENTIFIER_OPTICAL_FLOW_INPUT_2_LEVEL_4, L"OPTICALFLOW_OpticalFlowInput2Level4", FFX_RESOURCE_TYPE_TEXTURE2D, FFX_RESOURCE_USAGE_UAV,
+        {   FFX_OF_RESOURCE_IDENTIFIER_OPTICAL_FLOW_INPUT_2_LEVEL_4, "OPTICALFLOW_OpticalFlowInput2Level4", FFX_RESOURCE_TYPE_TEXTURE2D, FFX_RESOURCE_USAGE_UAV,
             FFX_SURFACE_FORMAT_R8_UINT, opticalFlowInputTextureSize.width >> 4, opticalFlowInputTextureSize.height >> 4, 1,  FFX_RESOURCE_FLAGS_NONE, {FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED} },
 
-        {   FFX_OF_RESOURCE_IDENTIFIER_OPTICAL_FLOW_INPUT_2_LEVEL_5, L"OPTICALFLOW_OpticalFlowInput2Level5", FFX_RESOURCE_TYPE_TEXTURE2D, FFX_RESOURCE_USAGE_UAV,
+        {   FFX_OF_RESOURCE_IDENTIFIER_OPTICAL_FLOW_INPUT_2_LEVEL_5, "OPTICALFLOW_OpticalFlowInput2Level5", FFX_RESOURCE_TYPE_TEXTURE2D, FFX_RESOURCE_USAGE_UAV,
             FFX_SURFACE_FORMAT_R8_UINT, opticalFlowInputTextureSize.width >> 5, opticalFlowInputTextureSize.height >> 5, 1,  FFX_RESOURCE_FLAGS_NONE, {FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED} },
 
-        {   FFX_OF_RESOURCE_IDENTIFIER_OPTICAL_FLOW_INPUT_2_LEVEL_6, L"OPTICALFLOW_OpticalFlowInput2Level6", FFX_RESOURCE_TYPE_TEXTURE2D, FFX_RESOURCE_USAGE_UAV,
+        {   FFX_OF_RESOURCE_IDENTIFIER_OPTICAL_FLOW_INPUT_2_LEVEL_6, "OPTICALFLOW_OpticalFlowInput2Level6", FFX_RESOURCE_TYPE_TEXTURE2D, FFX_RESOURCE_USAGE_UAV,
             FFX_SURFACE_FORMAT_R8_UINT, opticalFlowInputTextureSize.width >> 6, opticalFlowInputTextureSize.height >> 6, 1,  FFX_RESOURCE_FLAGS_NONE, {FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED} },
 
-        {   FFX_OF_RESOURCE_IDENTIFIER_OPTICAL_FLOW_1, L"OPTICALFLOW_OpticalFlow1", FFX_RESOURCE_TYPE_TEXTURE2D, FFX_RESOURCE_USAGE_UAV,
+        {   FFX_OF_RESOURCE_IDENTIFIER_OPTICAL_FLOW_1, "OPTICALFLOW_OpticalFlow1", FFX_RESOURCE_TYPE_TEXTURE2D, FFX_RESOURCE_USAGE_UAV,
             FFX_SURFACE_FORMAT_R16G16_SINT, opticalFlowTextureSize.width, opticalFlowTextureSize.height, 1,  FFX_RESOURCE_FLAGS_NONE, {FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED} },
 
-        {   FFX_OF_RESOURCE_IDENTIFIER_OPTICAL_FLOW_1_LEVEL_1, L"OPTICALFLOW_OpticalFlow1Level1", FFX_RESOURCE_TYPE_TEXTURE2D, FFX_RESOURCE_USAGE_UAV,
+        {   FFX_OF_RESOURCE_IDENTIFIER_OPTICAL_FLOW_1_LEVEL_1, "OPTICALFLOW_OpticalFlow1Level1", FFX_RESOURCE_TYPE_TEXTURE2D, FFX_RESOURCE_USAGE_UAV,
             FFX_SURFACE_FORMAT_R16G16_SINT, opticalFlowLevel1TextureSize.width, opticalFlowLevel1TextureSize.height, 1, FFX_RESOURCE_FLAGS_NONE, {FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED} },
 
-        {   FFX_OF_RESOURCE_IDENTIFIER_OPTICAL_FLOW_1_LEVEL_2, L"OPTICALFLOW_OpticalFlow1Level2", FFX_RESOURCE_TYPE_TEXTURE2D, FFX_RESOURCE_USAGE_UAV,
+        {   FFX_OF_RESOURCE_IDENTIFIER_OPTICAL_FLOW_1_LEVEL_2, "OPTICALFLOW_OpticalFlow1Level2", FFX_RESOURCE_TYPE_TEXTURE2D, FFX_RESOURCE_USAGE_UAV,
             FFX_SURFACE_FORMAT_R16G16_SINT, opticalFlowLevel2TextureSize.width, opticalFlowLevel2TextureSize.height, 1, FFX_RESOURCE_FLAGS_NONE, {FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED} },
 
-        {   FFX_OF_RESOURCE_IDENTIFIER_OPTICAL_FLOW_1_LEVEL_3, L"OPTICALFLOW_OpticalFlow1Level3", FFX_RESOURCE_TYPE_TEXTURE2D, FFX_RESOURCE_USAGE_UAV,
+        {   FFX_OF_RESOURCE_IDENTIFIER_OPTICAL_FLOW_1_LEVEL_3, "OPTICALFLOW_OpticalFlow1Level3", FFX_RESOURCE_TYPE_TEXTURE2D, FFX_RESOURCE_USAGE_UAV,
             FFX_SURFACE_FORMAT_R16G16_SINT, opticalFlowLevel3TextureSize.width, opticalFlowLevel3TextureSize.height, 1, FFX_RESOURCE_FLAGS_NONE, {FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED} },
 
-        {   FFX_OF_RESOURCE_IDENTIFIER_OPTICAL_FLOW_1_LEVEL_4, L"OPTICALFLOW_OpticalFlow1Level4", FFX_RESOURCE_TYPE_TEXTURE2D, FFX_RESOURCE_USAGE_UAV,
+        {   FFX_OF_RESOURCE_IDENTIFIER_OPTICAL_FLOW_1_LEVEL_4, "OPTICALFLOW_OpticalFlow1Level4", FFX_RESOURCE_TYPE_TEXTURE2D, FFX_RESOURCE_USAGE_UAV,
             FFX_SURFACE_FORMAT_R16G16_SINT, opticalFlowLevel4TextureSize.width, opticalFlowLevel4TextureSize.height, 1, FFX_RESOURCE_FLAGS_NONE, {FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED} },
 
-        {   FFX_OF_RESOURCE_IDENTIFIER_OPTICAL_FLOW_1_LEVEL_5, L"OPTICALFLOW_OpticalFlow1Level5", FFX_RESOURCE_TYPE_TEXTURE2D, FFX_RESOURCE_USAGE_UAV,
+        {   FFX_OF_RESOURCE_IDENTIFIER_OPTICAL_FLOW_1_LEVEL_5, "OPTICALFLOW_OpticalFlow1Level5", FFX_RESOURCE_TYPE_TEXTURE2D, FFX_RESOURCE_USAGE_UAV,
             FFX_SURFACE_FORMAT_R16G16_SINT, opticalFlowLevel5TextureSize.width, opticalFlowLevel5TextureSize.height, 1, FFX_RESOURCE_FLAGS_NONE, {FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED} },
 
-        {   FFX_OF_RESOURCE_IDENTIFIER_OPTICAL_FLOW_1_LEVEL_6, L"OPTICALFLOW_OpticalFlow1Level6", FFX_RESOURCE_TYPE_TEXTURE2D, FFX_RESOURCE_USAGE_UAV,
+        {   FFX_OF_RESOURCE_IDENTIFIER_OPTICAL_FLOW_1_LEVEL_6, "OPTICALFLOW_OpticalFlow1Level6", FFX_RESOURCE_TYPE_TEXTURE2D, FFX_RESOURCE_USAGE_UAV,
             FFX_SURFACE_FORMAT_R16G16_SINT, opticalFlowLevel6TextureSize.width, opticalFlowLevel6TextureSize.height, 1, FFX_RESOURCE_FLAGS_NONE, {FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED} },
 
-        {   FFX_OF_RESOURCE_IDENTIFIER_OPTICAL_FLOW_2, L"OPTICALFLOW_OpticalFlow2", FFX_RESOURCE_TYPE_TEXTURE2D, FFX_RESOURCE_USAGE_UAV,
+        {   FFX_OF_RESOURCE_IDENTIFIER_OPTICAL_FLOW_2, "OPTICALFLOW_OpticalFlow2", FFX_RESOURCE_TYPE_TEXTURE2D, FFX_RESOURCE_USAGE_UAV,
             FFX_SURFACE_FORMAT_R16G16_SINT, opticalFlowTextureSize.width, opticalFlowTextureSize.height, 1,  FFX_RESOURCE_FLAGS_NONE, {FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED} },
 
-        {   FFX_OF_RESOURCE_IDENTIFIER_OPTICAL_FLOW_2_LEVEL_1, L"OPTICALFLOW_OpticalFlow2Level1", FFX_RESOURCE_TYPE_TEXTURE2D, FFX_RESOURCE_USAGE_UAV,
+        {   FFX_OF_RESOURCE_IDENTIFIER_OPTICAL_FLOW_2_LEVEL_1, "OPTICALFLOW_OpticalFlow2Level1", FFX_RESOURCE_TYPE_TEXTURE2D, FFX_RESOURCE_USAGE_UAV,
             FFX_SURFACE_FORMAT_R16G16_SINT, opticalFlowLevel1TextureSize.width, opticalFlowLevel1TextureSize.height, 1, FFX_RESOURCE_FLAGS_NONE, {FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED} },
 
-        {   FFX_OF_RESOURCE_IDENTIFIER_OPTICAL_FLOW_2_LEVEL_2, L"OPTICALFLOW_OpticalFlow2Level2", FFX_RESOURCE_TYPE_TEXTURE2D, FFX_RESOURCE_USAGE_UAV,
+        {   FFX_OF_RESOURCE_IDENTIFIER_OPTICAL_FLOW_2_LEVEL_2, "OPTICALFLOW_OpticalFlow2Level2", FFX_RESOURCE_TYPE_TEXTURE2D, FFX_RESOURCE_USAGE_UAV,
             FFX_SURFACE_FORMAT_R16G16_SINT, opticalFlowLevel2TextureSize.width, opticalFlowLevel2TextureSize.height, 1, FFX_RESOURCE_FLAGS_NONE, {FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED} },
 
-        {   FFX_OF_RESOURCE_IDENTIFIER_OPTICAL_FLOW_2_LEVEL_3, L"OPTICALFLOW_OpticalFlow2Level3", FFX_RESOURCE_TYPE_TEXTURE2D, FFX_RESOURCE_USAGE_UAV,
+        {   FFX_OF_RESOURCE_IDENTIFIER_OPTICAL_FLOW_2_LEVEL_3, "OPTICALFLOW_OpticalFlow2Level3", FFX_RESOURCE_TYPE_TEXTURE2D, FFX_RESOURCE_USAGE_UAV,
             FFX_SURFACE_FORMAT_R16G16_SINT, opticalFlowLevel3TextureSize.width, opticalFlowLevel3TextureSize.height, 1, FFX_RESOURCE_FLAGS_NONE, {FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED} },
 
-        {   FFX_OF_RESOURCE_IDENTIFIER_OPTICAL_FLOW_2_LEVEL_4, L"OPTICALFLOW_OpticalFlow2Level4", FFX_RESOURCE_TYPE_TEXTURE2D, FFX_RESOURCE_USAGE_UAV,
+        {   FFX_OF_RESOURCE_IDENTIFIER_OPTICAL_FLOW_2_LEVEL_4, "OPTICALFLOW_OpticalFlow2Level4", FFX_RESOURCE_TYPE_TEXTURE2D, FFX_RESOURCE_USAGE_UAV,
             FFX_SURFACE_FORMAT_R16G16_SINT, opticalFlowLevel4TextureSize.width, opticalFlowLevel4TextureSize.height, 1, FFX_RESOURCE_FLAGS_NONE, {FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED} },
 
-        {   FFX_OF_RESOURCE_IDENTIFIER_OPTICAL_FLOW_2_LEVEL_5, L"OPTICALFLOW_OpticalFlow2Level5", FFX_RESOURCE_TYPE_TEXTURE2D, FFX_RESOURCE_USAGE_UAV,
+        {   FFX_OF_RESOURCE_IDENTIFIER_OPTICAL_FLOW_2_LEVEL_5, "OPTICALFLOW_OpticalFlow2Level5", FFX_RESOURCE_TYPE_TEXTURE2D, FFX_RESOURCE_USAGE_UAV,
             FFX_SURFACE_FORMAT_R16G16_SINT, opticalFlowLevel5TextureSize.width, opticalFlowLevel5TextureSize.height, 1, FFX_RESOURCE_FLAGS_NONE, {FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED} },
 
-        {   FFX_OF_RESOURCE_IDENTIFIER_OPTICAL_FLOW_2_LEVEL_6, L"OPTICALFLOW_OpticalFlow2Level6", FFX_RESOURCE_TYPE_TEXTURE2D, FFX_RESOURCE_USAGE_UAV,
+        {   FFX_OF_RESOURCE_IDENTIFIER_OPTICAL_FLOW_2_LEVEL_6, "OPTICALFLOW_OpticalFlow2Level6", FFX_RESOURCE_TYPE_TEXTURE2D, FFX_RESOURCE_USAGE_UAV,
             FFX_SURFACE_FORMAT_R16G16_SINT, opticalFlowLevel6TextureSize.width, opticalFlowLevel6TextureSize.height, 1, FFX_RESOURCE_FLAGS_NONE, {FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED} },
 
-        {   FFX_OF_RESOURCE_IDENTIFIER_OPTICAL_FLOW_SCD_HISTOGRAM, L"OPTICALFLOW_OpticalFlowSCDHistogram", FFX_RESOURCE_TYPE_TEXTURE2D, FFX_RESOURCE_USAGE_UAV,
+        {   FFX_OF_RESOURCE_IDENTIFIER_OPTICAL_FLOW_SCD_HISTOGRAM, "OPTICALFLOW_OpticalFlowSCDHistogram", FFX_RESOURCE_TYPE_TEXTURE2D, FFX_RESOURCE_USAGE_UAV,
             FFX_SURFACE_FORMAT_R32_UINT, GetSCDHistogramTextureWidth(), 1, 1,  FFX_RESOURCE_FLAGS_NONE, {FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED} },
 
-        {   FFX_OF_RESOURCE_IDENTIFIER_OPTICAL_FLOW_SCD_PREVIOUS_HISTOGRAM, L"OPTICALFLOW_OpticalFlowSCDPreviousHistogram", FFX_RESOURCE_TYPE_TEXTURE2D, FFX_RESOURCE_USAGE_UAV,
+        {   FFX_OF_RESOURCE_IDENTIFIER_OPTICAL_FLOW_SCD_PREVIOUS_HISTOGRAM, "OPTICALFLOW_OpticalFlowSCDPreviousHistogram", FFX_RESOURCE_TYPE_TEXTURE2D, FFX_RESOURCE_USAGE_UAV,
             FFX_SURFACE_FORMAT_R32_FLOAT, GetSCDHistogramTextureWidth(), 1, 1,  FFX_RESOURCE_FLAGS_NONE, {FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED} },
 
-        {   FFX_OF_RESOURCE_IDENTIFIER_OPTICAL_FLOW_SCD_TEMP, L"OPTICALFLOW_OpticalFlowSCDTemp", FFX_RESOURCE_TYPE_TEXTURE2D, FFX_RESOURCE_USAGE_UAV,
+        {   FFX_OF_RESOURCE_IDENTIFIER_OPTICAL_FLOW_SCD_TEMP, "OPTICALFLOW_OpticalFlowSCDTemp", FFX_RESOURCE_TYPE_TEXTURE2D, FFX_RESOURCE_USAGE_UAV,
             FFX_SURFACE_FORMAT_R32_UINT, 3, 1, 1,  FFX_RESOURCE_FLAGS_NONE, {FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED} },
     };
 
@@ -462,7 +463,7 @@ static FfxErrorCode opticalflowRelease(FfxOpticalflowContext_Private* context)
     return FFX_OK;
 }
 
-static void scheduleDispatch(FfxOpticalflowContext_Private* context, const FfxPipelineState* pipeline, const wchar_t* pipelineName, uint32_t dispatchX, uint32_t dispatchY, uint32_t dispatchZ = 1)
+static void scheduleDispatch(FfxOpticalflowContext_Private* context, const FfxPipelineState* pipeline, const char* pipelineName, uint32_t dispatchX, uint32_t dispatchY, uint32_t dispatchZ = 1)
 {
     FfxComputeJobDescription jobDescriptor = {};
 
@@ -472,7 +473,7 @@ static void scheduleDispatch(FfxOpticalflowContext_Private* context, const FfxPi
         const FfxResourceInternal currentResource = context->srvBindings[bindingIdentifier];
         jobDescriptor.srvTextures[currentShaderResourceViewIndex].resource = currentResource;
 #ifdef FFX_DEBUG
-        wcscpy_s(jobDescriptor.srvTextures[currentShaderResourceViewIndex].name, pipeline->srvTextureBindings[currentShaderResourceViewIndex].name);
+        strcpy(jobDescriptor.srvTextures[currentShaderResourceViewIndex].name, pipeline->srvTextureBindings[currentShaderResourceViewIndex].name);
 #endif
 
         FFX_ASSERT(bindingIdentifier != FFX_OF_BINDING_IDENTIFIER_NULL);
@@ -486,7 +487,7 @@ static void scheduleDispatch(FfxOpticalflowContext_Private* context, const FfxPi
         jobDescriptor.uavTextures[currentUnorderedAccessViewIndex].resource = currentResource;
         jobDescriptor.uavTextures[currentUnorderedAccessViewIndex].mip = 0;
 #ifdef FFX_DEBUG
-        wcscpy_s(jobDescriptor.uavTextures[currentUnorderedAccessViewIndex].name, pipeline->uavTextureBindings[currentUnorderedAccessViewIndex].name);
+        strcpy(jobDescriptor.uavTextures[currentUnorderedAccessViewIndex].name, pipeline->uavTextureBindings[currentUnorderedAccessViewIndex].name);
 #endif
 
         FFX_ASSERT(bindingIdentifier != FFX_OF_BINDING_IDENTIFIER_NULL);
@@ -500,13 +501,13 @@ static void scheduleDispatch(FfxOpticalflowContext_Private* context, const FfxPi
 
     for (uint32_t currentRootConstantIndex = 0; currentRootConstantIndex < pipeline->constCount; ++currentRootConstantIndex) {
 #ifdef FFX_DEBUG
-        wcscpy_s(jobDescriptor.cbNames[currentRootConstantIndex], pipeline->constantBufferBindings[currentRootConstantIndex].name);
+        strcpy(jobDescriptor.cbNames[currentRootConstantIndex], pipeline->constantBufferBindings[currentRootConstantIndex].name);
 #endif
         jobDescriptor.cbs[currentRootConstantIndex] = context->constantBuffers[pipeline->constantBufferBindings[currentRootConstantIndex].resourceIdentifier];
     }
 
     FfxGpuJobDescription dispatchJob = { FFX_GPU_JOB_COMPUTE };
-    wcscpy_s(dispatchJob.jobLabel, pipelineName);
+    strcpy(dispatchJob.jobLabel, pipelineName);
     dispatchJob.computeJobDescriptor = jobDescriptor;
 
     context->contextDescription.backendInterface.fpScheduleGpuJob(&context->contextDescription.backendInterface, &dispatchJob);
@@ -568,57 +569,57 @@ static FfxErrorCode dispatch(FfxOpticalflowContext_Private* context, const FfxOp
         FfxGpuJobDescription clearJob = { FFX_GPU_JOB_CLEAR_FLOAT };
         memcpy(clearJob.clearJobDescriptor.color, clearValuesToZeroFloat, 4 * sizeof(float));
 
-        wcscpy_s(clearJob.jobLabel, L"Clear Optical Flow SCD Temp");
+        strcpy(clearJob.jobLabel, "Clear Optical Flow SCD Temp");
         clearJob.clearJobDescriptor.target = context->resources[FFX_OF_RESOURCE_IDENTIFIER_OPTICAL_FLOW_SCD_TEMP];
         context->contextDescription.backendInterface.fpScheduleGpuJob(&context->contextDescription.backendInterface, &clearJob);
         clearJob.clearJobDescriptor.target = context->uavBindings[FFX_OF_BINDING_IDENTIFIER_SHARED_OPTICAL_FLOW_SCD_OUTPUT];
         context->contextDescription.backendInterface.fpScheduleGpuJob(&context->contextDescription.backendInterface, &clearJob);
-        wcscpy_s(clearJob.jobLabel, L"Clear Optical Flow SCD Histogram");
+        strcpy(clearJob.jobLabel, "Clear Optical Flow SCD Histogram");
         clearJob.clearJobDescriptor.target = context->resources[FFX_OF_RESOURCE_IDENTIFIER_OPTICAL_FLOW_SCD_HISTOGRAM];
         context->contextDescription.backendInterface.fpScheduleGpuJob(&context->contextDescription.backendInterface, &clearJob);
-        wcscpy_s(clearJob.jobLabel, L"Clear Optical Flow SCD Previous histogram");
+        strcpy(clearJob.jobLabel, "Clear Optical Flow SCD Previous histogram");
         clearJob.clearJobDescriptor.target = context->resources[FFX_OF_RESOURCE_IDENTIFIER_OPTICAL_FLOW_SCD_PREVIOUS_HISTOGRAM];
         context->contextDescription.backendInterface.fpScheduleGpuJob(&context->contextDescription.backendInterface, &clearJob);
-        wcscpy_s(clearJob.jobLabel, L"Clear Optical Flow Input 1");
+        strcpy(clearJob.jobLabel, "Clear Optical Flow Input 1");
         clearJob.clearJobDescriptor.target = context->resources[FFX_OF_RESOURCE_IDENTIFIER_OPTICAL_FLOW_INPUT_1];
         context->contextDescription.backendInterface.fpScheduleGpuJob(&context->contextDescription.backendInterface, &clearJob);
-        wcscpy_s(clearJob.jobLabel, L"Clear Optical Flow Input 1 Level 1");
+        strcpy(clearJob.jobLabel, "Clear Optical Flow Input 1 Level 1");
         clearJob.clearJobDescriptor.target = context->resources[FFX_OF_RESOURCE_IDENTIFIER_OPTICAL_FLOW_INPUT_1_LEVEL_1];
         context->contextDescription.backendInterface.fpScheduleGpuJob(&context->contextDescription.backendInterface, &clearJob);
-        wcscpy_s(clearJob.jobLabel, L"Clear Optical Flow Input 1 Level 2");
+        strcpy(clearJob.jobLabel, "Clear Optical Flow Input 1 Level 2");
         clearJob.clearJobDescriptor.target = context->resources[FFX_OF_RESOURCE_IDENTIFIER_OPTICAL_FLOW_INPUT_1_LEVEL_2];
         context->contextDescription.backendInterface.fpScheduleGpuJob(&context->contextDescription.backendInterface, &clearJob);
-        wcscpy_s(clearJob.jobLabel, L"Clear Optical Flow Input 1 Level 3");
+        strcpy(clearJob.jobLabel, "Clear Optical Flow Input 1 Level 3");
         clearJob.clearJobDescriptor.target = context->resources[FFX_OF_RESOURCE_IDENTIFIER_OPTICAL_FLOW_INPUT_1_LEVEL_3];
         context->contextDescription.backendInterface.fpScheduleGpuJob(&context->contextDescription.backendInterface, &clearJob);
-        wcscpy_s(clearJob.jobLabel, L"Clear Optical Flow Input 1 Level 4");
+        strcpy(clearJob.jobLabel, "Clear Optical Flow Input 1 Level 4");
         clearJob.clearJobDescriptor.target = context->resources[FFX_OF_RESOURCE_IDENTIFIER_OPTICAL_FLOW_INPUT_1_LEVEL_4];
         context->contextDescription.backendInterface.fpScheduleGpuJob(&context->contextDescription.backendInterface, &clearJob);
-        wcscpy_s(clearJob.jobLabel, L"Clear Optical Flow Input 1 Level 5");
+        strcpy(clearJob.jobLabel, "Clear Optical Flow Input 1 Level 5");
         clearJob.clearJobDescriptor.target = context->resources[FFX_OF_RESOURCE_IDENTIFIER_OPTICAL_FLOW_INPUT_1_LEVEL_5];
         context->contextDescription.backendInterface.fpScheduleGpuJob(&context->contextDescription.backendInterface, &clearJob);
-        wcscpy_s(clearJob.jobLabel, L"Clear Optical Flow Input 1 Level 6");
+        strcpy(clearJob.jobLabel, "Clear Optical Flow Input 1 Level 6");
         clearJob.clearJobDescriptor.target = context->resources[FFX_OF_RESOURCE_IDENTIFIER_OPTICAL_FLOW_INPUT_1_LEVEL_6];
         context->contextDescription.backendInterface.fpScheduleGpuJob(&context->contextDescription.backendInterface, &clearJob);
-        wcscpy_s(clearJob.jobLabel, L"Clear Optical Flow Input 2");
+        strcpy(clearJob.jobLabel, "Clear Optical Flow Input 2");
         clearJob.clearJobDescriptor.target = context->resources[FFX_OF_RESOURCE_IDENTIFIER_OPTICAL_FLOW_INPUT_2];
         context->contextDescription.backendInterface.fpScheduleGpuJob(&context->contextDescription.backendInterface, &clearJob);
-        wcscpy_s(clearJob.jobLabel, L"Clear Optical Flow Input 2 Level 1");
+        strcpy(clearJob.jobLabel, "Clear Optical Flow Input 2 Level 1");
         clearJob.clearJobDescriptor.target = context->resources[FFX_OF_RESOURCE_IDENTIFIER_OPTICAL_FLOW_INPUT_2_LEVEL_1];
         context->contextDescription.backendInterface.fpScheduleGpuJob(&context->contextDescription.backendInterface, &clearJob);
-        wcscpy_s(clearJob.jobLabel, L"Clear Optical Flow Input 2 Level 2");
+        strcpy(clearJob.jobLabel, "Clear Optical Flow Input 2 Level 2");
         clearJob.clearJobDescriptor.target = context->resources[FFX_OF_RESOURCE_IDENTIFIER_OPTICAL_FLOW_INPUT_2_LEVEL_2];
         context->contextDescription.backendInterface.fpScheduleGpuJob(&context->contextDescription.backendInterface, &clearJob);
-        wcscpy_s(clearJob.jobLabel, L"Clear Optical Flow Input 2 Level 3");
+        strcpy(clearJob.jobLabel, "Clear Optical Flow Input 2 Level 3");
         clearJob.clearJobDescriptor.target = context->resources[FFX_OF_RESOURCE_IDENTIFIER_OPTICAL_FLOW_INPUT_2_LEVEL_3];
         context->contextDescription.backendInterface.fpScheduleGpuJob(&context->contextDescription.backendInterface, &clearJob);
-        wcscpy_s(clearJob.jobLabel, L"Clear Optical Flow Input 2 Level 4");
+        strcpy(clearJob.jobLabel, "Clear Optical Flow Input 2 Level 4");
         clearJob.clearJobDescriptor.target = context->resources[FFX_OF_RESOURCE_IDENTIFIER_OPTICAL_FLOW_INPUT_2_LEVEL_4];
         context->contextDescription.backendInterface.fpScheduleGpuJob(&context->contextDescription.backendInterface, &clearJob);
-        wcscpy_s(clearJob.jobLabel, L"Clear Optical Flow Input 2 Level 5");
+        strcpy(clearJob.jobLabel, "Clear Optical Flow Input 2 Level 5");
         clearJob.clearJobDescriptor.target = context->resources[FFX_OF_RESOURCE_IDENTIFIER_OPTICAL_FLOW_INPUT_2_LEVEL_5];
         context->contextDescription.backendInterface.fpScheduleGpuJob(&context->contextDescription.backendInterface, &clearJob);
-        wcscpy_s(clearJob.jobLabel, L"Clear Optical Flow Input 2 Level 6");
+        strcpy(clearJob.jobLabel, "Clear Optical Flow Input 2 Level 6");
         clearJob.clearJobDescriptor.target = context->resources[FFX_OF_RESOURCE_IDENTIFIER_OPTICAL_FLOW_INPUT_2_LEVEL_6];
         context->contextDescription.backendInterface.fpScheduleGpuJob(&context->contextDescription.backendInterface, &clearJob);
     }
@@ -679,14 +680,14 @@ static FfxErrorCode dispatch(FfxOpticalflowContext_Private* context, const FfxOp
             uint32_t threadPixelsY = 2;
             int32_t dispatchX = ((context->contextDescription.resolution.width + (threadPixelsX - 1)) / threadPixelsX + (threadGroupSizeX - 1)) / threadGroupSizeX;
             int32_t dispatchY = ((context->contextDescription.resolution.height + (threadPixelsY - 1)) / threadPixelsY + (threadGroupSizeY - 1)) / threadGroupSizeY;
-            scheduleDispatch(context, &context->pipelinePrepareLuma, L"OF PrepareLuma", dispatchX, dispatchY);
+            scheduleDispatch(context, &context->pipelinePrepareLuma, "OF PrepareLuma", dispatchX, dispatchY);
         }
 
         {
             {
                 scheduleDispatch(context,
                                  &context->pipelineGenerateOpticalFlowInputPyramid,
-                                 L"OF GenerateOpticalFlowInputPyramid",
+                                 "OF GenerateOpticalFlowInputPyramid",
                                  threadGroupSizeOpticalFlowInputPyramid[0],
                                  threadGroupSizeOpticalFlowInputPyramid[1]
                 );
@@ -701,12 +702,12 @@ static FfxErrorCode dispatch(FfxOpticalflowContext_Private* context, const FfxOp
                     const uint32_t dispatchX = (strataWidth + threadGroupSizeX - 1) / threadGroupSizeX;
                     const uint32_t dispatchY = 16;
                     const uint32_t dispatchZ = HistogramsPerDim * HistogramsPerDim;
-                    scheduleDispatch(context, &context->pipelineGenerateSCDHistogram, L"OF GenerateSCDHistogram", dispatchX, dispatchY, dispatchZ);
+                    scheduleDispatch(context, &context->pipelineGenerateSCDHistogram, "OF GenerateSCDHistogram", dispatchX, dispatchY, dispatchZ);
                 }
                 {
                     const uint32_t dispatchX = HistogramsPerDim * HistogramsPerDim;
                     const uint32_t dispatchY = HistogramShifts;
-                    scheduleDispatch(context, &context->pipelineComputeSCDDivergence, L"OF ComputeSCDDivergence", dispatchX, dispatchY);
+                    scheduleDispatch(context, &context->pipelineComputeSCDDivergence, "OF ComputeSCDDivergence", dispatchX, dispatchY);
                 }
             }
 
@@ -745,7 +746,7 @@ static FfxErrorCode dispatch(FfxOpticalflowContext_Private* context, const FfxOp
                 {
                     const FfxUInt32 inputLumaWidth = ffxMax(context->contextDescription.resolution.width >> level, 1);
                     const FfxUInt32 inputLumaHeight = ffxMax(context->contextDescription.resolution.height >> level, 1);
-                    std::wstring pipelineName = L"OF " + std::to_wstring(level) + L" Search";
+                    std::string pipelineName = "OF " + std::to_string(level) + " Search";
 
                     {
                         uint32_t threadPixels = 4;
@@ -776,7 +777,7 @@ static FfxErrorCode dispatch(FfxOpticalflowContext_Private* context, const FfxOp
                     const uint32_t threadGroupSizeY = 4;
                     const uint32_t dispatchX = (levelWidth + threadGroupSizeX - 1) / threadGroupSizeX;
                     const uint32_t dispatchY = (levelHeight + threadGroupSizeY - 1) / threadGroupSizeY;
-                    std::wstring pipelineName = L"OF " + std::to_wstring(level) + L" Filter";
+                    std::string pipelineName = "OF " + std::to_string(level) + " Filter";
 
                     {
                         scheduleDispatch(context, &context->pipelineFilterOpticalFlowV5, pipelineName.c_str(), dispatchX, dispatchY);
@@ -805,7 +806,7 @@ static FfxErrorCode dispatch(FfxOpticalflowContext_Private* context, const FfxOp
                     const uint32_t dispatchX = (nextLevelWidth + threadGroupSizeX - 1) / threadGroupSizeX;
                     const uint32_t dispatchY = (nextLevelHeight + threadGroupSizeY - 1) / threadGroupSizeY;
                     const uint32_t dispatchZ = 1;
-                    std::wstring pipelineName = L"OF " + std::to_wstring(level) + L" Scale";
+                    std::string pipelineName = "OF " + std::to_string(level) + " Scale";
 
                     {
                         const uint32_t dispatchX = (nextLevelWidth + 3) / 4;
@@ -832,46 +833,46 @@ static FfxErrorCode dispatch(FfxOpticalflowContext_Private* context, const FfxOp
     {
         FfxGpuJobDescription barrierJob = {FFX_GPU_JOB_BARRIER};
 
-        wcscpy_s(barrierJob.jobLabel, L"Transition Optical Flow Input 1");
+        strcpy(barrierJob.jobLabel, "Transition Optical Flow Input 1");
         barrierJob.barrierDescriptor = { context->resources[FFX_OF_RESOURCE_IDENTIFIER_OPTICAL_FLOW_INPUT_1], FFX_BARRIER_TYPE_TRANSITION, FFX_RESOURCE_STATE_COMPUTE_READ, FFX_RESOURCE_STATE_UNORDERED_ACCESS, 0};
         context->contextDescription.backendInterface.fpScheduleGpuJob(&context->contextDescription.backendInterface, &barrierJob);
-        wcscpy_s(barrierJob.jobLabel, L"Transition Optical Flow Input 1 Level 1");
+        strcpy(barrierJob.jobLabel, "Transition Optical Flow Input 1 Level 1");
         barrierJob.barrierDescriptor = { context->resources[FFX_OF_RESOURCE_IDENTIFIER_OPTICAL_FLOW_INPUT_1_LEVEL_1], FFX_BARRIER_TYPE_TRANSITION, FFX_RESOURCE_STATE_COMPUTE_READ, FFX_RESOURCE_STATE_UNORDERED_ACCESS, 0};
         context->contextDescription.backendInterface.fpScheduleGpuJob(&context->contextDescription.backendInterface, &barrierJob);
-        wcscpy_s(barrierJob.jobLabel, L"Transition Optical Flow Input 1 Level 2");
+        strcpy(barrierJob.jobLabel, "Transition Optical Flow Input 1 Level 2");
         barrierJob.barrierDescriptor = { context->resources[FFX_OF_RESOURCE_IDENTIFIER_OPTICAL_FLOW_INPUT_1_LEVEL_2], FFX_BARRIER_TYPE_TRANSITION, FFX_RESOURCE_STATE_COMPUTE_READ, FFX_RESOURCE_STATE_UNORDERED_ACCESS, 0};
         context->contextDescription.backendInterface.fpScheduleGpuJob(&context->contextDescription.backendInterface, &barrierJob);
-        wcscpy_s(barrierJob.jobLabel, L"Transition Optical Flow Input 1 Level 3");
+        strcpy(barrierJob.jobLabel, "Transition Optical Flow Input 1 Level 3");
         barrierJob.barrierDescriptor = { context->resources[FFX_OF_RESOURCE_IDENTIFIER_OPTICAL_FLOW_INPUT_1_LEVEL_3], FFX_BARRIER_TYPE_TRANSITION, FFX_RESOURCE_STATE_COMPUTE_READ, FFX_RESOURCE_STATE_UNORDERED_ACCESS, 0};
         context->contextDescription.backendInterface.fpScheduleGpuJob(&context->contextDescription.backendInterface, &barrierJob);
-        wcscpy_s(barrierJob.jobLabel, L"Transition Optical Flow Input 1 Level 4");
+        strcpy(barrierJob.jobLabel, "Transition Optical Flow Input 1 Level 4");
         barrierJob.barrierDescriptor = { context->resources[FFX_OF_RESOURCE_IDENTIFIER_OPTICAL_FLOW_INPUT_1_LEVEL_4], FFX_BARRIER_TYPE_TRANSITION, FFX_RESOURCE_STATE_COMPUTE_READ, FFX_RESOURCE_STATE_UNORDERED_ACCESS, 0};
         context->contextDescription.backendInterface.fpScheduleGpuJob(&context->contextDescription.backendInterface, &barrierJob);
-        wcscpy_s(barrierJob.jobLabel, L"Transition Optical Flow Input 1 Level 5");
+        strcpy(barrierJob.jobLabel, "Transition Optical Flow Input 1 Level 5");
         barrierJob.barrierDescriptor = { context->resources[FFX_OF_RESOURCE_IDENTIFIER_OPTICAL_FLOW_INPUT_1_LEVEL_5], FFX_BARRIER_TYPE_TRANSITION, FFX_RESOURCE_STATE_COMPUTE_READ, FFX_RESOURCE_STATE_UNORDERED_ACCESS, 0};
         context->contextDescription.backendInterface.fpScheduleGpuJob(&context->contextDescription.backendInterface, &barrierJob);
-        wcscpy_s(barrierJob.jobLabel, L"Transition Optical Flow Input 1 Level 6");
+        strcpy(barrierJob.jobLabel, "Transition Optical Flow Input 1 Level 6");
         barrierJob.barrierDescriptor = { context->resources[FFX_OF_RESOURCE_IDENTIFIER_OPTICAL_FLOW_INPUT_1_LEVEL_6], FFX_BARRIER_TYPE_TRANSITION, FFX_RESOURCE_STATE_COMPUTE_READ, FFX_RESOURCE_STATE_UNORDERED_ACCESS, 0};
         context->contextDescription.backendInterface.fpScheduleGpuJob(&context->contextDescription.backendInterface, &barrierJob);
-        wcscpy_s(barrierJob.jobLabel, L"Transition Optical Flow Input 2");
+        strcpy(barrierJob.jobLabel, "Transition Optical Flow Input 2");
         barrierJob.barrierDescriptor = { context->resources[FFX_OF_RESOURCE_IDENTIFIER_OPTICAL_FLOW_INPUT_2], FFX_BARRIER_TYPE_TRANSITION, FFX_RESOURCE_STATE_COMPUTE_READ, FFX_RESOURCE_STATE_UNORDERED_ACCESS, 0};
         context->contextDescription.backendInterface.fpScheduleGpuJob(&context->contextDescription.backendInterface, &barrierJob);
-        wcscpy_s(barrierJob.jobLabel, L"Transition Optical Flow Input 2 Level 1");
+        strcpy(barrierJob.jobLabel, "Transition Optical Flow Input 2 Level 1");
         barrierJob.barrierDescriptor = { context->resources[FFX_OF_RESOURCE_IDENTIFIER_OPTICAL_FLOW_INPUT_2_LEVEL_1], FFX_BARRIER_TYPE_TRANSITION, FFX_RESOURCE_STATE_COMPUTE_READ, FFX_RESOURCE_STATE_UNORDERED_ACCESS, 0};
         context->contextDescription.backendInterface.fpScheduleGpuJob(&context->contextDescription.backendInterface, &barrierJob);
-        wcscpy_s(barrierJob.jobLabel, L"Transition Optical Flow Input 2 Level 2");
+        strcpy(barrierJob.jobLabel, "Transition Optical Flow Input 2 Level 2");
         barrierJob.barrierDescriptor = { context->resources[FFX_OF_RESOURCE_IDENTIFIER_OPTICAL_FLOW_INPUT_2_LEVEL_2], FFX_BARRIER_TYPE_TRANSITION, FFX_RESOURCE_STATE_COMPUTE_READ, FFX_RESOURCE_STATE_UNORDERED_ACCESS, 0};
         context->contextDescription.backendInterface.fpScheduleGpuJob(&context->contextDescription.backendInterface, &barrierJob);
-        wcscpy_s(barrierJob.jobLabel, L"Transition Optical Flow Input 2 Level 3");
+        strcpy(barrierJob.jobLabel, "Transition Optical Flow Input 2 Level 3");
         barrierJob.barrierDescriptor = { context->resources[FFX_OF_RESOURCE_IDENTIFIER_OPTICAL_FLOW_INPUT_2_LEVEL_3], FFX_BARRIER_TYPE_TRANSITION, FFX_RESOURCE_STATE_COMPUTE_READ, FFX_RESOURCE_STATE_UNORDERED_ACCESS, 0};
         context->contextDescription.backendInterface.fpScheduleGpuJob(&context->contextDescription.backendInterface, &barrierJob);
-        wcscpy_s(barrierJob.jobLabel, L"Transition Optical Flow Input 2 Level 4");
+        strcpy(barrierJob.jobLabel, "Transition Optical Flow Input 2 Level 4");
         barrierJob.barrierDescriptor = { context->resources[FFX_OF_RESOURCE_IDENTIFIER_OPTICAL_FLOW_INPUT_2_LEVEL_4], FFX_BARRIER_TYPE_TRANSITION, FFX_RESOURCE_STATE_COMPUTE_READ, FFX_RESOURCE_STATE_UNORDERED_ACCESS, 0};
         context->contextDescription.backendInterface.fpScheduleGpuJob(&context->contextDescription.backendInterface, &barrierJob);
-        wcscpy_s(barrierJob.jobLabel, L"Transition Optical Flow Input 2 Level 5");
+        strcpy(barrierJob.jobLabel, "Transition Optical Flow Input 2 Level 5");
         barrierJob.barrierDescriptor = { context->resources[FFX_OF_RESOURCE_IDENTIFIER_OPTICAL_FLOW_INPUT_2_LEVEL_5], FFX_BARRIER_TYPE_TRANSITION, FFX_RESOURCE_STATE_COMPUTE_READ, FFX_RESOURCE_STATE_UNORDERED_ACCESS, 0};
         context->contextDescription.backendInterface.fpScheduleGpuJob(&context->contextDescription.backendInterface, &barrierJob);
-        wcscpy_s(barrierJob.jobLabel, L"Transition Optical Flow Input 2 Level 6");
+        strcpy(barrierJob.jobLabel, "Transition Optical Flow Input 2 Level 6");
         barrierJob.barrierDescriptor = { context->resources[FFX_OF_RESOURCE_IDENTIFIER_OPTICAL_FLOW_INPUT_2_LEVEL_6], FFX_BARRIER_TYPE_TRANSITION, FFX_RESOURCE_STATE_COMPUTE_READ, FFX_RESOURCE_STATE_UNORDERED_ACCESS, 0};
         context->contextDescription.backendInterface.fpScheduleGpuJob(&context->contextDescription.backendInterface, &barrierJob);
     }
@@ -951,12 +952,12 @@ FFX_API FfxErrorCode ffxOpticalflowGetSharedResourceDescriptions(FfxOpticalflowC
     SharedResources->opticalFlowVector = {
         FFX_HEAP_TYPE_DEFAULT,
         { FFX_RESOURCE_TYPE_TEXTURE2D, FFX_SURFACE_FORMAT_R16G16_SINT, opticalFlowTextureSize.width, opticalFlowTextureSize.height, 1, 1, FFX_RESOURCE_FLAGS_NONE, FFX_RESOURCE_USAGE_UAV },
-        FFX_RESOURCE_STATE_UNORDERED_ACCESS, L"OPTICALFLOW_Result", 0, {FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED} };
+        FFX_RESOURCE_STATE_UNORDERED_ACCESS, "OPTICALFLOW_Result", 0, {FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED} };
 
     SharedResources->opticalFlowSCD = {
         FFX_HEAP_TYPE_DEFAULT,
         { FFX_RESOURCE_TYPE_TEXTURE2D, FFX_SURFACE_FORMAT_R32_UINT, 3, 1, 1, 1, FFX_RESOURCE_FLAGS_NONE, FFX_RESOURCE_USAGE_UAV },
-        FFX_RESOURCE_STATE_UNORDERED_ACCESS, L"OPTICALFLOW_SCDOutput", 0, {FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED} };
+        FFX_RESOURCE_STATE_UNORDERED_ACCESS, "OPTICALFLOW_SCDOutput", 0, {FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED} };
 
     return FFX_OK;
 }
diff --git a/sdk/src/components/parallelsort/CMakeLists.txt b/sdk/src/components/parallelsort/CMakeLists.txt
index 2772089..f34c24f 100644
--- a/sdk/src/components/parallelsort/CMakeLists.txt
+++ b/sdk/src/components/parallelsort/CMakeLists.txt
@@ -39,9 +39,9 @@ if (FFX_PARALLEL_SORT OR FFX_ALL)
 	list(APPEND PUBLIC_SOURCES ${FFX_PUBLIC_SOURCES})
 
 	if (FFX_BUILD_AS_DLL)
-		add_library(ffx_parallelsort_${FFX_PLATFORM_NAME} SHARED ${SHARED_SOURCES} ${PRIVATE_SOURCES} ${PUBLIC_SOURCES})
+		add_library(parallelsort SHARED ${SHARED_SOURCES} ${PRIVATE_SOURCES} ${PUBLIC_SOURCES})
 	else()
-		add_library(ffx_parallelsort_${FFX_PLATFORM_NAME} STATIC ${SHARED_SOURCES} ${PRIVATE_SOURCES} ${PUBLIC_SOURCES})
+		add_library(parallelsort STATIC ${SHARED_SOURCES} ${PRIVATE_SOURCES} ${PUBLIC_SOURCES})
 	endif()
 
 	# API
@@ -49,10 +49,17 @@ if (FFX_PARALLEL_SORT OR FFX_ALL)
 	source_group("private_source" FILES ${PRIVATE_SOURCES})
 	source_group("public_source"  FILES ${PUBLIC_SOURCES})
 
-	target_include_directories(ffx_parallelsort_${FFX_PLATFORM_NAME} PUBLIC ${FFX_INCLUDE_PATH})
-	target_include_directories(ffx_parallelsort_${FFX_PLATFORM_NAME} PUBLIC ${FFX_SHARED_PATH})
+	target_include_directories(parallelsort PUBLIC
+		$<BUILD_INTERFACE:${FFX_INCLUDE_PATH}>
+		$<INSTALL_INTERFACE:include>)
+	target_include_directories(parallelsort PRIVATE ${FFX_SHARED_PATH})
 
 	set_source_files_properties(${SHADERS} PROPERTIES HEADER_FILE_ONLY TRUE)
-	set_target_properties(ffx_parallelsort_${FFX_PLATFORM_NAME} PROPERTIES FOLDER Components)
+	set_target_properties(parallelsort PROPERTIES FOLDER Components)
+	
+	install(TARGETS parallelsort EXPORT parallelsort-targets)
+	install(EXPORT parallelsort-targets 
+		DESTINATION "${CMAKE_INSTALL_DATADIR}/cmake/${PROJECT_NAME}"
+		NAMESPACE fidelityfx::)
 	
 endif()
diff --git a/sdk/src/components/parallelsort/ffx_parallelsort.cpp b/sdk/src/components/parallelsort/ffx_parallelsort.cpp
index 1b1af64..e3b5f59 100644
--- a/sdk/src/components/parallelsort/ffx_parallelsort.cpp
+++ b/sdk/src/components/parallelsort/ffx_parallelsort.cpp
@@ -20,8 +20,9 @@
 // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 // THE SOFTWARE.
 
+#include <array>        // for std::size
 #include <string.h>     // for memset
-#include <stdlib.h>     // for _countof
+#include <stdlib.h>     // for std::size
 
 #include <FidelityFX/host/ffx_parallelsort.h>
 #include "ffx_parallelsort_private.h"
@@ -31,27 +32,27 @@
 typedef struct ResourceBinding
 {
     uint32_t    index;
-    wchar_t     name[64];
+    char        name[64];
 }ResourceBinding;
 
 static const ResourceBinding uavBufferBindingTable[] =
 {
-    {FFX_PARALLELSORT_RESOURCE_IDENTIFIER_INDIRECT_COUNT_SCATTER_ARGS_BUFFER,   L"rw_count_scatter_args"},
-    {FFX_PARALLELSORT_RESOURCE_IDENTIFIER_INDIRECT_REDUCE_SCAN_ARGS_BUFER,      L"rw_reduce_scan_args"},
-    {FFX_PARALLELSORT_RESOURCE_IDENTIFIER_SUM_TABLE,                            L"rw_sum_table"},
-    {FFX_PARALLELSORT_RESOURCE_IDENTIFIER_REDUCE_TABLE,                         L"rw_reduce_table"},
-    {FFX_PARALLELSORT_RESOURCE_IDENTIFIER_SCAN_SOURCE,                          L"rw_scan_source"},
-    {FFX_PARALLELSORT_RESOURCE_IDENTIFIER_SCAN_DST,                             L"rw_scan_dest"},
-    {FFX_PARALLELSORT_RESOURCE_IDENTIFIER_SCAN_SCRATCH,                         L"rw_scan_scratch"},
-    {FFX_PARALLELSORT_RESOURCE_IDENTIFIER_KEY_SRC,                              L"rw_source_keys"},
-    {FFX_PARALLELSORT_RESOURCE_IDENTIFIER_KEY_DST,                              L"rw_dest_keys"},
-    {FFX_PARALLELSORT_RESOURCE_IDENTIFIER_PAYLOAD_SRC,                          L"rw_source_payloads"},
-    {FFX_PARALLELSORT_RESOURCE_IDENTIFIER_PAYLOAD_DST,                          L"rw_dest_payloads"},
+    {FFX_PARALLELSORT_RESOURCE_IDENTIFIER_INDIRECT_COUNT_SCATTER_ARGS_BUFFER,   "rw_count_scatter_args"},
+    {FFX_PARALLELSORT_RESOURCE_IDENTIFIER_INDIRECT_REDUCE_SCAN_ARGS_BUFER,      "rw_reduce_scan_args"},
+    {FFX_PARALLELSORT_RESOURCE_IDENTIFIER_SUM_TABLE,                            "rw_sum_table"},
+    {FFX_PARALLELSORT_RESOURCE_IDENTIFIER_REDUCE_TABLE,                         "rw_reduce_table"},
+    {FFX_PARALLELSORT_RESOURCE_IDENTIFIER_SCAN_SOURCE,                          "rw_scan_source"},
+    {FFX_PARALLELSORT_RESOURCE_IDENTIFIER_SCAN_DST,                             "rw_scan_dest"},
+    {FFX_PARALLELSORT_RESOURCE_IDENTIFIER_SCAN_SCRATCH,                         "rw_scan_scratch"},
+    {FFX_PARALLELSORT_RESOURCE_IDENTIFIER_KEY_SRC,                              "rw_source_keys"},
+    {FFX_PARALLELSORT_RESOURCE_IDENTIFIER_KEY_DST,                              "rw_dest_keys"},
+    {FFX_PARALLELSORT_RESOURCE_IDENTIFIER_PAYLOAD_SRC,                          "rw_source_payloads"},
+    {FFX_PARALLELSORT_RESOURCE_IDENTIFIER_PAYLOAD_DST,                          "rw_dest_payloads"},
 };
 
 static const ResourceBinding cbResourceBindingTable[] =
 {
-    {FFX_PARALLELSORT_CONSTANTBUFFER_IDENTIFIER_PARALLEL_SORT,                  L"cbParallelSort"},
+    {FFX_PARALLELSORT_CONSTANTBUFFER_IDENTIFIER_PARALLEL_SORT,                  "cbParallelSort"},
 };
 
 static FfxErrorCode patchResourceBindings(FfxPipelineState* inoutPipeline)
@@ -60,12 +61,12 @@ static FfxErrorCode patchResourceBindings(FfxPipelineState* inoutPipeline)
     for (uint32_t uavIndex = 0; uavIndex < inoutPipeline->uavBufferCount; ++uavIndex)
     {
         int32_t mapIndex = 0;
-        for (mapIndex = 0; mapIndex < _countof(uavBufferBindingTable); ++mapIndex)
+        for (mapIndex = 0; mapIndex < std::size(uavBufferBindingTable); ++mapIndex)
         {
-            if (0 == wcscmp(uavBufferBindingTable[mapIndex].name, inoutPipeline->uavBufferBindings[uavIndex].name))
+            if (0 == strcmp(uavBufferBindingTable[mapIndex].name, inoutPipeline->uavBufferBindings[uavIndex].name))
                 break;
         }
-        if (mapIndex == _countof(uavBufferBindingTable))
+        if (mapIndex == std::size(uavBufferBindingTable))
             return FFX_ERROR_INVALID_ARGUMENT;
 
         inoutPipeline->uavBufferBindings[uavIndex].resourceIdentifier = uavBufferBindingTable[mapIndex].index;
@@ -75,12 +76,12 @@ static FfxErrorCode patchResourceBindings(FfxPipelineState* inoutPipeline)
     for (uint32_t cbIndex = 0; cbIndex < inoutPipeline->constCount; ++cbIndex)
     {
         int32_t mapIndex = 0;
-        for (mapIndex = 0; mapIndex < _countof(cbResourceBindingTable); ++mapIndex)
+        for (mapIndex = 0; mapIndex < std::size(cbResourceBindingTable); ++mapIndex)
         {
-            if (0 == wcscmp(cbResourceBindingTable[mapIndex].name, inoutPipeline->constantBufferBindings[cbIndex].name))
+            if (0 == strcmp(cbResourceBindingTable[mapIndex].name, inoutPipeline->constantBufferBindings[cbIndex].name))
                 break;
         }
-        if (mapIndex == _countof(cbResourceBindingTable))
+        if (mapIndex == std::size(cbResourceBindingTable))
             return FFX_ERROR_INVALID_ARGUMENT;
 
         inoutPipeline->constantBufferBindings[cbIndex].resourceIdentifier = cbResourceBindingTable[mapIndex].index;
@@ -137,7 +138,7 @@ static FfxErrorCode createPipelineStates(FfxParallelSortContext_Private* context
     // Set up pipeline descriptors (basically RootSignature and binding)
     if (context->contextDescription.flags & FFX_PARALLELSORT_INDIRECT_SORT) 
     {
-        wcscpy_s(pipelineDescription.name, L"PARALLELSORT-SETUPDINDIRECTARGS");
+        strcpy(pipelineDescription.name, "PARALLELSORT-SETUPDINDIRECTARGS");
         FFX_VALIDATE(context->contextDescription.backendInterface.fpCreatePipeline(&context->contextDescription.backendInterface, FFX_EFFECT_PARALLEL_SORT, FFX_PARALLELSORT_PASS_SETUP_INDIRECT_ARGS,
             getPipelinePermutationFlags(contextFlags, FFX_PARALLELSORT_PASS_SETUP_INDIRECT_ARGS, supportedFP16, canForceWave64),
             &pipelineDescription, context->effectContextId, &context->pipelineSetupIndirectArgs));
@@ -149,7 +150,7 @@ static FfxErrorCode createPipelineStates(FfxParallelSortContext_Private* context
     {
         // no indirect on this pipeline
         pipelineDescription.indirectWorkload = 0;
-        wcscpy_s(pipelineDescription.name, L"PARALLELSORT-SCAN");
+        strcpy(pipelineDescription.name, "PARALLELSORT-SCAN");
         FFX_VALIDATE(context->contextDescription.backendInterface.fpCreatePipeline(&context->contextDescription.backendInterface, FFX_EFFECT_PARALLEL_SORT, FFX_PARALLELSORT_PASS_SCAN,
             getPipelinePermutationFlags(contextFlags, FFX_PARALLELSORT_PASS_SCAN, supportedFP16, canForceWave64),
             &pipelineDescription, context->effectContextId, &context->pipelineScan[i]));
@@ -159,22 +160,22 @@ static FfxErrorCode createPipelineStates(FfxParallelSortContext_Private* context
             pipelineDescription.indirectWorkload = 1;
         }
 
-        wcscpy_s(pipelineDescription.name, L"PARALLELSORT-SUM");
+        strcpy(pipelineDescription.name, "PARALLELSORT-SUM");
         FFX_VALIDATE(context->contextDescription.backendInterface.fpCreatePipeline(&context->contextDescription.backendInterface, FFX_EFFECT_PARALLEL_SORT, FFX_PARALLELSORT_PASS_SUM,
             getPipelinePermutationFlags(contextFlags, FFX_PARALLELSORT_PASS_SUM, supportedFP16, canForceWave64),
             &pipelineDescription, context->effectContextId, &context->pipelineCount[i]));
 
-        wcscpy_s(pipelineDescription.name, L"PARALLELSORT-REDUCE");
+        strcpy(pipelineDescription.name, "PARALLELSORT-REDUCE");
         FFX_VALIDATE(context->contextDescription.backendInterface.fpCreatePipeline(&context->contextDescription.backendInterface, FFX_EFFECT_PARALLEL_SORT, FFX_PARALLELSORT_PASS_REDUCE,
             getPipelinePermutationFlags(contextFlags, FFX_PARALLELSORT_PASS_REDUCE, supportedFP16, canForceWave64),
             &pipelineDescription, context->effectContextId, &context->pipelineReduce[i]));
 
-        wcscpy_s(pipelineDescription.name, L"PARALLELSORT-SCAN_ADD");
+        strcpy(pipelineDescription.name, "PARALLELSORT-SCAN_ADD");
         FFX_VALIDATE(context->contextDescription.backendInterface.fpCreatePipeline(&context->contextDescription.backendInterface, FFX_EFFECT_PARALLEL_SORT, FFX_PARALLELSORT_PASS_SCAN_ADD,
             getPipelinePermutationFlags(contextFlags, FFX_PARALLELSORT_PASS_SCAN_ADD, supportedFP16, canForceWave64),
             &pipelineDescription, context->effectContextId, &context->pipelineScanAdd[i]));
 
-        wcscpy_s(pipelineDescription.name, L"PARALLELSORT-SCATTER");
+        strcpy(pipelineDescription.name, "PARALLELSORT-SCATTER");
         FFX_VALIDATE(context->contextDescription.backendInterface.fpCreatePipeline(&context->contextDescription.backendInterface, FFX_EFFECT_PARALLEL_SORT, FFX_PARALLELSORT_PASS_SCATTER,
             getPipelinePermutationFlags(contextFlags, FFX_PARALLELSORT_PASS_SCATTER, supportedFP16, canForceWave64),
             &pipelineDescription, context->effectContextId, &context->pipelineScatter[i]));
@@ -231,7 +232,7 @@ static FfxErrorCode parallelSortCreate(FfxParallelSortContext_Private* context,
     // declare internal resources needed
     const FfxInternalResourceDescription internalResourceDescs[] = {
         {FFX_PARALLELSORT_RESOURCE_IDENTIFIER_KEY_SCRATCH_BUFFER,
-         L"ParallelSort_SortScratchBuffer",
+         "ParallelSort_SortScratchBuffer",
          FFX_RESOURCE_TYPE_BUFFER,
          FFX_RESOURCE_USAGE_UAV,
          FFX_SURFACE_FORMAT_UNKNOWN,
@@ -242,7 +243,7 @@ static FfxErrorCode parallelSortCreate(FfxParallelSortContext_Private* context,
          {FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED}},
 
         {FFX_PARALLELSORT_RESOURCE_IDENTIFIER_PAYLOAD_SCRATCH_BUFFER,
-         L"ParallelSort_PayloadScratchBuffer",
+         "ParallelSort_PayloadScratchBuffer",
          FFX_RESOURCE_TYPE_BUFFER,
          FFX_RESOURCE_USAGE_UAV,
          FFX_SURFACE_FORMAT_UNKNOWN,
@@ -253,7 +254,7 @@ static FfxErrorCode parallelSortCreate(FfxParallelSortContext_Private* context,
          {FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED}},
 
         {FFX_PARALLELSORT_RESOURCE_IDENTIFIER_SCRATCH_BUFFER,
-         L"ParallelSort_ScratchBuffer",
+         "ParallelSort_ScratchBuffer",
          FFX_RESOURCE_TYPE_BUFFER,
          FFX_RESOURCE_USAGE_UAV,
          FFX_SURFACE_FORMAT_UNKNOWN,
@@ -264,7 +265,7 @@ static FfxErrorCode parallelSortCreate(FfxParallelSortContext_Private* context,
          {FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED}},
 
         {FFX_PARALLELSORT_RESOURCE_IDENTIFIER_REDUCED_SCRATCH_BUFFER,
-         L"ParallelSort_ReducedScratchBuffer",
+         "ParallelSort_ReducedScratchBuffer",
          FFX_RESOURCE_TYPE_BUFFER,
          FFX_RESOURCE_USAGE_UAV,
          FFX_SURFACE_FORMAT_UNKNOWN,
@@ -275,7 +276,7 @@ static FfxErrorCode parallelSortCreate(FfxParallelSortContext_Private* context,
          {FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED}},
 
         {FFX_PARALLELSORT_RESOURCE_IDENTIFIER_INDIRECT_COUNT_SCATTER_ARGS_BUFFER,
-         L"ParallelSort_IndirectCountScatterArgsBuffer",
+         "ParallelSort_IndirectCountScatterArgsBuffer",
          FFX_RESOURCE_TYPE_BUFFER,
          (FfxResourceUsage)(FFX_RESOURCE_USAGE_UAV | FFX_RESOURCE_USAGE_INDIRECT),
          FFX_SURFACE_FORMAT_UNKNOWN,
@@ -286,7 +287,7 @@ static FfxErrorCode parallelSortCreate(FfxParallelSortContext_Private* context,
          {FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED}},
 
         {FFX_PARALLELSORT_RESOURCE_IDENTIFIER_INDIRECT_REDUCE_SCAN_ARGS_BUFER,
-         L"ParallelSort_IndirectReduceScanArgsBuffer",
+         "ParallelSort_IndirectReduceScanArgsBuffer",
          FFX_RESOURCE_TYPE_BUFFER,
          (FfxResourceUsage)(FFX_RESOURCE_USAGE_UAV | FFX_RESOURCE_USAGE_INDIRECT),
          FFX_SURFACE_FORMAT_UNKNOWN,
@@ -332,7 +333,7 @@ static void scheduleDispatch(FfxParallelSortContext_Private* pContext, const Ffx
                                 const FfxPipelineState* pPipeline, uint32_t dispatchX, uint32_t dispatchY, uint32_t dispatchZ)
 {
     FfxGpuJobDescription dispatchJob = {FFX_GPU_JOB_COMPUTE};
-    wcscpy_s(dispatchJob.jobLabel, pPipeline->name);
+    strcpy(dispatchJob.jobLabel, pPipeline->name);
 
     // Buffer uavs
     for (uint32_t currentUnorderedAccessViewIndex = 0; currentUnorderedAccessViewIndex < pPipeline->uavBufferCount; ++currentUnorderedAccessViewIndex) {
@@ -341,7 +342,7 @@ static void scheduleDispatch(FfxParallelSortContext_Private* pContext, const Ffx
         const FfxResourceInternal currentResource = pContext->uavResources[currentResourceId];
         dispatchJob.computeJobDescriptor.uavBuffers[currentUnorderedAccessViewIndex].resource = currentResource;
 #ifdef FFX_DEBUG
-        wcscpy_s(dispatchJob.computeJobDescriptor.uavBuffers[currentUnorderedAccessViewIndex].name,
+        strcpy(dispatchJob.computeJobDescriptor.uavBuffers[currentUnorderedAccessViewIndex].name,
                  pPipeline->uavBufferBindings[currentUnorderedAccessViewIndex].name);
 #endif
     }
@@ -352,7 +353,7 @@ static void scheduleDispatch(FfxParallelSortContext_Private* pContext, const Ffx
     dispatchJob.computeJobDescriptor.pipeline      = *pPipeline;
 
 #ifdef FFX_DEBUG
-    wcscpy_s(dispatchJob.computeJobDescriptor.cbNames[0], pPipeline->constantBufferBindings[0].name);
+    strcpy(dispatchJob.computeJobDescriptor.cbNames[0], pPipeline->constantBufferBindings[0].name);
 #endif
     dispatchJob.computeJobDescriptor.cbs[0] = pContext->constantBuffer;
 
@@ -372,7 +373,7 @@ static void scheduleIndirectDispatch(FfxParallelSortContext_Private* pContext, c
         const FfxResourceInternal currentResource = pContext->uavResources[currentResourceId];
         jobDescriptor.uavBuffers[currentUnorderedAccessViewIndex].resource = currentResource;
 #ifdef FFX_DEBUG
-        wcscpy_s(jobDescriptor.uavBuffers[currentUnorderedAccessViewIndex].name, pPipeline->uavBufferBindings[currentUnorderedAccessViewIndex].name);
+        strcpy(jobDescriptor.uavBuffers[currentUnorderedAccessViewIndex].name, pPipeline->uavBufferBindings[currentUnorderedAccessViewIndex].name);
 #endif
     }
 
@@ -382,12 +383,12 @@ static void scheduleIndirectDispatch(FfxParallelSortContext_Private* pContext, c
 
     // Copy constants
 #ifdef FFX_DEBUG
-    wcscpy_s(jobDescriptor.cbNames[0], pPipeline->constantBufferBindings[0].name);
+    strcpy(jobDescriptor.cbNames[0], pPipeline->constantBufferBindings[0].name);
 #endif
     jobDescriptor.cbs[0] = pContext->constantBuffer;
 
     FfxGpuJobDescription dispatchJob = { FFX_GPU_JOB_COMPUTE };
-    wcscpy_s(dispatchJob.jobLabel, pPipeline->name);
+    strcpy(dispatchJob.jobLabel, pPipeline->name);
     dispatchJob.computeJobDescriptor = jobDescriptor;
 
     pContext->contextDescription.backendInterface.fpScheduleGpuJob(&pContext->contextDescription.backendInterface, &dispatchJob);
diff --git a/sdk/src/components/spd/CMakeLists.txt b/sdk/src/components/spd/CMakeLists.txt
index 06cffe5..bebb608 100644
--- a/sdk/src/components/spd/CMakeLists.txt
+++ b/sdk/src/components/spd/CMakeLists.txt
@@ -38,9 +38,9 @@ if (FFX_SPD OR FFX_ALL)
 	list(APPEND PUBLIC_SOURCES ${FFX_PUBLIC_SOURCES})
 
 	if (FFX_BUILD_AS_DLL)
-		add_library(ffx_spd_${FFX_PLATFORM_NAME} SHARED ${SHARED_SOURCES} ${PRIVATE_SOURCES} ${PUBLIC_SOURCES})
+		add_library(spd SHARED ${SHARED_SOURCES} ${PRIVATE_SOURCES} ${PUBLIC_SOURCES})
 	else()
-		add_library(ffx_spd_${FFX_PLATFORM_NAME} STATIC ${SHARED_SOURCES} ${PRIVATE_SOURCES} ${PUBLIC_SOURCES})
+		add_library(spd STATIC ${SHARED_SOURCES} ${PRIVATE_SOURCES} ${PUBLIC_SOURCES})
 	endif()
 
 	# API
@@ -48,10 +48,17 @@ if (FFX_SPD OR FFX_ALL)
 	source_group("private_source" FILES ${PRIVATE_SOURCES})
 	source_group("public_source"  FILES ${PUBLIC_SOURCES})
 
-	target_include_directories(ffx_spd_${FFX_PLATFORM_NAME} PUBLIC ${FFX_INCLUDE_PATH})
-	target_include_directories(ffx_spd_${FFX_PLATFORM_NAME} PUBLIC ${FFX_SHARED_PATH})
+	target_include_directories(spd PUBLIC
+		$<BUILD_INTERFACE:${FFX_INCLUDE_PATH}>
+		$<INSTALL_INTERFACE:include>)
+	target_include_directories(spd PRIVATE ${FFX_SHARED_PATH})
 
 	set_source_files_properties(${SHADERS} PROPERTIES HEADER_FILE_ONLY TRUE)
-	set_target_properties(ffx_spd_${FFX_PLATFORM_NAME} PROPERTIES FOLDER Components)
+	set_target_properties(spd PROPERTIES FOLDER Components)
+	
+	install(TARGETS spd EXPORT spd-targets)
+	install(EXPORT spd-targets 
+		DESTINATION "${CMAKE_INSTALL_DATADIR}/cmake/${PROJECT_NAME}"
+		NAMESPACE fidelityfx::)
 	
 endif()
diff --git a/sdk/src/components/spd/ffx_spd.cpp b/sdk/src/components/spd/ffx_spd.cpp
index 1727755..5bd46dc 100644
--- a/sdk/src/components/spd/ffx_spd.cpp
+++ b/sdk/src/components/spd/ffx_spd.cpp
@@ -20,8 +20,9 @@
 // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 // THE SOFTWARE.
 
+#include <array>        // for std::size
 #include <string.h>     // for memset
-#include <stdlib.h>     // for _countof
+#include <stdlib.h>     // 
 #include <cmath>        // for fabs, abs, sinf, sqrt, etc.
 
 #include <FidelityFX/host/ffx_spd.h>
@@ -36,28 +37,28 @@
 typedef struct ResourceBinding
 {
     uint32_t    index;
-    wchar_t     name[64];
+    char        name[64];
 }ResourceBinding;
 
 static const ResourceBinding srvTextureBindingTable[] =
 {
-    {FFX_SPD_RESOURCE_IDENTIFIER_INPUT_DOWNSAMPLE_SRC,                   L"r_input_downsample_src"},
+    {FFX_SPD_RESOURCE_IDENTIFIER_INPUT_DOWNSAMPLE_SRC,                   "r_input_downsample_src"},
 };
 
 static const ResourceBinding uavBufferBindingTable[] =
 {
-    {FFX_SPD_RESOURCE_IDENTIFIER_INTERNAL_GLOBAL_ATOMIC,           L"rw_internal_global_atomic"},
+    {FFX_SPD_RESOURCE_IDENTIFIER_INTERNAL_GLOBAL_ATOMIC,           "rw_internal_global_atomic"},
 };
 
 static const ResourceBinding uavTextureBindingTable[] =
 {
-    {FFX_SPD_RESOURCE_IDENTIFIER_INPUT_DOWNSAMPLE_SRC_MID_MIPMAP,  L"rw_input_downsample_src_mid_mip"},
-    {FFX_SPD_RESOURCE_IDENTIFIER_INPUT_DOWNSAMPLE_SRC_MIPMAP_0,    L"rw_input_downsample_src_mips"},
+    {FFX_SPD_RESOURCE_IDENTIFIER_INPUT_DOWNSAMPLE_SRC_MID_MIPMAP,  "rw_input_downsample_src_mid_mip"},
+    {FFX_SPD_RESOURCE_IDENTIFIER_INPUT_DOWNSAMPLE_SRC_MIPMAP_0,    "rw_input_downsample_src_mips"},
 };
 
 static const ResourceBinding cbResourceBindingTable[] =
 {
-    {FFX_SPD_CONSTANTBUFFER_IDENTIFIER_SPD,                        L"cbSPD"},
+    {FFX_SPD_CONSTANTBUFFER_IDENTIFIER_SPD,                        "cbSPD"},
 };
 
 static FfxErrorCode patchResourceBindings(FfxPipelineState* inoutPipeline)
@@ -66,12 +67,12 @@ static FfxErrorCode patchResourceBindings(FfxPipelineState* inoutPipeline)
     for (uint32_t srvIndex = 0; srvIndex < inoutPipeline->srvTextureCount; ++srvIndex)
     {
         int32_t mapIndex = 0;
-        for (mapIndex = 0; mapIndex < _countof(srvTextureBindingTable); ++mapIndex)
+        for (mapIndex = 0; mapIndex < std::size(srvTextureBindingTable); ++mapIndex)
         {
-            if (0 == wcscmp(srvTextureBindingTable[mapIndex].name, inoutPipeline->srvTextureBindings[srvIndex].name))
+            if (0 == strcmp(srvTextureBindingTable[mapIndex].name, inoutPipeline->srvTextureBindings[srvIndex].name))
                 break;
         }
-        if (mapIndex == _countof(srvTextureBindingTable))
+        if (mapIndex == std::size(srvTextureBindingTable))
             return FFX_ERROR_INVALID_ARGUMENT;
 
         inoutPipeline->srvTextureBindings[srvIndex].resourceIdentifier = srvTextureBindingTable[mapIndex].index;
@@ -81,12 +82,12 @@ static FfxErrorCode patchResourceBindings(FfxPipelineState* inoutPipeline)
     for (uint32_t uavIndex = 0; uavIndex < inoutPipeline->uavBufferCount; ++uavIndex)
     {
         int32_t mapIndex = 0;
-        for (mapIndex = 0; mapIndex < _countof(uavBufferBindingTable); ++mapIndex)
+        for (mapIndex = 0; mapIndex < std::size(uavBufferBindingTable); ++mapIndex)
         {
-            if (0 == wcscmp(uavBufferBindingTable[mapIndex].name, inoutPipeline->uavBufferBindings[uavIndex].name))
+            if (0 == strcmp(uavBufferBindingTable[mapIndex].name, inoutPipeline->uavBufferBindings[uavIndex].name))
                 break;
         }
-        if (mapIndex == _countof(uavBufferBindingTable))
+        if (mapIndex == std::size(uavBufferBindingTable))
             return FFX_ERROR_INVALID_ARGUMENT;
 
         inoutPipeline->uavBufferBindings[uavIndex].resourceIdentifier = uavBufferBindingTable[mapIndex].index;
@@ -96,12 +97,12 @@ static FfxErrorCode patchResourceBindings(FfxPipelineState* inoutPipeline)
     for (uint32_t uavIndex = 0; uavIndex < inoutPipeline->uavTextureCount; ++uavIndex)
     {
         int32_t mapIndex = 0;
-        for (mapIndex = 0; mapIndex < _countof(uavTextureBindingTable); ++mapIndex)
+        for (mapIndex = 0; mapIndex < std::size(uavTextureBindingTable); ++mapIndex)
         {
-            if (0 == wcscmp(uavTextureBindingTable[mapIndex].name, inoutPipeline->uavTextureBindings[uavIndex].name))
+            if (0 == strcmp(uavTextureBindingTable[mapIndex].name, inoutPipeline->uavTextureBindings[uavIndex].name))
                 break;
         }
-        if (mapIndex == _countof(uavTextureBindingTable))
+        if (mapIndex == std::size(uavTextureBindingTable))
             return FFX_ERROR_INVALID_ARGUMENT;
 
         inoutPipeline->uavTextureBindings[uavIndex].resourceIdentifier = uavTextureBindingTable[mapIndex].index;
@@ -111,12 +112,12 @@ static FfxErrorCode patchResourceBindings(FfxPipelineState* inoutPipeline)
     for (uint32_t cbIndex = 0; cbIndex < inoutPipeline->constCount; ++cbIndex)
     {
         int32_t mapIndex = 0;
-        for (mapIndex = 0; mapIndex < _countof(cbResourceBindingTable); ++mapIndex)
+        for (mapIndex = 0; mapIndex < std::size(cbResourceBindingTable); ++mapIndex)
         {
-            if (0 == wcscmp(cbResourceBindingTable[mapIndex].name, inoutPipeline->constantBufferBindings[cbIndex].name))
+            if (0 == strcmp(cbResourceBindingTable[mapIndex].name, inoutPipeline->constantBufferBindings[cbIndex].name))
                 break;
         }
-        if (mapIndex == _countof(cbResourceBindingTable))
+        if (mapIndex == std::size(cbResourceBindingTable))
             return FFX_ERROR_INVALID_ARGUMENT;
 
         inoutPipeline->constantBufferBindings[cbIndex].resourceIdentifier = cbResourceBindingTable[mapIndex].index;
@@ -190,7 +191,7 @@ static FfxErrorCode createPipelineStates(FfxSpdContext_Private* context)
     FfxSpdDownsampleFilter downsampleFilter = context->contextDescription.downsampleFilter;
 
     // Set up pipeline descriptors (basically RootSignature and binding)
-    wcscpy_s(pipelineDescription.name, L"SPD-DOWNSAMPLE");
+    strcpy(pipelineDescription.name, "SPD-DOWNSAMPLE");
     FFX_VALIDATE(context->contextDescription.backendInterface.fpCreatePipeline(&context->contextDescription.backendInterface, FFX_EFFECT_SPD, FFX_SPD_PASS_DOWNSAMPLE,
         getPipelinePermutationFlags(contextFlags, downsampleFilter, FFX_SPD_PASS_DOWNSAMPLE, supportedFP16, canForceWave64),
         &pipelineDescription, context->effectContextId, &context->pipelineDownsample));
@@ -204,7 +205,7 @@ static FfxErrorCode createPipelineStates(FfxSpdContext_Private* context)
 static void scheduleDispatch(FfxSpdContext_Private* context, const FfxSpdDispatchDescription* params, const FfxPipelineState* pipeline, uint32_t dispatchX, uint32_t dispatchY, uint32_t dispatchZ)
 {
     FfxGpuJobDescription dispatchJob = { FFX_GPU_JOB_COMPUTE };
-    wcscpy_s(dispatchJob.jobLabel, pipeline->name);
+    strcpy(dispatchJob.jobLabel, pipeline->name);
 
     // Texture srv
     for (uint32_t currentShaderResourceViewIndex = 0; currentShaderResourceViewIndex < pipeline->srvTextureCount; ++currentShaderResourceViewIndex) {
@@ -213,7 +214,7 @@ static void scheduleDispatch(FfxSpdContext_Private* context, const FfxSpdDispatc
         const FfxResourceInternal currentResource = context->srvResources[currentResourceId];
         dispatchJob.computeJobDescriptor.srvTextures[currentShaderResourceViewIndex].resource = currentResource;
 #ifdef FFX_DEBUG
-        wcscpy_s(dispatchJob.computeJobDescriptor.srvTextures[currentShaderResourceViewIndex].name, pipeline->srvTextureBindings[currentShaderResourceViewIndex].name);
+        strcpy(dispatchJob.computeJobDescriptor.srvTextures[currentShaderResourceViewIndex].name, pipeline->srvTextureBindings[currentShaderResourceViewIndex].name);
 #endif
     }
 
@@ -223,7 +224,7 @@ static void scheduleDispatch(FfxSpdContext_Private* context, const FfxSpdDispatc
 
         uint32_t currentResourceId = pipeline->uavTextureBindings[currentUnorderedAccessViewIndex].resourceIdentifier;
 #ifdef FFX_DEBUG
-        wcscpy_s(dispatchJob.computeJobDescriptor.uavTextures[currentUnorderedAccessViewIndex].name, pipeline->uavTextureBindings[currentUnorderedAccessViewIndex].name);
+        strcpy(dispatchJob.computeJobDescriptor.uavTextures[currentUnorderedAccessViewIndex].name, pipeline->uavTextureBindings[currentUnorderedAccessViewIndex].name);
 #endif
         // Mid-level mip
         if (currentResourceId == FFX_SPD_RESOURCE_IDENTIFIER_INPUT_DOWNSAMPLE_SRC_MID_MIPMAP)
@@ -266,7 +267,7 @@ static void scheduleDispatch(FfxSpdContext_Private* context, const FfxSpdDispatc
         const FfxResourceInternal currentResource = context->uavResources[currentResourceId];
         dispatchJob.computeJobDescriptor.uavBuffers[currentUnorderedAccessViewIndex].resource = currentResource;
 #ifdef FFX_DEBUG
-        wcscpy_s(dispatchJob.computeJobDescriptor.uavBuffers[currentUnorderedAccessViewIndex].name,
+        strcpy(dispatchJob.computeJobDescriptor.uavBuffers[currentUnorderedAccessViewIndex].name,
                  pipeline->uavBufferBindings[currentUnorderedAccessViewIndex].name);
 #endif
     }
@@ -276,7 +277,7 @@ static void scheduleDispatch(FfxSpdContext_Private* context, const FfxSpdDispatc
     dispatchJob.computeJobDescriptor.dimensions[2] = dispatchZ;
     dispatchJob.computeJobDescriptor.pipeline      = *pipeline;
 #ifdef FFX_DEBUG
-    wcscpy_s(dispatchJob.computeJobDescriptor.cbNames[0], pipeline->constantBufferBindings[0].name);
+    strcpy(dispatchJob.computeJobDescriptor.cbNames[0], pipeline->constantBufferBindings[0].name);
 #endif
     dispatchJob.computeJobDescriptor.cbs[0] = context->constantBuffer;
 
@@ -358,7 +359,7 @@ static FfxErrorCode spdCreate(FfxSpdContext_Private* context, const FfxSpdContex
 
     // Create the atomic buffer resource used as a counter in SPD
     const FfxInternalResourceDescription internalSurfaceDesc = {FFX_SPD_RESOURCE_IDENTIFIER_INTERNAL_GLOBAL_ATOMIC,
-                                                                L"SPD_AtomicCounter",
+                                                                "SPD_AtomicCounter",
                                                                 FFX_RESOURCE_TYPE_BUFFER,
                                                                 FFX_RESOURCE_USAGE_UAV,
                                                                 FFX_SURFACE_FORMAT_UNKNOWN,
diff --git a/sdk/src/components/sssr/CMakeLists.txt b/sdk/src/components/sssr/CMakeLists.txt
index 77cd284..ed27b2b 100644
--- a/sdk/src/components/sssr/CMakeLists.txt
+++ b/sdk/src/components/sssr/CMakeLists.txt
@@ -39,9 +39,9 @@ if (FFX_SSSR OR FFX_ALL)
 	list(APPEND PUBLIC_SOURCES ${FFX_PUBLIC_SOURCES})
 
 	if (FFX_BUILD_AS_DLL)
-		add_library(ffx_sssr_${FFX_PLATFORM_NAME} SHARED ${SHARED_SOURCES} ${PRIVATE_SOURCES} ${PUBLIC_SOURCES})
+		add_library(sssr SHARED ${SHARED_SOURCES} ${PRIVATE_SOURCES} ${PUBLIC_SOURCES})
 	else()
-		add_library(ffx_sssr_${FFX_PLATFORM_NAME} STATIC ${SHARED_SOURCES} ${PRIVATE_SOURCES} ${PUBLIC_SOURCES})
+		add_library(sssr STATIC ${SHARED_SOURCES} ${PRIVATE_SOURCES} ${PUBLIC_SOURCES})
 	endif()
 
 	# API
@@ -49,15 +49,22 @@ if (FFX_SSSR OR FFX_ALL)
 	source_group("private_source" FILES ${PRIVATE_SOURCES})
 	source_group("public_source"  FILES ${PUBLIC_SOURCES})
 
-	target_link_libraries(ffx_sssr_${FFX_PLATFORM_NAME} PRIVATE ffx_denoiser_${FFX_PLATFORM_NAME})
+	target_link_libraries(sssr PRIVATE denoiser)
 
-	target_include_directories(ffx_sssr_${FFX_PLATFORM_NAME} PUBLIC ${FFX_INCLUDE_PATH})
-	target_include_directories(ffx_sssr_${FFX_PLATFORM_NAME} PUBLIC ${FFX_SHARED_PATH})
+	target_include_directories(sssr PUBLIC
+		$<BUILD_INTERFACE:${FFX_INCLUDE_PATH}>
+		$<INSTALL_INTERFACE:include>)
+	target_include_directories(sssr PRIVATE ${FFX_SHARED_PATH})
 
 	# Dependencies
- 	add_dependencies(ffx_sssr_${FFX_PLATFORM_NAME} ffx_denoiser_${FFX_PLATFORM_NAME})
+ 	add_dependencies(sssr denoiser)
 
 	set_source_files_properties(${SHADERS} PROPERTIES HEADER_FILE_ONLY TRUE)
-	set_target_properties(ffx_sssr_${FFX_PLATFORM_NAME} PROPERTIES FOLDER Components)
+	set_target_properties(sssr PROPERTIES FOLDER Components)
 
+	install(TARGETS sssr EXPORT sssr-targets)
+	install(EXPORT sssr-targets 
+		DESTINATION "${CMAKE_INSTALL_DATADIR}/cmake/${PROJECT_NAME}"
+		NAMESPACE fidelityfx::)
+	
 endif()
diff --git a/sdk/src/components/sssr/ffx_sssr.cpp b/sdk/src/components/sssr/ffx_sssr.cpp
index 2d5c559..16eab17 100644
--- a/sdk/src/components/sssr/ffx_sssr.cpp
+++ b/sdk/src/components/sssr/ffx_sssr.cpp
@@ -41,49 +41,49 @@ namespace _noiseBuffers
 typedef struct ResourceBinding
 {
     uint32_t    index;
-    wchar_t     name[64];
+    char        name[64];
 }ResourceBinding;
 
 static const ResourceBinding srvTextureBindingTable[] =
 {
-    {FFX_SSSR_RESOURCE_IDENTIFIER_INPUT_COLOR,                  L"r_input_color"},
-    {FFX_SSSR_RESOURCE_IDENTIFIER_INPUT_DEPTH,                  L"r_input_depth"},
-    {FFX_SSSR_RESOURCE_IDENTIFIER_INPUT_MOTION_VECTORS,         L"r_input_motion_vectors"},
-    {FFX_SSSR_RESOURCE_IDENTIFIER_INPUT_NORMAL,                 L"r_input_normal"},
-    {FFX_SSSR_RESOURCE_IDENTIFIER_INPUT_MATERIAL_PARAMETERS,    L"r_input_material_parameters"},
-    {FFX_SSSR_RESOURCE_IDENTIFIER_INPUT_ENVIRONMENT_MAP,        L"r_input_environment_map"},
-    {FFX_SSSR_RESOURCE_IDENTIFIER_DEPTH_HIERARCHY,              L"r_depth_hierarchy"},
-    {FFX_SSSR_RESOURCE_IDENTIFIER_RADIANCE,                     L"r_radiance"},
-    {FFX_SSSR_RESOURCE_IDENTIFIER_RADIANCE_HISTORY,             L"r_radiance_history"},
-    {FFX_SSSR_RESOURCE_IDENTIFIER_VARIANCE,                     L"r_variance"},
-    {FFX_SSSR_RESOURCE_IDENTIFIER_EXTRACTED_ROUGHNESS,          L"r_extracted_roughness"},
-    {FFX_SSSR_RESOURCE_IDENTIFIER_SOBOL_BUFFER,                 L"r_sobol_buffer"},
-    {FFX_SSSR_RESOURCE_IDENTIFIER_SCRAMBLING_TILE_BUFFER,       L"r_scrambling_tile_buffer"},
-    {FFX_SSSR_RESOURCE_IDENTIFIER_BLUE_NOISE_TEXTURE,           L"r_blue_noise_texture"},
-    {FFX_SSSR_RESOURCE_IDENTIFIER_INPUT_BRDF_TEXTURE,           L"r_input_brdf_texture"},
+    {FFX_SSSR_RESOURCE_IDENTIFIER_INPUT_COLOR,                  "r_input_color"},
+    {FFX_SSSR_RESOURCE_IDENTIFIER_INPUT_DEPTH,                  "r_input_depth"},
+    {FFX_SSSR_RESOURCE_IDENTIFIER_INPUT_MOTION_VECTORS,         "r_input_motion_vectors"},
+    {FFX_SSSR_RESOURCE_IDENTIFIER_INPUT_NORMAL,                 "r_input_normal"},
+    {FFX_SSSR_RESOURCE_IDENTIFIER_INPUT_MATERIAL_PARAMETERS,    "r_input_material_parameters"},
+    {FFX_SSSR_RESOURCE_IDENTIFIER_INPUT_ENVIRONMENT_MAP,        "r_input_environment_map"},
+    {FFX_SSSR_RESOURCE_IDENTIFIER_DEPTH_HIERARCHY,              "r_depth_hierarchy"},
+    {FFX_SSSR_RESOURCE_IDENTIFIER_RADIANCE,                     "r_radiance"},
+    {FFX_SSSR_RESOURCE_IDENTIFIER_RADIANCE_HISTORY,             "r_radiance_history"},
+    {FFX_SSSR_RESOURCE_IDENTIFIER_VARIANCE,                     "r_variance"},
+    {FFX_SSSR_RESOURCE_IDENTIFIER_EXTRACTED_ROUGHNESS,          "r_extracted_roughness"},
+    {FFX_SSSR_RESOURCE_IDENTIFIER_SOBOL_BUFFER,                 "r_sobol_buffer"},
+    {FFX_SSSR_RESOURCE_IDENTIFIER_SCRAMBLING_TILE_BUFFER,       "r_scrambling_tile_buffer"},
+    {FFX_SSSR_RESOURCE_IDENTIFIER_BLUE_NOISE_TEXTURE,           "r_blue_noise_texture"},
+    {FFX_SSSR_RESOURCE_IDENTIFIER_INPUT_BRDF_TEXTURE,           "r_input_brdf_texture"},
 };
 
 static const ResourceBinding uavTextureBindingTable[] =
 {
-    {FFX_SSSR_RESOURCE_IDENTIFIER_RADIANCE,                        L"rw_radiance"},
-    {FFX_SSSR_RESOURCE_IDENTIFIER_VARIANCE,                        L"rw_variance"},
-    {FFX_SSSR_RESOURCE_IDENTIFIER_EXTRACTED_ROUGHNESS,             L"rw_extracted_roughness"},
-    {FFX_SSSR_RESOURCE_IDENTIFIER_BLUE_NOISE_TEXTURE,              L"rw_blue_noise_texture"},
-    {FFX_SSSR_RESOURCE_IDENTIFIER_DEPTH_HIERARCHY,                 L"rw_depth_hierarchy"},
+    {FFX_SSSR_RESOURCE_IDENTIFIER_RADIANCE,                        "rw_radiance"},
+    {FFX_SSSR_RESOURCE_IDENTIFIER_VARIANCE,                        "rw_variance"},
+    {FFX_SSSR_RESOURCE_IDENTIFIER_EXTRACTED_ROUGHNESS,             "rw_extracted_roughness"},
+    {FFX_SSSR_RESOURCE_IDENTIFIER_BLUE_NOISE_TEXTURE,              "rw_blue_noise_texture"},
+    {FFX_SSSR_RESOURCE_IDENTIFIER_DEPTH_HIERARCHY,                 "rw_depth_hierarchy"},
 };
 
 static const ResourceBinding uavBufferBindingTable[] =
 {
-    {FFX_SSSR_RESOURCE_IDENTIFIER_RAY_LIST,                        L"rw_ray_list"},
-    {FFX_SSSR_RESOURCE_IDENTIFIER_DENOISER_TILE_LIST,              L"rw_denoiser_tile_list"},
-    {FFX_SSSR_RESOURCE_IDENTIFIER_RAY_COUNTER,                     L"rw_ray_counter"},
-    {FFX_SSSR_RESOURCE_IDENTIFIER_INTERSECTION_PASS_INDIRECT_ARGS, L"rw_intersection_pass_indirect_args"},
-    {FFX_SSSR_RESOURCE_IDENTIFIER_SPD_GLOBAL_ATOMIC,               L"rw_spd_global_atomic"},
+    {FFX_SSSR_RESOURCE_IDENTIFIER_RAY_LIST,                        "rw_ray_list"},
+    {FFX_SSSR_RESOURCE_IDENTIFIER_DENOISER_TILE_LIST,              "rw_denoiser_tile_list"},
+    {FFX_SSSR_RESOURCE_IDENTIFIER_RAY_COUNTER,                     "rw_ray_counter"},
+    {FFX_SSSR_RESOURCE_IDENTIFIER_INTERSECTION_PASS_INDIRECT_ARGS, "rw_intersection_pass_indirect_args"},
+    {FFX_SSSR_RESOURCE_IDENTIFIER_SPD_GLOBAL_ATOMIC,               "rw_spd_global_atomic"},
 };
 
 static const ResourceBinding constantBufferBindingTable[] =
 {
-    {FFX_SSSR_CONSTANTBUFFER_IDENTIFIER_SSSR,     L"cbSSSR"},
+    {FFX_SSSR_CONSTANTBUFFER_IDENTIFIER_SSSR,     "cbSSSR"},
 };
 
 template<typename T> inline T DivideRoundingUp(T a, T b)
@@ -98,7 +98,7 @@ static FfxErrorCode patchResourceBindings(FfxPipelineState* inoutPipeline)
         int32_t mapIndex = 0;
         for (mapIndex = 0; mapIndex < FFX_ARRAY_ELEMENTS(srvTextureBindingTable); ++mapIndex)
         {
-            if (0 == wcscmp(srvTextureBindingTable[mapIndex].name, inoutPipeline->srvTextureBindings[srvIndex].name))
+            if (0 == strcmp(srvTextureBindingTable[mapIndex].name, inoutPipeline->srvTextureBindings[srvIndex].name))
                 break;
         }
         if (mapIndex == FFX_ARRAY_ELEMENTS(srvTextureBindingTable))
@@ -112,7 +112,7 @@ static FfxErrorCode patchResourceBindings(FfxPipelineState* inoutPipeline)
         int32_t mapIndex = 0;
         for (mapIndex = 0; mapIndex < FFX_ARRAY_ELEMENTS(uavTextureBindingTable); ++mapIndex)
         {
-            if (0 == wcscmp(uavTextureBindingTable[mapIndex].name, inoutPipeline->uavTextureBindings[uavIndex].name))
+            if (0 == strcmp(uavTextureBindingTable[mapIndex].name, inoutPipeline->uavTextureBindings[uavIndex].name))
                 break;
         }
         if (mapIndex == FFX_ARRAY_ELEMENTS(uavTextureBindingTable))
@@ -127,7 +127,7 @@ static FfxErrorCode patchResourceBindings(FfxPipelineState* inoutPipeline)
         int32_t mapIndex = 0;
         for (mapIndex = 0; mapIndex < FFX_ARRAY_ELEMENTS(uavBufferBindingTable); ++mapIndex)
         {
-            if (0 == wcscmp(uavBufferBindingTable[mapIndex].name, inoutPipeline->uavBufferBindings[uavIndex].name))
+            if (0 == strcmp(uavBufferBindingTable[mapIndex].name, inoutPipeline->uavBufferBindings[uavIndex].name))
                 break;
         }
         if (mapIndex == FFX_ARRAY_ELEMENTS(uavBufferBindingTable))
@@ -141,7 +141,7 @@ static FfxErrorCode patchResourceBindings(FfxPipelineState* inoutPipeline)
         int32_t mapIndex = 0;
         for (mapIndex = 0; mapIndex < FFX_ARRAY_ELEMENTS(constantBufferBindingTable); ++mapIndex)
         {
-            if (0 == wcscmp(constantBufferBindingTable[mapIndex].name, inoutPipeline->constantBufferBindings[cbIndex].name))
+            if (0 == strcmp(constantBufferBindingTable[mapIndex].name, inoutPipeline->constantBufferBindings[cbIndex].name))
                 break;
         }
         if (mapIndex == FFX_ARRAY_ELEMENTS(constantBufferBindingTable))
@@ -207,22 +207,22 @@ static FfxErrorCode createPipelineStates(FfxSssrContext_Private* context)
     uint32_t contextFlags = context->contextDescription.flags;
 
     // Set up pipeline descriptor (basically RootSignature and binding)
-    wcscpy_s(pipelineDescription.name, L"SSSR-DEPTH_DOWNSAMPLE");
+    strcpy(pipelineDescription.name, "SSSR-DEPTH_DOWNSAMPLE");
     FFX_VALIDATE(context->contextDescription.backendInterface.fpCreatePipeline(&context->contextDescription.backendInterface, FFX_EFFECT_SSSR, FFX_SSSR_PASS_DEPTH_DOWNSAMPLE,
         getPipelinePermutationFlags(contextFlags, FFX_SSSR_PASS_DEPTH_DOWNSAMPLE, supportedFP16, false), &pipelineDescription, context->effectContextId, &context->pipelineDepthDownsample ));
-    wcscpy_s(pipelineDescription.name, L"SSSR-CLASSIFY_TILES");
+    strcpy(pipelineDescription.name, "SSSR-CLASSIFY_TILES");
     FFX_VALIDATE(context->contextDescription.backendInterface.fpCreatePipeline(&context->contextDescription.backendInterface, FFX_EFFECT_SSSR, FFX_SSSR_PASS_CLASSIFY_TILES,
         getPipelinePermutationFlags(contextFlags, FFX_SSSR_PASS_CLASSIFY_TILES, supportedFP16, canForceWave64), &pipelineDescription, context->effectContextId, &context->pipelineClassifyTiles));
-    wcscpy_s(pipelineDescription.name, L"SSSR-PREPARE_BLUE_NOISE_TEXTURE");
+    strcpy(pipelineDescription.name, "SSSR-PREPARE_BLUE_NOISE_TEXTURE");
     FFX_VALIDATE(context->contextDescription.backendInterface.fpCreatePipeline(&context->contextDescription.backendInterface, FFX_EFFECT_SSSR, FFX_SSSR_PASS_PREPARE_BLUE_NOISE_TEXTURE, 
         getPipelinePermutationFlags(contextFlags, FFX_SSSR_PASS_PREPARE_BLUE_NOISE_TEXTURE, supportedFP16, canForceWave64), &pipelineDescription, context->effectContextId, &context->pipelinePrepareBlueNoiseTexture));
-    wcscpy_s(pipelineDescription.name, L"SSSR-PREPARE_INDIRECT_ARGS");
+    strcpy(pipelineDescription.name, "SSSR-PREPARE_INDIRECT_ARGS");
     FFX_VALIDATE(context->contextDescription.backendInterface.fpCreatePipeline(&context->contextDescription.backendInterface, FFX_EFFECT_SSSR, FFX_SSSR_PASS_PREPARE_INDIRECT_ARGS, 
         getPipelinePermutationFlags(contextFlags, FFX_SSSR_PASS_PREPARE_INDIRECT_ARGS, supportedFP16, canForceWave64), &pipelineDescription, context->effectContextId, &context->pipelinePrepareIndirectArgs));
     
     // Indirect workloads
     pipelineDescription.indirectWorkload = 1;
-    wcscpy_s(pipelineDescription.name, L"SSSR-INTERSECTION");
+    strcpy(pipelineDescription.name, "SSSR-INTERSECTION");
     FFX_VALIDATE(context->contextDescription.backendInterface.fpCreatePipeline(&context->contextDescription.backendInterface, FFX_EFFECT_SSSR, FFX_SSSR_PASS_INTERSECTION, 
         getPipelinePermutationFlags(contextFlags ,FFX_SSSR_PASS_INTERSECTION, supportedFP16, canForceWave64), &pipelineDescription, context->effectContextId, &context->pipelineIntersection));
 
@@ -272,7 +272,7 @@ static FfxErrorCode sssrCreate(FfxSssrContext_Private* context, const FfxSssrCon
     const FfxInternalResourceDescription internalSurfaceDesc[] = {
 
         {FFX_SSSR_RESOURCE_IDENTIFIER_DEPTH_HIERARCHY,
-         L"SSSR_DepthHierarchy",
+         "SSSR_DepthHierarchy",
          FFX_RESOURCE_TYPE_TEXTURE2D,
          FFX_RESOURCE_USAGE_UAV,
          FFX_SURFACE_FORMAT_R32_FLOAT,
@@ -283,7 +283,7 @@ static FfxErrorCode sssrCreate(FfxSssrContext_Private* context, const FfxSssrCon
          {FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED}},
         
         {FFX_SSSR_RESOURCE_IDENTIFIER_RAY_LIST,
-         L"SSSR_RayList",
+         "SSSR_RayList",
          FFX_RESOURCE_TYPE_BUFFER,
          FFX_RESOURCE_USAGE_UAV,
          FFX_SURFACE_FORMAT_R32_UINT,
@@ -294,7 +294,7 @@ static FfxErrorCode sssrCreate(FfxSssrContext_Private* context, const FfxSssrCon
          {FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED}},
 
         {FFX_SSSR_RESOURCE_IDENTIFIER_DENOISER_TILE_LIST,
-         L"SSSR_DenoiserTileList",
+         "SSSR_DenoiserTileList",
          FFX_RESOURCE_TYPE_BUFFER,
          FFX_RESOURCE_USAGE_UAV,
          FFX_SURFACE_FORMAT_R32_UINT,
@@ -305,7 +305,7 @@ static FfxErrorCode sssrCreate(FfxSssrContext_Private* context, const FfxSssrCon
          {FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED}},
 
         {FFX_SSSR_RESOURCE_IDENTIFIER_RAY_COUNTER,
-         L"SSSR_RayCounter",
+         "SSSR_RayCounter",
          FFX_RESOURCE_TYPE_BUFFER,
          FFX_RESOURCE_USAGE_UAV,
          FFX_SURFACE_FORMAT_R8_UNORM,
@@ -316,7 +316,7 @@ static FfxErrorCode sssrCreate(FfxSssrContext_Private* context, const FfxSssrCon
          {FFX_RESOURCE_INIT_DATA_TYPE_VALUE, 48, 0}},
 
         {FFX_SSSR_RESOURCE_IDENTIFIER_INTERSECTION_PASS_INDIRECT_ARGS,
-         L"SSSR_IntersectionPassIndirectArgs",
+         "SSSR_IntersectionPassIndirectArgs",
          FFX_RESOURCE_TYPE_BUFFER,
          (FfxResourceUsage)(FFX_RESOURCE_USAGE_UAV | FFX_RESOURCE_USAGE_INDIRECT),
          FFX_SURFACE_FORMAT_R8_UNORM,
@@ -327,7 +327,7 @@ static FfxErrorCode sssrCreate(FfxSssrContext_Private* context, const FfxSssrCon
          {FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED}},
 
         {FFX_SSSR_RESOURCE_IDENTIFIER_EXTRACTED_ROUGHNESS,
-         L"SSSR_ExtractedRoughness",
+         "SSSR_ExtractedRoughness",
          FFX_RESOURCE_TYPE_TEXTURE2D,
          FFX_RESOURCE_USAGE_UAV,
          FFX_SURFACE_FORMAT_R8_UNORM,
@@ -338,7 +338,7 @@ static FfxErrorCode sssrCreate(FfxSssrContext_Private* context, const FfxSssrCon
          {FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED}},
 
         {FFX_SSSR_RESOURCE_IDENTIFIER_RADIANCE_0,
-         L"SSSR_Radiance0",
+         "SSSR_Radiance0",
          FFX_RESOURCE_TYPE_TEXTURE2D,
          FFX_RESOURCE_USAGE_UAV,
          FFX_SURFACE_FORMAT_R16G16B16A16_FLOAT,
@@ -349,7 +349,7 @@ static FfxErrorCode sssrCreate(FfxSssrContext_Private* context, const FfxSssrCon
          {FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED}},
 
         {FFX_SSSR_RESOURCE_IDENTIFIER_RADIANCE_1,
-         L"SSSR_Radiance1",
+         "SSSR_Radiance1",
          FFX_RESOURCE_TYPE_TEXTURE2D,
          FFX_RESOURCE_USAGE_UAV,
          FFX_SURFACE_FORMAT_R16G16B16A16_FLOAT,
@@ -360,7 +360,7 @@ static FfxErrorCode sssrCreate(FfxSssrContext_Private* context, const FfxSssrCon
          {FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED}},
 
         {FFX_SSSR_RESOURCE_IDENTIFIER_VARIANCE_0,
-         L"SSSR_Variance0",
+         "SSSR_Variance0",
          FFX_RESOURCE_TYPE_TEXTURE2D,
          FFX_RESOURCE_USAGE_UAV,
          FFX_SURFACE_FORMAT_R16_FLOAT,
@@ -371,7 +371,7 @@ static FfxErrorCode sssrCreate(FfxSssrContext_Private* context, const FfxSssrCon
          {FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED}},
 
         {FFX_SSSR_RESOURCE_IDENTIFIER_VARIANCE_1,
-         L"SSSR_Variance1",
+         "SSSR_Variance1",
          FFX_RESOURCE_TYPE_TEXTURE2D,
          FFX_RESOURCE_USAGE_UAV,
          FFX_SURFACE_FORMAT_R16_FLOAT,
@@ -382,7 +382,7 @@ static FfxErrorCode sssrCreate(FfxSssrContext_Private* context, const FfxSssrCon
          {FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED}},
 
         {FFX_SSSR_RESOURCE_IDENTIFIER_SOBOL_BUFFER,
-         L"SSSR_SobolBuffer",
+         "SSSR_SobolBuffer",
          FFX_RESOURCE_TYPE_TEXTURE2D,
          FFX_RESOURCE_USAGE_READ_ONLY,
          FFX_SURFACE_FORMAT_R32_UINT,
@@ -393,7 +393,7 @@ static FfxErrorCode sssrCreate(FfxSssrContext_Private* context, const FfxSssrCon
          {FFX_RESOURCE_INIT_DATA_TYPE_BUFFER, sizeof(_noiseBuffers::sobol_256spp_256d), (void*)_noiseBuffers::sobol_256spp_256d}},
 
         {FFX_SSSR_RESOURCE_IDENTIFIER_SCRAMBLING_TILE_BUFFER,
-         L"SSSR_ScramblingTileBuffer",
+         "SSSR_ScramblingTileBuffer",
          FFX_RESOURCE_TYPE_TEXTURE2D,
          FFX_RESOURCE_USAGE_READ_ONLY,
          FFX_SURFACE_FORMAT_R32_UINT,
@@ -404,7 +404,7 @@ static FfxErrorCode sssrCreate(FfxSssrContext_Private* context, const FfxSssrCon
          {FFX_RESOURCE_INIT_DATA_TYPE_BUFFER, sizeof(_noiseBuffers::scramblingTile), (void*)_noiseBuffers::scramblingTile}},
 
         {FFX_SSSR_RESOURCE_IDENTIFIER_BLUE_NOISE_TEXTURE,
-         L"SSSR_BlueNoiseTexture",
+         "SSSR_BlueNoiseTexture",
          FFX_RESOURCE_TYPE_TEXTURE2D,
          FFX_RESOURCE_USAGE_UAV,
          FFX_SURFACE_FORMAT_R8G8_UNORM,
@@ -415,7 +415,7 @@ static FfxErrorCode sssrCreate(FfxSssrContext_Private* context, const FfxSssrCon
          {FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED}},
 
         {FFX_SSSR_RESOURCE_IDENTIFIER_SPD_GLOBAL_ATOMIC,
-         L"SSSR_SpdAtomicCounter",
+         "SSSR_SpdAtomicCounter",
          FFX_RESOURCE_TYPE_BUFFER,
          FFX_RESOURCE_USAGE_UAV,
          FFX_SURFACE_FORMAT_R32_UINT,
@@ -521,14 +521,14 @@ static void populateComputeJobResources(FfxSssrContext_Private* context, const F
         const FfxResourceInternal currentResource = context->srvResources[currentResourceId];
         jobDescriptor->srvTextures[currentShaderResourceViewIndex].resource = currentResource;
 #ifdef FFX_DEBUG
-        wcscpy_s(jobDescriptor->srvTextures[currentShaderResourceViewIndex].name, pipeline->srvTextureBindings[currentShaderResourceViewIndex].name);
+        strcpy(jobDescriptor->srvTextures[currentShaderResourceViewIndex].name, pipeline->srvTextureBindings[currentShaderResourceViewIndex].name);
 #endif
     }
 
     uint32_t uavEntry = 0;  // Uav resource offset (accounts for uav arrays)
     for (uint32_t currentUnorderedAccessViewIndex = 0; currentUnorderedAccessViewIndex < pipeline->uavTextureCount; ++currentUnorderedAccessViewIndex) {
 #ifdef FFX_DEBUG
-        wcscpy_s(jobDescriptor->uavTextures[currentUnorderedAccessViewIndex].name, pipeline->uavTextureBindings[currentUnorderedAccessViewIndex].name);
+        strcpy(jobDescriptor->uavTextures[currentUnorderedAccessViewIndex].name, pipeline->uavTextureBindings[currentUnorderedAccessViewIndex].name);
 #endif
         const uint32_t bindEntry = pipeline->uavTextureBindings[currentUnorderedAccessViewIndex].arrayIndex;
         const uint32_t currentResourceId = pipeline->uavTextureBindings[currentUnorderedAccessViewIndex].resourceIdentifier;
@@ -547,13 +547,13 @@ static void populateComputeJobResources(FfxSssrContext_Private* context, const F
         const FfxResourceInternal currentResource = context->uavResources[currentResourceId];
         jobDescriptor->uavBuffers[currentUnorderedAccessViewIndex].resource = currentResource;
 #ifdef FFX_DEBUG
-        wcscpy_s(jobDescriptor->uavBuffers[currentUnorderedAccessViewIndex].name, pipeline->uavBufferBindings[currentUnorderedAccessViewIndex].name);
+        strcpy(jobDescriptor->uavBuffers[currentUnorderedAccessViewIndex].name, pipeline->uavBufferBindings[currentUnorderedAccessViewIndex].name);
 #endif
     }
 
     for (uint32_t currentRootConstantIndex = 0; currentRootConstantIndex < pipeline->constCount; ++currentRootConstantIndex) {
 #ifdef FFX_DEBUG
-        wcscpy_s(jobDescriptor->cbNames[currentRootConstantIndex], pipeline->constantBufferBindings[currentRootConstantIndex].name);
+        strcpy(jobDescriptor->cbNames[currentRootConstantIndex], pipeline->constantBufferBindings[currentRootConstantIndex].name);
 #endif
         jobDescriptor->cbs[currentRootConstantIndex] = context->constantBuffers[pipeline->constantBufferBindings[currentRootConstantIndex].resourceIdentifier];
     }
@@ -568,7 +568,7 @@ static void scheduleIndirectDispatch(FfxSssrContext_Private* context, const FfxP
     populateComputeJobResources(context , pipeline, &jobDescriptor);
 
     FfxGpuJobDescription dispatchJob = { FFX_GPU_JOB_COMPUTE };
-    wcscpy_s(dispatchJob.jobLabel, pipeline->name);
+    strcpy(dispatchJob.jobLabel, pipeline->name);
     dispatchJob.computeJobDescriptor = jobDescriptor;
     context->contextDescription.backendInterface.fpScheduleGpuJob(&context->contextDescription.backendInterface, &dispatchJob);
 }
@@ -576,7 +576,7 @@ static void scheduleIndirectDispatch(FfxSssrContext_Private* context, const FfxP
 static void scheduleDispatch(FfxSssrContext_Private* context, const FfxPipelineState* pipeline, uint32_t dispatchX, uint32_t dispatchY)
 {
     FfxGpuJobDescription dispatchJob = {FFX_GPU_JOB_COMPUTE};
-    wcscpy_s(dispatchJob.jobLabel, pipeline->name);
+    strcpy(dispatchJob.jobLabel, pipeline->name);
     dispatchJob.computeJobDescriptor.dimensions[0] = dispatchX;
     dispatchJob.computeJobDescriptor.dimensions[1] = dispatchY;
     dispatchJob.computeJobDescriptor.dimensions[2] = 1;
@@ -603,7 +603,7 @@ static FfxErrorCode sssrDispatch(FfxSssrContext_Private* context, const FfxSssrD
     if (context->constants.frameIndex == 0) {
         FfxGpuJobDescription job = {};
         job.jobType = FFX_GPU_JOB_CLEAR_FLOAT;
-        wcscpy_s(job.jobLabel, L"Zero initialize resource");
+        strcpy(job.jobLabel, "Zero initialize resource");
         job.clearJobDescriptor.color[0] = 0.0f;
         job.clearJobDescriptor.color[1] = 0.0f;
         job.clearJobDescriptor.color[2] = 0.0f;
diff --git a/sdk/src/components/vrs/CMakeLists.txt b/sdk/src/components/vrs/CMakeLists.txt
index 2ec3e8c..439aeea 100644
--- a/sdk/src/components/vrs/CMakeLists.txt
+++ b/sdk/src/components/vrs/CMakeLists.txt
@@ -38,9 +38,9 @@ if (FFX_VRS OR FFX_ALL)
 	list(APPEND PUBLIC_SOURCES ${FFX_PUBLIC_SOURCES})
 
 	if (FFX_BUILD_AS_DLL)
-		add_library(ffx_vrs_${FFX_PLATFORM_NAME} SHARED ${SHARED_SOURCES} ${PRIVATE_SOURCES} ${PUBLIC_SOURCES})
+		add_library(vrs SHARED ${SHARED_SOURCES} ${PRIVATE_SOURCES} ${PUBLIC_SOURCES})
 	else()
-		add_library(ffx_vrs_${FFX_PLATFORM_NAME} STATIC ${SHARED_SOURCES} ${PRIVATE_SOURCES} ${PUBLIC_SOURCES})
+		add_library(vrs STATIC ${SHARED_SOURCES} ${PRIVATE_SOURCES} ${PUBLIC_SOURCES})
 	endif()
 
 	# API
@@ -48,10 +48,17 @@ if (FFX_VRS OR FFX_ALL)
 	source_group("private_source" FILES ${PRIVATE_SOURCES})
 	source_group("public_source"  FILES ${PUBLIC_SOURCES})
 
-	target_include_directories(ffx_vrs_${FFX_PLATFORM_NAME} PUBLIC ${FFX_INCLUDE_PATH})
-	target_include_directories(ffx_vrs_${FFX_PLATFORM_NAME} PUBLIC ${FFX_SHARED_PATH})
+	target_include_directories(vrs PUBLIC
+		$<BUILD_INTERFACE:${FFX_INCLUDE_PATH}>
+		$<INSTALL_INTERFACE:include>)
+	target_include_directories(vrs PRIVATE ${FFX_SHARED_PATH})
 
 	set_source_files_properties(${SHADERS} PROPERTIES HEADER_FILE_ONLY TRUE)
-	set_target_properties(ffx_vrs_${FFX_PLATFORM_NAME} PROPERTIES FOLDER Components)
+	set_target_properties(vrs PROPERTIES FOLDER Components)
 
+	install(TARGETS vrs EXPORT vrs-targets)
+	install(EXPORT vrs-targets 
+		DESTINATION "${CMAKE_INSTALL_DATADIR}/cmake/${PROJECT_NAME}"
+		NAMESPACE fidelityfx::)
+	
 endif()
diff --git a/sdk/src/components/vrs/ffx_vrs.cpp b/sdk/src/components/vrs/ffx_vrs.cpp
index 47fbc76..984cd1d 100644
--- a/sdk/src/components/vrs/ffx_vrs.cpp
+++ b/sdk/src/components/vrs/ffx_vrs.cpp
@@ -20,8 +20,9 @@
 // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 // THE SOFTWARE.
 
+#include <array>        // for std::size
 #include <string.h>     // for memset
-#include <stdlib.h>     // for _countof
+#include <stdlib.h>     // 
 #include <cmath>        // for fabs, abs, sinf, sqrt, etc.
 
 #ifdef __clang__
@@ -42,20 +43,20 @@
 typedef struct ResourceBinding
 {
     uint32_t index;
-    wchar_t  name[64];
+    char     name[64];
 } ResourceBinding;
 
 static const ResourceBinding srvTextureBindingTable[] = {
-    {FFX_VRS_RESOURCE_IDENTIFIER_INPUT_COLOR, L"r_input_color"},
-    {FFX_VRS_RESOURCE_IDENTIFIER_INPUT_MOTIONVECTORS, L"r_input_velocity"},
+    {FFX_VRS_RESOURCE_IDENTIFIER_INPUT_COLOR, "r_input_color"},
+    {FFX_VRS_RESOURCE_IDENTIFIER_INPUT_MOTIONVECTORS, "r_input_velocity"},
 };
 
 static const ResourceBinding uavTextureBindingTable[] = {
-    {FFX_VRS_RESOURCE_IDENTIFIER_VRSIMAGE_OUTPUT, L"rw_vrsimage_output"},
+    {FFX_VRS_RESOURCE_IDENTIFIER_VRSIMAGE_OUTPUT, "rw_vrsimage_output"},
 };
 
 static const ResourceBinding cbResourceBindingTable[] = {
-    {FFX_VRS_CONSTANTBUFFER_IDENTIFIER_VRS, L"cbVRS"},
+    {FFX_VRS_CONSTANTBUFFER_IDENTIFIER_VRS, "cbVRS"},
 };
 
 static FfxErrorCode patchResourceBindings(FfxPipelineState* inoutPipeline)
@@ -64,12 +65,12 @@ static FfxErrorCode patchResourceBindings(FfxPipelineState* inoutPipeline)
     for (uint32_t srvIndex = 0; srvIndex < inoutPipeline->srvTextureCount; ++srvIndex)
     {
         int32_t mapIndex = 0;
-        for (mapIndex = 0; mapIndex < _countof(srvTextureBindingTable); ++mapIndex)
+        for (mapIndex = 0; mapIndex < std::size(srvTextureBindingTable); ++mapIndex)
         {
-            if (0 == wcscmp(srvTextureBindingTable[mapIndex].name, inoutPipeline->srvTextureBindings[srvIndex].name))
+            if (0 == strcmp(srvTextureBindingTable[mapIndex].name, inoutPipeline->srvTextureBindings[srvIndex].name))
                 break;
         }
-        if (mapIndex == _countof(srvTextureBindingTable))
+        if (mapIndex == std::size(srvTextureBindingTable))
             return FFX_ERROR_INVALID_ARGUMENT;
 
         inoutPipeline->srvTextureBindings[srvIndex].resourceIdentifier = srvTextureBindingTable[mapIndex].index;
@@ -79,12 +80,12 @@ static FfxErrorCode patchResourceBindings(FfxPipelineState* inoutPipeline)
     for (uint32_t uavIndex = 0; uavIndex < inoutPipeline->uavTextureCount; ++uavIndex)
     {
         int32_t mapIndex = 0;
-        for (mapIndex = 0; mapIndex < _countof(uavTextureBindingTable); ++mapIndex)
+        for (mapIndex = 0; mapIndex < std::size(uavTextureBindingTable); ++mapIndex)
         {
-            if (0 == wcscmp(uavTextureBindingTable[mapIndex].name, inoutPipeline->uavTextureBindings[uavIndex].name))
+            if (0 == strcmp(uavTextureBindingTable[mapIndex].name, inoutPipeline->uavTextureBindings[uavIndex].name))
                 break;
         }
-        if (mapIndex == _countof(uavTextureBindingTable))
+        if (mapIndex == std::size(uavTextureBindingTable))
             return FFX_ERROR_INVALID_ARGUMENT;
 
         inoutPipeline->uavTextureBindings[uavIndex].resourceIdentifier = uavTextureBindingTable[mapIndex].index;
@@ -94,12 +95,12 @@ static FfxErrorCode patchResourceBindings(FfxPipelineState* inoutPipeline)
     for (uint32_t cbIndex = 0; cbIndex < inoutPipeline->constCount; ++cbIndex)
     {
         int32_t mapIndex = 0;
-        for (mapIndex = 0; mapIndex < _countof(cbResourceBindingTable); ++mapIndex)
+        for (mapIndex = 0; mapIndex < std::size(cbResourceBindingTable); ++mapIndex)
         {
-            if (0 == wcscmp(cbResourceBindingTable[mapIndex].name, inoutPipeline->constantBufferBindings[cbIndex].name))
+            if (0 == strcmp(cbResourceBindingTable[mapIndex].name, inoutPipeline->constantBufferBindings[cbIndex].name))
                 break;
         }
-        if (mapIndex == _countof(cbResourceBindingTable))
+        if (mapIndex == std::size(cbResourceBindingTable))
             return FFX_ERROR_INVALID_ARGUMENT;
 
         inoutPipeline->constantBufferBindings[cbIndex].resourceIdentifier = cbResourceBindingTable[mapIndex].index;
@@ -258,7 +259,7 @@ static void scheduleDispatch(FfxVrsContext_Private*           context,
                              uint32_t                         dispatchZ)
 {
     FfxGpuJobDescription     dispatchJob   = {FFX_GPU_JOB_COMPUTE};
-    wcscpy_s(dispatchJob.jobLabel, pipeline->name);
+    strcpy(dispatchJob.jobLabel, pipeline->name);
 
     for (uint32_t currentShaderResourceViewIndex = 0; currentShaderResourceViewIndex < pipeline->srvTextureCount; ++currentShaderResourceViewIndex)
     {
@@ -266,7 +267,7 @@ static void scheduleDispatch(FfxVrsContext_Private*           context,
         const FfxResourceInternal currentResource                 = context->srvResources[currentResourceId];
         dispatchJob.computeJobDescriptor.srvTextures[currentShaderResourceViewIndex].resource = currentResource;
 #ifdef FFX_DEBUG
-        wcscpy_s(dispatchJob.computeJobDescriptor.srvTextures[currentShaderResourceViewIndex].name,
+        strcpy(dispatchJob.computeJobDescriptor.srvTextures[currentShaderResourceViewIndex].name,
                  pipeline->srvTextureBindings[currentShaderResourceViewIndex].name);
 #endif
     }
@@ -275,7 +276,7 @@ static void scheduleDispatch(FfxVrsContext_Private*           context,
     {
         const uint32_t currentResourceId = pipeline->uavTextureBindings[currentUnorderedAccessViewIndex].resourceIdentifier;
 #ifdef FFX_DEBUG
-        wcscpy_s(dispatchJob.computeJobDescriptor.uavTextures[currentUnorderedAccessViewIndex].name,
+        strcpy(dispatchJob.computeJobDescriptor.uavTextures[currentUnorderedAccessViewIndex].name,
                  pipeline->uavTextureBindings[currentUnorderedAccessViewIndex].name);
 #endif
         const FfxResourceInternal currentResource                     = context->uavResources[currentResourceId];
@@ -289,7 +290,7 @@ static void scheduleDispatch(FfxVrsContext_Private*           context,
     dispatchJob.computeJobDescriptor.pipeline      = *pipeline;
 
 #ifdef FFX_DEBUG
-    wcscpy_s(dispatchJob.computeJobDescriptor.cbNames[0], pipeline->constantBufferBindings[0].name);
+    strcpy(dispatchJob.computeJobDescriptor.cbNames[0], pipeline->constantBufferBindings[0].name);
 #endif
     dispatchJob.computeJobDescriptor.cbs[0] = context->constantBuffer;
 
diff --git a/sdk/src/shared/ffx_breadcrumbs_list.h b/sdk/src/shared/ffx_breadcrumbs_list.h
index facc77e..f6a6571 100644
--- a/sdk/src/shared/ffx_breadcrumbs_list.h
+++ b/sdk/src/shared/ffx_breadcrumbs_list.h
@@ -22,6 +22,7 @@
 
 #pragma once
 
+#include <cstring>
 #include <cstdint>
 #include <cstdio>      // sprintf_s
 #include <FidelityFX/host/ffx_assert.h>
@@ -48,7 +49,7 @@
     do                                                                           \
     {                                                                            \
         char _numberStr[maxLength];                                              \
-        const size_t _length = sprintf_s(_numberStr, maxLength, format, number); \
+        const size_t _length = snprintf(_numberStr, maxLength, format, number);  \
         buff = (char*)ffxBreadcrumbsAppendList(buff, count, 1, _length, allocs); \
         memcpy(buff + count, _numberStr, _length);                               \
         count += _length;                                                        \
@@ -116,7 +117,7 @@
     {                                                                                               \
         FFX_BREADCRUMBS_APPEND_STRING(buff, count, FFX_BREADCRUMBS_PRINTING_INDENT #member ": 0x"); \
         char _hexStr[maxLength];                                                                    \
-        const size_t _length = sprintf_s(_hexStr, maxLength, format, baseStruct.member);            \
+        const size_t _length = snprintf(_hexStr, maxLength, format, baseStruct.member);             \
         buff = (char*)ffxBreadcrumbsAppendList(buff, count, 1, _length + 1, allocs);                \
         memcpy(buff + count, _hexStr, _length);                                                     \
         count += _length;                                                                           \
diff --git a/sdk/toolchain.cmake b/sdk/toolchain.cmake
index 61aba48..00d04dc 100644
--- a/sdk/toolchain.cmake
+++ b/sdk/toolchain.cmake
@@ -29,7 +29,7 @@ endif()
 
 # Set configuration options
 set(CMAKE_CONFIGURATION_TYPES Debug Release RelWithDebInfo)
-set(CMAKE_DEBUG_POSTFIX d)
+# set(CMAKE_DEBUG_POSTFIX d)
 set_property(GLOBAL PROPERTY USE_FOLDERS ON)
 
 # Get warnings for everything
@@ -49,16 +49,16 @@ endif()
 if (FFX_API_BACKEND STREQUAL DX12_X64 OR
 	FFX_API_BACKEND STREQUAL VK_X64)
 
-	set(CMAKE_RELWITHDEBINFO_POSTFIX drel)
-	set(CMAKE_SYSTEM_NAME WINDOWS)
-	set(CMAKE_SYSTEM_VERSION 10.0)
+	# set(CMAKE_RELWITHDEBINFO_POSTFIX drel)
+	# set(CMAKE_SYSTEM_NAME WINDOWS)
+	# set(CMAKE_SYSTEM_VERSION 10.0)
 
-	set(CMAKE_GENERATOR_PLATFORM "x64" CACHE STRING "" FORCE)
-	set(CMAKE_VS_PLATFORM_NAME "x64" CACHE STRING "" FORCE)
+	# set(CMAKE_GENERATOR_PLATFORM "x64" CACHE STRING "" FORCE)
+	# set(CMAKE_VS_PLATFORM_NAME "x64" CACHE STRING "" FORCE)
 
 	# Ensure our platform toolset is x64
-	set(CMAKE_VS_PLATFORM_TOOLSET_HOST_ARCHITECTURE "x64" CACHE STRING "" FORCE)
-	
+	# set(CMAKE_VS_PLATFORM_TOOLSET_HOST_ARCHITECTURE "x64" CACHE STRING "" FORCE)
+
 elseif(FFX_API_BACKEND STREQUAL DX12_ARM64)
 
 	set(CMAKE_RELWITHDEBINFO_POSTFIX drel)
